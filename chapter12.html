<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第12章：NPU设计实战 - NPU设计教程</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .nav-bar {
            background: #34495e;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .nav-bar ul {
            list-style: none;
            display: flex;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        .nav-bar li {
            margin: 0 15px;
        }

        .nav-bar a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .nav-bar a:hover {
            background: #2c3e50;
        }

        .nav-bar .current {
            background: #2c3e50;
            font-weight: bold;
        }

        .chapter {
            background: white;
            margin: 20px 0;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chapter h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .chapter h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        .chapter h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
        }
        
        /* Language label */
        .code-block::before {
            content: attr(data-language);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            color: #95a5a6;
            text-transform: uppercase;
        }
        
        /* Syntax highlighting classes */
        .code-block .keyword { color: #e74c3c; font-weight: bold; }
        .code-block .type { color: #3498db; }
        .code-block .comment { color: #95a5a6; font-style: italic; }
        .code-block .number { color: #e67e22; }
        .code-block .string { color: #2ecc71; }
        .code-block .function { color: #3498db; }

        .exercise {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .exercise h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .question {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .answer {
            margin-top: 10px;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 5px;
            display: none;
            border-left: 4px solid #4caf50;
        }

        .answer.show {
            display: block;
        }
        
        .hint {
            margin: 10px 0;
            padding: 10px 15px;
            background: #fff8dc;
            border-left: 4px solid #ffa500;
            border-radius: 5px;
            font-size: 0.95em;
        }
        
        .hint summary {
            cursor: pointer;
            font-weight: bold;
            color: #ff8c00;
            outline: none;
        }
        
        .hint summary:hover {
            color: #ff6347;
        }
        
        .hint p {
            margin-top: 10px;
            color: #666;
        }

        .toggle-answer {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.3s;
        }

        .toggle-answer:hover {
            background: #2980b9;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .chapter-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
        }

        .chapter-nav a {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .chapter-nav a:hover {
            background: #2980b9;
        }

        .chapter-nav .prev::before {
            content: "← ";
        }

        .chapter-nav .next::after {
            content: " →";
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            header {
                padding: 20px 10px;
            }
            
            header h1 {
                font-size: 1.5em;
            }
            
            .chapter {
                padding: 15px;
                margin: 10px 0;
            }
            
            .chapter h2 {
                font-size: 1.5em;
            }
            
            .chapter h3 {
                font-size: 1.2em;
            }
            
            .nav-bar ul {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .nav-bar li {
                margin: 5px;
            }
            
            .code-block {
                padding: 10px;
                font-size: 12px;
            }
            
            table {
                font-size: 14px;
            }
            
            th, td {
                padding: 8px;
            }
        }

        /* List styles for proper indentation */
        .chapter ul, .chapter ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .chapter li {
            margin-bottom: 8px;
            line-height: 1.8;
        }
        
        .chapter ul ul, .chapter ol ol, .chapter ul ol, .chapter ol ul {
            margin-left: 20px;
            margin-top: 5px;
        }
        
        .info-box ul, .warning-box ul, .answer ul {
            margin-left: 20px;
        }
        
        .info-box li, .warning-box li, .answer li {
            margin-bottom: 10px;
        }
        
        /* Keep nav-bar lists unstyled */
        .nav-bar ul {
            margin-left: 0;
        }
        
        .nav-bar li {
            margin-bottom: 0;
        }
    </style>
    <script>
        // Syntax highlighting functions
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        function highlightSyntax() {
            const codeBlocks = document.querySelectorAll('.code-block');
            
            codeBlocks.forEach(block => {
                const content = block.textContent;
                let language = 'text';
                let highlighted = content;
                
                // Auto-detect language based on content
                if (content.includes('module ') || content.includes('always @') || content.includes('wire ') || content.includes('reg ')) {
                    language = 'verilog';
                    highlighted = highlightVerilog(content);
                } else if (content.includes('import ') || content.includes('def ') || content.includes('class ')) {
                    language = 'python';
                    highlighted = highlightPython(content);
                }
                
                block.innerHTML = highlighted;
                block.classList.add(language);
                block.setAttribute('data-language', language);
            });
        }
        
        function highlightVerilog(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments with placeholders
            code = code.replace(/(\/\/.*$|\/\*[\s\S]*?\*\/)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings with placeholders
            code = code.replace(/("[^"]*")/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(module|endmodule|input|output|wire|reg|always|assign|begin|end|if|else|for|while|parameter|posedge|negedge)\b/g;
            const types = /\b(bit|logic|byte|shortint|int|longint|integer|time|real)\b/g;
            const numbers = /\b(\d+'[hbdo][\da-fA-F_]+|\d+)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(types, '<span class="type">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        function highlightPython(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments
            code = code.replace(/(#.*$)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings
            code = code.replace(/("[^"]*"|'[^']*')/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(and|as|assert|break|class|continue|def|del|elif|else|except|False|finally|for|from|global|if|import|in|is|lambda|None|not|or|pass|raise|return|True|try|while|with|yield)\b/g;
            const builtins = /\b(abs|all|any|bin|bool|dict|float|format|hex|input|int|len|list|map|max|min|open|print|range|round|set|sorted|str|sum|tuple|type|zip)\b/g;
            const numbers = /\b(\d+\.?\d*)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(builtins, '<span class="function">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        // Toggle answer visibility
        document.addEventListener('DOMContentLoaded', function() {
            highlightSyntax();
            
            const toggleButtons = document.querySelectorAll('.toggle-answer');
            toggleButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const answer = this.nextElementSibling;
                    answer.classList.toggle('show');
                    this.textContent = answer.classList.contains('show') ? '隐藏答案' : '显示答案';
                });
            });
        });
    </script>
</head>
<body>
    <header>
        <h1>第12章：NPU设计实战</h1>
    </header>
    
    <nav class="nav-bar">
        <ul>
            <li><a href="index.html">首页</a></li>
            <li><a href="chapter1.html">第1章</a></li>
            <li><a href="chapter2.html">第2章</a></li>
            <li><a href="chapter3.html">第3章</a></li>
            <li><a href="chapter4.html">第4章</a></li>
            <li><a href="chapter5.html">第5章</a></li>
            <li><a href="chapter6.html">第6章</a></li>
            <li><a href="chapter7.html">第7章</a></li>
            <li><a href="chapter8.html">第8章</a></li>
            <li><a href="chapter9.html">第9章</a></li>
            <li><a href="chapter10.html">第10章</a></li>
            <li><a href="chapter11.html">第11章</a></li>
            <li><a href="chapter12.html" class="current">第12章</a></li>
        </ul>
    </nav>
    
    <div class="container">
        <div class="chapter">
            <h2>第12章：NPU设计实战</h2>
            
            <p>欢迎来到NPU设计的综合实战。在前面的章节中，我们已经分别探讨了神经网络的基本原理、硬件加速的核心思想、关键计算单元（如MAC阵列）以及存储架构。本章将扮演一个"总装车间"的角色，带领读者从零开始，经历一个完整的、符合工业界设计流程的边缘计算NPU项目。</p>
            
            <p>我们将不仅仅是展示最终的代码，更重要的是，我们将深入探讨"为什么"这么设计。每一行代码、每一个架构决策背后，都有其性能、功耗、面积（PPA）上的权衡。本章的目标是让读者不仅能看懂一个NPU设计，更能理解其背后的设计哲学和工程实践，从而具备独立设计和评估NPU的能力。让我们从项目的第一步——需求分析开始。</p>

            <h3>12.1 项目需求分析</h3>
            
            <p>所有设计的源头是需求。硬件设计不是凭空创造，而是为了解决特定问题。在开始设计之前，需要明确项目目标、应用场景和关键性能指标。本节将详细分析边缘AI NPU的需求。</p>

            <h4>12.1.1 应用场景定义</h4>
            
            <div class="info-box">
                <h5>什么是边缘AI？</h5>
                <p>边缘AI是相对于云端AI的概念。它将AI计算能力部署在靠近数据源的"边缘"设备上，具有以下优势：</p>
                <ul>
                    <li><strong>低延迟</strong>：无需将数据传输到云端，实时响应（毫秒级）</li>
                    <li><strong>数据隐私</strong>：敏感数据无需离开本地设备</li>
                    <li><strong>低功耗</strong>：专用硬件设计，能效比远超通用处理器</li>
                    <li><strong>网络无关性</strong>：即使没有网络连接也能正常工作</li>
                </ul>
            </div>
            
            <p>我们选择以下四个应用场景作为设计目标，它们代表了不同的工作负载类型和性能要求：</p>
            
            <ul>
                <li><strong>智能摄像头</strong>：
                    <ul>
                        <li>应用：实时目标检测、人脸识别</li>
                        <li>特点：典型CNN应用，对吞吐率（FPS）和延迟要求高</li>
                        <li>挑战：需要处理高分辨率视频流（1080p@30fps）</li>
                    </ul>
                </li>
                <li><strong>智能家居（语音处理）</strong>：
                    <ul>
                        <li>应用：语音识别、自然语言处理</li>
                        <li>特点：可能是RNN或小型Transformer，对实时响应和低功耗待机要求高</li>
                        <li>挑战：需要支持长时间待机，响应延迟<200ms</li>
                    </ul>
                </li>
                <li><strong>工业检测</strong>：
                    <ul>
                        <li>应用：缺陷检测、质量控制</li>
                        <li>特点：对精度和可靠性要求极高，模型可能更复杂</li>
                        <li>挑战：需要支持高精度推理（FP16），错误率<0.1%</li>
                    </ul>
                </li>
                <li><strong>移动设备</strong>：
                    <ul>
                        <li>应用：图像增强、AR/VR处理</li>
                        <li>特点：对能效（电池寿命）的要求是第一位的</li>
                        <li>挑战：功耗预算极其有限（<2W），需要处理多种混合任务</li>
                    </ul>
                </li>
                <li><strong>具身智能</strong>：
                    <ul>
                        <li>应用：机器人感知与控制、自主导航、人机交互</li>
                        <li>特点：需要融合多模态感知（视觉、触觉、力觉）和实时决策</li>
                        <li>挑战：超低延迟控制环路（<10ms），多传感器数据融合，动态环境适应</li>
                    </ul>
                </li>
            </ul>
            
            <p class="highlight-box">
                <strong>设计启示：</strong>这些不同的应用场景会直接影响我们在第2章和第3章学到的不同网络模型（如CNN、Transformer）的选择，并最终决定了我们在12.2节中架构设计的侧重点。一个优秀的NPU设计应该能够灵活地适应这些不同的工作负载。
            </p>

            <h4>12.1.2 性能需求分析</h4>
            
            <p>为了将模糊的应用需求转化为清晰的工程目标，我们需要定义一系列可量化的性能指标（Key Performance Indicators, KPIs）。这就像在建造一座大楼前，必须有明确的图纸，标明高度、承重、面积等。在NPU设计中，这些指标将成为我们后续所有设计、验证和优化工作的"黄金标准"。下面的<code>NPU_Requirements</code>结构体，就是我们将这些需求代码化的第一步，它将作为我们设计和验证的"合同"（Specification as Code）。</p>
            
            <div class="code-block">
// NPU性能需求定义
typedef struct {
    // 算力需求
    uint32_t peak_tops;        // 峰值算力 (TOPS)
    uint32_t sustained_tops;   // 持续算力 (TOPS)
    
    // 功耗约束
    uint16_t tdp_watts;        // 热设计功耗 (W)
    uint16_t idle_mw;          // 待机功耗 (mW)
    
    // 内存需求
    uint32_t sram_size_mb;     // 片上SRAM (MB)
    uint32_t ddr_bandwidth_gb; // DDR带宽 (GB/s)
    
    // 支持的模型
    uint8_t support_cnn;       // CNN支持
    uint8_t support_rnn;       // RNN支持
    uint8_t support_transformer; // Transformer支持
    
    // 精度支持
    uint8_t fp32_support;      // FP32
    uint8_t fp16_support;      // FP16
    uint8_t int8_support;      // INT8
    uint8_t int4_support;      // INT4
} NPU_Requirements;

// 边缘AI NPU需求实例
NPU_Requirements edge_npu_req = {
    .peak_tops = 8,            // 8 TOPS峰值算力
    .sustained_tops = 6,       // 6 TOPS持续算力
    .tdp_watts = 5,            // 5W TDP
    .idle_mw = 100,            // 100mW待机
    .sram_size_mb = 4,         // 4MB片上SRAM
    .ddr_bandwidth_gb = 16,    // 16GB/s DDR带宽
    .support_cnn = 1,          // 支持CNN
    .support_rnn = 1,          // 支持RNN
    .support_transformer = 1,   // 支持Transformer
    .fp32_support = 0,         // 不支持FP32
    .fp16_support = 1,         // 支持FP16
    .int8_support = 1,         // 支持INT8
    .int4_support = 1          // 支持INT4
};
            </div>

            <h4>12.1.3 目标模型分析</h4>
            <div class="code-block">
// 目标模型工作负载分析
module WorkloadAnalyzer #(
    parameter MODEL_COUNT = 8,
    parameter LAYER_MAX = 256
)(
    input wire clk,
    input wire rst_n,
    
    // 模型输入
    input wire [7:0] model_id,
    input wire model_load,
    
    // 层信息输入
    input wire [7:0] layer_type,      // 0:CONV 1:FC 2:POOL 3:ATTN
    input wire [31:0] layer_ops,      // 操作数
    input wire [31:0] layer_params,   // 参数量
    input wire [31:0] layer_activations, // 激活值大小
    
    // 分析输出
    output reg [63:0] total_ops,
    output reg [63:0] total_params,
    output reg [63:0] total_activations,
    output reg [7:0] bottleneck_layer,
    output reg [2:0] bottleneck_type,  // 0:计算 1:内存 2:带宽
    output reg analysis_done
);
    
    // 模型统计存储
    reg [63:0] model_ops [MODEL_COUNT-1:0];
    reg [63:0] model_params [MODEL_COUNT-1:0];
    reg [63:0] model_acts [MODEL_COUNT-1:0];
    
    // 层统计
    reg [7:0] layer_count;
    reg [31:0] layer_compute_intensity [LAYER_MAX-1:0];
    reg [31:0] layer_memory_footprint [LAYER_MAX-1:0];
    reg [31:0] layer_bandwidth_req [LAYER_MAX-1:0];
    
    // 分析状态机
    typedef enum logic [2:0] {
        IDLE,
        COLLECT,
        ANALYZE,
        REPORT
    } analyzer_state_t;
    
    analyzer_state_t state;
    
    // 计算强度分析
    function [31:0] calc_compute_intensity;
        input [31:0] ops, params, acts;
        begin
            // 计算密度 = 操作数 / (参数+激活值)
            calc_compute_intensity = ops / ((params + acts) >> 10); // KB为单位
        end
    endfunction
    
    // 带宽需求分析
    function [31:0] calc_bandwidth_req;
        input [7:0] ltype;
        input [31:0] params, acts;
        begin
            case (ltype)
                8'd0: begin // CONV
                    // 卷积层需要读取权重和输入，写入输出
                    calc_bandwidth_req = (params + acts * 2) >> 20; // MB
                end
                8'd1: begin // FC
                    // 全连接层带宽密集
                    calc_bandwidth_req = (params + acts) >> 20;
                end
                8'd3: begin // ATTN
                    // 注意力层需要大量中间结果存储
                    calc_bandwidth_req = (acts * 4) >> 20; // QKV + output
                end
                default: begin
                    calc_bandwidth_req = acts >> 20;
                end
            endcase
        end
    endfunction
    
    // 主状态机
    always @(posedge clk) begin
        if (!rst_n) begin
            state <= IDLE;
            layer_count <= 0;
            analysis_done <= 0;
            total_ops <= 0;
            total_params <= 0;
            total_activations <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (model_load) begin
                        state <= COLLECT;
                        layer_count <= 0;
                        analysis_done <= 0;
                    end
                end
                
                COLLECT: begin
                    // 收集层信息
                    layer_compute_intensity[layer_count] <= 
                        calc_compute_intensity(layer_ops, layer_params, layer_activations);
                    layer_memory_footprint[layer_count] <= 
                        (layer_params + layer_activations) >> 20; // MB
                    layer_bandwidth_req[layer_count] <= 
                        calc_bandwidth_req(layer_type, layer_params, layer_activations);
                    
                    // 累计统计
                    total_ops <= total_ops + layer_ops;
                    total_params <= total_params + layer_params;
                    total_activations <= total_activations + layer_activations;
                    
                    layer_count <= layer_count + 1;
                    
                    if (layer_count == LAYER_MAX - 1) begin
                        state <= ANALYZE;
                    end
                end
                
                ANALYZE: begin
                    // 找出瓶颈层
                    reg [31:0] max_compute_req, max_memory_req, max_bandwidth_req;
                    reg [7:0] compute_bottleneck, memory_bottleneck, bandwidth_bottleneck;
                    
                    max_compute_req = 0;
                    max_memory_req = 0;
                    max_bandwidth_req = 0;
                    
                    for (int i = 0; i < layer_count; i++) begin
                        // 计算瓶颈
                        if (layer_ops[i] > max_compute_req) begin
                            max_compute_req = layer_ops[i];
                            compute_bottleneck = i;
                        end
                        
                        // 内存瓶颈
                        if (layer_memory_footprint[i] > max_memory_req) begin
                            max_memory_req = layer_memory_footprint[i];
                            memory_bottleneck = i;
                        end
                        
                        // 带宽瓶颈
                        if (layer_bandwidth_req[i] > max_bandwidth_req) begin
                            max_bandwidth_req = layer_bandwidth_req[i];
                            bandwidth_bottleneck = i;
                        end
                    end
                    
                    // 确定主要瓶颈
                    if (max_compute_req > max_memory_req && max_compute_req > max_bandwidth_req) begin
                        bottleneck_layer <= compute_bottleneck;
                        bottleneck_type <= 3'b000; // 计算瓶颈
                    end else if (max_memory_req > max_bandwidth_req) begin
                        bottleneck_layer <= memory_bottleneck;
                        bottleneck_type <= 3'b001; // 内存瓶颈
                    end else begin
                        bottleneck_layer <= bandwidth_bottleneck;
                        bottleneck_type <= 3'b010; // 带宽瓶颈
                    end
                    
                    state <= REPORT;
                end
                
                REPORT: begin
                    // 保存分析结果
                    model_ops[model_id] <= total_ops;
                    model_params[model_id] <= total_params;
                    model_acts[model_id] <= total_activations;
                    
                    analysis_done <= 1;
                    state <= IDLE;
                end
            endcase
        end
    end
endmodule
            </div>

            <h4>12.1.4 设计约束定义</h4>
            <div class="code-block">
// 设计约束参数
module DesignConstraints;
    // 工艺约束
    parameter PROCESS_NODE = 16;        // 16nm工艺
    parameter VOLTAGE_NOMINAL = 0.8;    // 0.8V标称电压
    parameter FREQ_TARGET = 1000;       // 1GHz目标频率
    
    // 面积约束
    parameter DIE_AREA_MM2 = 25;        // 25mm²芯片面积
    parameter COMPUTE_AREA_PCT = 60;    // 60%用于计算
    parameter SRAM_AREA_PCT = 30;       // 30%用于SRAM
    parameter IO_AREA_PCT = 10;         // 10%用于IO
    
    // 功耗预算
    parameter POWER_COMPUTE = 3.0;      // 3W计算功耗
    parameter POWER_MEMORY = 1.5;       // 1.5W内存功耗
    parameter POWER_IO = 0.5;           // 0.5W IO功耗
    
    // 性能目标
    parameter MAC_UNITS = 2048;         // 2048个MAC单元
    parameter SIMD_WIDTH = 128;         // 128位SIMD宽度
    parameter PIPELINE_DEPTH = 8;       // 8级流水线
    
    // 内存层次
    parameter L1_SIZE_KB = 64;          // 64KB L1缓存
    parameter L2_SIZE_KB = 512;         // 512KB L2缓存
    parameter L3_SIZE_MB = 4;           // 4MB L3缓存
    
    // 接口规格
    parameter PCIE_GEN = 4;             // PCIe Gen4
    parameter PCIE_LANES = 4;           // x4通道
    parameter DDR_TYPE = "LPDDR4";      // LPDDR4内存
    parameter DDR_WIDTH = 64;           // 64位宽度
endmodule
            </div>

            <div class="exercise">
                <h4>练习 1：需求分析与规格定义</h4>
                <p>假设你需要为自动驾驶应用设计一个NPU，该NPU需要实时处理来自多个摄像头的视频流，执行目标检测、语义分割和路径规划。请：</p>
                <ol>
                    <li>定义具体的性能需求（算力、延迟、功耗）</li>
                    <li>分析主要的工作负载特征</li>
                    <li>确定关键的设计约束</li>
                    <li>编写需求规格文档的RTL结构体</li>
                </ol>
                
                <details class="hint">
                    <summary>💡 提示</summary>
                    <p>思考方向：自动驾驶需要实时性（<100ms延迟）、高可靠性、功耗受限（车载<50W）。工作负载包括CNN（检测）、FCN（分割）、RNN（预测）。考虑多模型并行、确定性延迟、功能安全等约束。</p>
                </details>
                <button class="toggle-answer">显示答案</button>
                <div class="answer">
                    <div class="code-block">
// 自动驾驶NPU需求定义
typedef struct {
    // 性能需求
    uint32_t min_fps;          // 最小帧率要求
    uint32_t camera_count;     // 摄像头数量
    uint32_t resolution;       // 处理分辨率
    uint32_t latency_ms;       // 端到端延迟
    
    // 算力需求
    uint32_t detection_tops;   // 目标检测算力
    uint32_t segmentation_tops; // 语义分割算力
    uint32_t planning_tops;    // 路径规划算力
    
    // 功耗约束
    uint16_t max_power_w;      // 最大功耗
    uint16_t typical_power_w;  // 典型功耗
    uint8_t thermal_grade;     // 温度等级
    
    // 可靠性需求
    uint8_t asil_level;        // 汽车安全完整性等级
    uint8_t ecc_support;       // ECC支持
    uint8_t redundancy;        // 冗余设计
} AutomotiveNPU_Spec;

// 具体需求实例
AutomotiveNPU_Spec auto_npu_spec = {
    // 性能需求
    .min_fps = 30,             // 30 FPS最小帧率
    .camera_count = 8,         // 8个摄像头
    .resolution = 1920*1080,   // 1080p分辨率
    .latency_ms = 100,         // 100ms最大延迟
    
    // 算力需求（总计50 TOPS）
    .detection_tops = 20,      // 20 TOPS用于检测
    .segmentation_tops = 20,   // 20 TOPS用于分割
    .planning_tops = 10,       // 10 TOPS用于规划
    
    // 功耗约束
    .max_power_w = 30,         // 30W最大功耗
    .typical_power_w = 20,     // 20W典型功耗
    .thermal_grade = 125,      // 125°C车规级
    
    // 可靠性需求
    .asil_level = 3,           // ASIL-C等级
    .ecc_support = 1,          // 支持ECC
    .redundancy = 2            // 双核冗余
};

// 工作负载特征分析
module AutomotiveWorkloadProfile;
    // YOLO目标检测特征
    parameter YOLO_LAYERS = 53;
    parameter YOLO_GFLOPS = 65;
    parameter YOLO_PARAMS_MB = 250;
    parameter YOLO_BATCH = 8;      // 8路摄像头
    
    // DeepLabV3语义分割特征
    parameter DEEPLAB_LAYERS = 101;
    parameter DEEPLAB_GFLOPS = 120;
    parameter DEEPLAB_PARAMS_MB = 180;
    parameter DEEPLAB_RESOLUTION = 1024;
    
    // 路径规划网络特征
    parameter PLANNING_RNN_LAYERS = 4;
    parameter PLANNING_HIDDEN_SIZE = 512;
    parameter PLANNING_SEQUENCE_LEN = 100;
    
    // 内存需求计算
    parameter TOTAL_PARAMS_MB = YOLO_PARAMS_MB + DEEPLAB_PARAMS_MB + 50;
    parameter ACTIVATION_BUFFER_MB = 512;  // 中间激活值缓存
    parameter TOTAL_SRAM_MB = 16;          // 片上SRAM需求
    
    // 带宽需求计算
    parameter PIXEL_BANDWIDTH_GB = 8 * 1920 * 1080 * 3 * 30 / 1e9; // 11.9 GB/s
    parameter WEIGHT_BANDWIDTH_GB = TOTAL_PARAMS_MB * 30 / 1000;    // 14.1 GB/s
    parameter TOTAL_BANDWIDTH_GB = PIXEL_BANDWIDTH_GB + WEIGHT_BANDWIDTH_GB; // 26 GB/s
endmodule

// 设计约束定义
module AutomotiveDesignConstraints;
    // 安全性约束
    parameter LOCKSTEP_CORES = 1;      // 锁步核心
    parameter ECC_PROTECTION = 1;      // ECC保护
    parameter PARITY_CHECK = 1;        // 奇偶校验
    parameter BIST_SUPPORT = 1;        // 内建自测试
    
    // 实时性约束
    parameter MAX_LATENCY_CYCLES = 100_000_000; // 1GHz下100ms
    parameter DETERMINISTIC_EXEC = 1;   // 确定性执行
    parameter PRIORITY_LEVELS = 4;      // 4级优先级
    
    // 接口约束
    parameter CAMERA_INTERFACES = 8;    // 8路MIPI CSI-2
    parameter CAN_FD_SUPPORT = 1;       // CAN-FD支持
    parameter ETHERNET_AVB = 1;         // 汽车以太网
    
    // 温度和电压范围
    parameter TEMP_MIN = -40;           // -40°C
    parameter TEMP_MAX = 125;           // +125°C
    parameter VDD_MIN = 0.72;           // 0.72V
    parameter VDD_MAX = 0.88;           // 0.88V
endmodule
                    </div>
                    <p><strong>解析：</strong></p>
                    <ul>
                        <li>自动驾驶NPU需要处理多路高分辨率视频，算力需求达50 TOPS</li>
                        <li>实时性要求严格，端到端延迟不超过100ms</li>
                        <li>需要满足汽车安全标准（ASIL-C），包含冗余设计和ECC保护</li>
                        <li>工作温度范围宽（-40°C到+125°C），需要车规级设计</li>
                        <li>带宽需求高（26 GB/s），需要优化内存访问模式</li>
                    </ul>
                </div>
            </div>

            <div class="exercise">
                <h4>练习 2：性能建模与预测</h4>
                <p>基于给定的NPU规格，建立一个性能预测模型，能够：</p>
                <ol>
                    <li>根据硬件配置预测理论峰值性能</li>
                    <li>考虑内存带宽限制的实际性能</li>
                    <li>评估不同工作负载的性能</li>
                </ol>
                
                <details class="hint">
                    <summary>💡 提示</summary>
                    <p>思考方向：理论峰值=MAC数×频率×2。实际性能受限于min(计算性能, 内存带宽/计算强度)。不同层的计算强度不同（FC层高，DW卷积低）。建立roofline模型来预测性能。</p>
                </details>
                <button class="toggle-answer">显示答案</button>
                <div class="answer">
                    <div class="code-block">
module PerformanceModel #(
    parameter MAC_UNITS = 2048,
    parameter FREQUENCY_MHZ = 1000,
    parameter SRAM_SIZE_MB = 4,
    parameter DDR_BANDWIDTH_GB = 16,
    parameter DATA_WIDTH = 8  // INT8
)(
    input wire clk,
    input wire rst_n,
    
    // 工作负载参数
    input wire [31:0] layer_macs,        // MAC操作数
    input wire [31:0] weight_size_kb,    // 权重大小
    input wire [31:0] activation_size_kb, // 激活值大小
    input wire [7:0] reuse_factor,       // 数据重用因子
    
    // 性能预测输出
    output reg [31:0] compute_cycles,
    output reg [31:0] memory_cycles,
    output reg [31:0] total_cycles,
    output reg [15:0] achieved_tops,
    output reg [7:0] efficiency_percent
);
    
    // 计算理论峰值性能
    localparam PEAK_OPS_PER_CYCLE = MAC_UNITS * 2; // 2 ops per MAC
    localparam PEAK_TOPS = PEAK_OPS_PER_CYCLE * FREQUENCY_MHZ / 1000;
    
    // 内存带宽参数
    localparam SRAM_BANDWIDTH_GB = SRAM_SIZE_MB * FREQUENCY_MHZ / 250; // 假设4周期访问
    localparam EFFECTIVE_DDR_BW_GB = DDR_BANDWIDTH_GB * 70 / 100; // 70%效率
    
    // 计算所需周期
    always @(*) begin
        // 计算周期 = MAC操作数 / 每周期MAC数
        compute_cycles = layer_macs / MAC_UNITS;
        
        // 内存周期计算
        reg [31:0] sram_data_kb, ddr_data_kb;
        reg [31:0] sram_cycles, ddr_cycles;
        
        // 估算SRAM可以容纳的数据
        if (weight_size_kb + activation_size_kb <= SRAM_SIZE_MB * 1024) begin
            // 全部在SRAM中
            sram_data_kb = weight_size_kb + activation_size_kb;
            ddr_data_kb = 0;
        end else begin
            // 部分在SRAM，部分需要从DDR读取
            sram_data_kb = SRAM_SIZE_MB * 1024;
            ddr_data_kb = (weight_size_kb + activation_size_kb - sram_data_kb) / reuse_factor;
        end
        
        // 计算内存访问周期
        sram_cycles = (sram_data_kb * 1024) / (SRAM_BANDWIDTH_GB * 1000 * 1000 / FREQUENCY_MHZ);
        ddr_cycles = (ddr_data_kb * 1024) / (EFFECTIVE_DDR_BW_GB * 1000 * 1000 / FREQUENCY_MHZ);
        
        memory_cycles = sram_cycles > ddr_cycles ? sram_cycles : ddr_cycles;
        
        // 总周期取计算和内存的最大值
        total_cycles = compute_cycles > memory_cycles ? compute_cycles : memory_cycles;
        
        // 实际达到的性能
        achieved_tops = (layer_macs * 2 * FREQUENCY_MHZ) / (total_cycles * 1000 * 1000);
        
        // 效率百分比
        efficiency_percent = (achieved_tops * 100) / PEAK_TOPS;
    end
    
    // 性能瓶颈分析
    reg [2:0] bottleneck_type; // 0:计算 1:SRAM带宽 2:DDR带宽
    always @(*) begin
        if (compute_cycles >= memory_cycles) begin
            bottleneck_type = 3'b000; // 计算瓶颈
        end else if (sram_cycles >= ddr_cycles) begin
            bottleneck_type = 3'b001; // SRAM带宽瓶颈
        end else begin
            bottleneck_type = 3'b010; // DDR带宽瓶颈
        end
    end
    
    // 优化建议生成
    reg [127:0] optimization_hint;
    always @(*) begin
        case (bottleneck_type)
            3'b000: optimization_hint = "Compute bound: consider increasing MAC units";
            3'b001: optimization_hint = "SRAM BW bound: optimize data layout and reuse";
            3'b010: optimization_hint = "DDR BW bound: increase on-chip buffer size";
            default: optimization_hint = "Balanced design";
        endcase
    end
endmodule

// 多层网络性能评估
module NetworkPerformanceEvaluator #(
    parameter MAX_LAYERS = 256
)(
    input wire clk,
    input wire rst_n,
    
    // 网络输入
    input wire network_start,
    input wire [7:0] network_id,
    input wire [7:0] num_layers,
    
    // 逐层性能数据
    input wire [31:0] layer_cycles [MAX_LAYERS-1:0],
    input wire [15:0] layer_tops [MAX_LAYERS-1:0],
    
    // 网络级性能输出
    output reg [63:0] total_inference_cycles,
    output reg [31:0] average_tops,
    output reg [7:0] min_efficiency_layer,
    output reg [15:0] inference_latency_ms,
    output reg eval_done
);
    
    // 评估状态机
    reg [2:0] eval_state;
    reg [7:0] layer_idx;
    reg [63:0] cycle_accumulator;
    reg [31:0] tops_accumulator;
    reg [7:0] min_eff_layer;
    reg [15:0] min_efficiency;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            eval_state <= 0;
            eval_done <= 0;
        end else begin
            case (eval_state)
                3'b000: begin // 空闲
                    if (network_start) begin
                        eval_state <= 3'b001;
                        layer_idx <= 0;
                        cycle_accumulator <= 0;
                        tops_accumulator <= 0;
                        min_efficiency <= 16'hFFFF;
                        eval_done <= 0;
                    end
                end
                
                3'b001: begin // 累加层统计
                    if (layer_idx < num_layers) begin
                        cycle_accumulator <= cycle_accumulator + layer_cycles[layer_idx];
                        tops_accumulator <= tops_accumulator + layer_tops[layer_idx];
                        
                        // 跟踪最低效率层
                        if (layer_tops[layer_idx] < min_efficiency) begin
                            min_efficiency <= layer_tops[layer_idx];
                            min_eff_layer <= layer_idx;
                        end
                        
                        layer_idx <= layer_idx + 1;
                    end else begin
                        eval_state <= 3'b010;
                    end
                end
                
                3'b010: begin // 计算网络级指标
                    total_inference_cycles <= cycle_accumulator;
                    average_tops <= tops_accumulator / num_layers;
                    min_efficiency_layer <= min_eff_layer;
                    
                    // 计算推理延迟 (ms)
                    inference_latency_ms <= (cycle_accumulator * 1000) / (1000 * 1000 * 1000); // 假设1GHz
                    
                    eval_done <= 1;
                    eval_state <= 3'b000;
                end
            endcase
        end
    end
endmodule
                    </div>
                    <p><strong>解析：</strong></p>
                    <ul>
                        <li>性能模型考虑了计算能力和内存带宽两个主要因素</li>
                        <li>通过比较计算周期和内存访问周期，识别性能瓶颈</li>
                        <li>数据重用因子反映了算法优化对内存访问的影响</li>
                        <li>网络级评估器可以分析整个模型的性能，找出效率最低的层</li>
                        <li>模型输出包括实际TOPS、效率百分比和优化建议</li>
                    </ul>
                </div>
            </div>

            <h3>12.2 架构设计实践</h3>
            
            <p>基于需求分析，本节将设计NPU的整体架构，包括计算核心、存储层次、互连网络和控制系统。</p>

            <h4>12.2.1 整体架构设计</h4>
            <div class="code-block">
// NPU顶层架构定义
module EdgeNPU_Top #(
    parameter NUM_CLUSTERS = 4,
    parameter MACS_PER_CLUSTER = 512,
    parameter SRAM_SIZE_PER_CLUSTER_KB = 1024,
    parameter GLOBAL_BUFFER_MB = 4
)(
    input wire clk,
    input wire rst_n,
    
    // 主机接口
    input wire pcie_clk,
    input wire [63:0] pcie_data_in,
    output wire [63:0] pcie_data_out,
    input wire pcie_valid,
    output wire pcie_ready,
    
    // DDR接口
    output wire [31:0] ddr_addr,
    inout wire [63:0] ddr_data,
    output wire ddr_wen,
    output wire ddr_ren,
    input wire ddr_ready,
    
    // 状态和控制
    output wire [3:0] npu_state,
    output wire [31:0] performance_counter,
    output wire [15:0] power_state
);
    
    // 全局控制器
    wire [31:0] global_pc;
    wire [127:0] global_instruction;
    wire global_inst_valid;
    
    GlobalController #(
        .INST_CACHE_SIZE_KB(64)
    ) global_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .pc(global_pc),
        .instruction(global_instruction),
        .inst_valid(global_inst_valid),
        .pcie_cmd_in(pcie_data_in),
        .pcie_cmd_valid(pcie_valid),
        .state_out(npu_state)
    );
    
    // 计算簇阵列
    wire [NUM_CLUSTERS-1:0] cluster_enable;
    wire [NUM_CLUSTERS-1:0] cluster_busy;
    wire [31:0] cluster_results [NUM_CLUSTERS-1:0];
    
    genvar i;
    generate
        for (i = 0; i < NUM_CLUSTERS; i = i + 1) begin : cluster_gen
            ComputeCluster #(
                .CLUSTER_ID(i),
                .NUM_MACS(MACS_PER_CLUSTER),
                .LOCAL_SRAM_KB(SRAM_SIZE_PER_CLUSTER_KB)
            ) cluster (
                .clk(clk),
                .rst_n(rst_n),
                .enable(cluster_enable[i]),
                .instruction(global_instruction),
                .inst_valid(global_inst_valid),
                .busy(cluster_busy[i]),
                .result_out(cluster_results[i]),
                .gl_buffer_read_addr(),
                .gl_buffer_read_data(),
                .gl_buffer_write_addr(),
                .gl_buffer_write_data(),
                .gl_buffer_write_en()
            );
        end
    endgenerate
    
    // 全局缓冲器
    GlobalBuffer #(
        .SIZE_MB(GLOBAL_BUFFER_MB),
        .NUM_BANKS(16),
        .NUM_PORTS(NUM_CLUSTERS * 2)
    ) global_buffer (
        .clk(clk),
        .rst_n(rst_n),
        // 连接到各个簇的读写端口
    );
    
    // NoC互连网络
    NetworkOnChip #(
        .NUM_NODES(NUM_CLUSTERS + 2), // +2 for global buffer and DDR
        .FLIT_WIDTH(128),
        .VC_NUM(4)
    ) noc (
        .clk(clk),
        .rst_n(rst_n)
        // 路由和仲裁逻辑
    );
    
    // DDR控制器
    DDRController #(
        .DATA_WIDTH(64),
        .ADDR_WIDTH(32),
        .BURST_LENGTH(8)
    ) ddr_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .ddr_clk(clk),
        .addr_out(ddr_addr),
        .data_io(ddr_data),
        .wen(ddr_wen),
        .ren(ddr_ren),
        .ready_in(ddr_ready)
    );
    
    // 电源管理单元
    PowerManagementUnit #(
        .NUM_DOMAINS(NUM_CLUSTERS + 1)
    ) pmu (
        .clk(clk),
        .rst_n(rst_n),
        .activity_level(cluster_busy),
        .power_state(power_state),
        .dvfs_enable(),
        .power_gate_ctrl()
    );
endmodule
            </div>

            <h4>12.2.2 计算簇设计</h4>
            <div class="code-block">
// 优化的计算簇架构 - Verilog版本
module ComputeCluster #(
    parameter CLUSTER_ID = 0,
    parameter NUM_MACS = 512,
    parameter LOCAL_SRAM_KB = 1024,
    parameter PE_ARRAY_DIM = 16,  // 16x16 PE阵列
    parameter PIPELINE_STAGES = 4
)(
    input wire clk,
    input wire rst_n,
    
    // 控制接口
    input wire enable,
    input wire [127:0] instruction,
    input wire inst_valid,
    output reg busy,
    output reg done,
    output reg [31:0] result_out,
    output reg result_valid,
    
    // 全局缓冲器接口 - 流水线化
    output reg [19:0] gl_buffer_read_addr,
    output reg gl_buffer_read_req,
    input wire [255:0] gl_buffer_read_data,
    input wire gl_buffer_read_valid,
    
    output reg [19:0] gl_buffer_write_addr,
    output reg [255:0] gl_buffer_write_data,
    output reg gl_buffer_write_en,
    input wire gl_buffer_write_ack,
    
    // 本地SRAM接口 - 流水线化
    output reg [16:0] local_sram_addr,
    output reg [255:0] local_sram_write_data,
    output reg local_sram_write_en,
    output reg [2:0] local_sram_bank_sel,
    input wire [255:0] local_sram_read_data,
    input wire local_sram_read_valid
);
    
    // 指令解码 - 流水线寄存器
    reg [127:0] instruction_reg;
    reg [7:0] opcode;
    reg [3:0] dataflow_mode;
    reg [7:0] tile_m, tile_n, tile_k;
    reg [15:0] base_addr_a, base_addr_b, base_addr_c;
    reg decode_valid;
    
    // 指令解码流水线
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            instruction_reg <= 128'd0;
            opcode <= 8'd0;
            dataflow_mode <= 4'd0;
            {tile_m, tile_n, tile_k} <= 24'd0;
            {base_addr_a, base_addr_b, base_addr_c} <= 48'd0;
            decode_valid <= 1'b0;
        end else begin
            if (inst_valid && enable) begin
                instruction_reg <= instruction;
                decode_valid <= 1'b1;
            end else begin
                decode_valid <= 1'b0;
            end
            
            // 流水线级别1: 解码基本字段
            if (decode_valid) begin
                opcode <= instruction_reg[127:120];
                dataflow_mode <= instruction_reg[119:116];
            end
            
            // 流水线级别2: 解码地址和维度
            tile_m <= instruction_reg[115:108];
            tile_n <= instruction_reg[107:100];
            tile_k <= instruction_reg[99:92];
            base_addr_a <= instruction_reg[91:76];
            base_addr_b <= instruction_reg[75:60];
            base_addr_c <= instruction_reg[59:44];
        end
    end
    
    // PE阵列信号
    reg [PE_ARRAY_DIM-1:0][7:0] pe_data_in_h_reg;  // 水平输入寄存器
    reg [PE_ARRAY_DIM-1:0][7:0] pe_data_in_v_reg;  // 垂直输入寄存器
    wire [PE_ARRAY_DIM-1:0][PE_ARRAY_DIM-1:0][31:0] pe_results;
    reg pe_array_enable;
    wire pe_array_done;
    
    // 流水线化的PE阵列
    ProcessingElementArray_Pipelined #(
        .ARRAY_DIM(PE_ARRAY_DIM),
        .DATA_WIDTH(8),
        .ACCUM_WIDTH(32),
        .PIPELINE_DEPTH(PIPELINE_STAGES)
    ) pe_array (
        .clk(clk),
        .rst_n(rst_n),
        .enable(pe_array_enable),
        .dataflow_mode(dataflow_mode),
        .data_in_h(pe_data_in_h_reg),
        .data_in_v(pe_data_in_v_reg),
        .results_out(pe_results),
        .done(pe_array_done)
    );
    
    // 本地SRAM与流水线缓冲
    reg [16:0] sram_addr_pipe [PIPELINE_STAGES-1:0];
    reg [255:0] sram_data_pipe [PIPELINE_STAGES-1:0];
    reg sram_pipe_valid [PIPELINE_STAGES-1:0];
    
    integer p;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (p = 0; p < PIPELINE_STAGES; p = p + 1) begin
                sram_addr_pipe[p] <= 17'd0;
                sram_data_pipe[p] <= 256'd0;
                sram_pipe_valid[p] <= 1'b0;
            end
        end else begin
            // 地址流水线
            sram_addr_pipe[0] <= local_sram_addr;
            sram_pipe_valid[0] <= local_sram_write_en;
            for (p = 1; p < PIPELINE_STAGES; p = p + 1) begin
                sram_addr_pipe[p] <= sram_addr_pipe[p-1];
                sram_pipe_valid[p] <= sram_pipe_valid[p-1];
            end
            
            // 数据流水线
            if (local_sram_read_valid) begin
                sram_data_pipe[0] <= local_sram_read_data;
                for (p = 1; p < PIPELINE_STAGES; p = p + 1) begin
                    sram_data_pipe[p] <= sram_data_pipe[p-1];
                end
            end
        end
    end
    
    // 数据编排器 - 流水线化
    reg [7:0] data_buffer_h [PE_ARRAY_DIM-1:0][PIPELINE_STAGES-1:0];
    reg [7:0] data_buffer_v [PE_ARRAY_DIM-1:0][PIPELINE_STAGES-1:0];
    reg data_orch_valid;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_orch_valid <= 1'b0;
            for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                for (int j = 0; j < PIPELINE_STAGES; j++) begin
                    data_buffer_h[i][j] <= 8'd0;
                    data_buffer_v[i][j] <= 8'd0;
                end
            end
        end else if (sram_pipe_valid[PIPELINE_STAGES-1]) begin
            // 根据数据流模式编排数据
            case (dataflow_mode)
                4'b0001: begin // Weight Stationary
                    for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                        data_buffer_h[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][i*8+:8];
                        data_buffer_v[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][(i+16)*8+:8];
                    end
                end
                4'b0010: begin // Output Stationary
                    for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                        data_buffer_h[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][(i*2)*8+:8];
                        data_buffer_v[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][(i*2+1)*8+:8];
                    end
                end
                default: begin // Input Stationary
                    for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                        data_buffer_h[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][i*8+:8];
                        data_buffer_v[i][0] <= 8'd0;
                    end
                end
            endcase
            data_orch_valid <= 1'b1;
        end else begin
            data_orch_valid <= 1'b0;
        end
        
        // 数据缓冲器移位
        if (data_orch_valid) begin
            for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                pe_data_in_h_reg[i] <= data_buffer_h[i][0];
                pe_data_in_v_reg[i] <= data_buffer_v[i][0];
                for (int j = 1; j < PIPELINE_STAGES; j++) begin
                    data_buffer_h[i][j-1] <= data_buffer_h[i][j];
                    data_buffer_v[i][j-1] <= data_buffer_v[i][j];
                end
            end
        end
    end
    
    // 簇控制状态机 - 流水线化
    reg [3:0] cluster_state, next_state;
    localparam IDLE = 4'b0000;
    localparam DECODE = 4'b0001;
    localparam FETCH_PREP = 4'b0010;
    localparam FETCH = 4'b0011;
    localparam COMPUTE_PREP = 4'b0100;
    localparam COMPUTE = 4'b0101;
    localparam WRITEBACK_PREP = 4'b0110;
    localparam WRITEBACK = 4'b0111;
    localparam DONE = 4'b1000;
    
    // 计数器和控制信号
    reg [15:0] fetch_counter;
    reg [15:0] compute_counter;
    reg [15:0] writeback_counter;
    reg fetch_complete, compute_complete, writeback_complete;
    
    // 状态机逻辑
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            cluster_state <= IDLE;
        end else begin
            cluster_state <= next_state;
        end
    end
    
    // 下一状态逻辑
    always @(*) begin
        next_state = cluster_state;
        
        case (cluster_state)
            IDLE: begin
                if (enable && inst_valid) begin
                    next_state = DECODE;
                end
            end
            
            DECODE: begin
                if (decode_valid) begin
                    next_state = FETCH_PREP;
                end
            end
            
            FETCH_PREP: begin
                next_state = FETCH;
            end
            
            FETCH: begin
                if (fetch_complete) begin
                    next_state = COMPUTE_PREP;
                end
            end
            
            COMPUTE_PREP: begin
                next_state = COMPUTE;
            end
            
            COMPUTE: begin
                if (compute_complete) begin
                    next_state = WRITEBACK_PREP;
                end
            end
            
            WRITEBACK_PREP: begin
                next_state = WRITEBACK;
            end
            
            WRITEBACK: begin
                if (writeback_complete) begin
                    next_state = DONE;
                end
            end
            
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end
    
    // 输出逻辑和控制信号
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            busy <= 1'b0;
            done <= 1'b0;
            result_valid <= 1'b0;
            pe_array_enable <= 1'b0;
            fetch_counter <= 16'd0;
            compute_counter <= 16'd0;
            writeback_counter <= 16'd0;
            fetch_complete <= 1'b0;
            compute_complete <= 1'b0;
            writeback_complete <= 1'b0;
        end else begin
            done <= (cluster_state == DONE);
            busy <= (cluster_state != IDLE);
            
            case (cluster_state)
                FETCH_PREP: begin
                    fetch_counter <= 16'd0;
                    fetch_complete <= 1'b0;
                    gl_buffer_read_addr <= {CLUSTER_ID[3:0], base_addr_a};
                    gl_buffer_read_req <= 1'b1;
                end
                
                FETCH: begin
                    if (gl_buffer_read_valid) begin
                        local_sram_addr <= fetch_counter;
                        local_sram_write_data <= gl_buffer_read_data;
                        local_sram_write_en <= 1'b1;
                        local_sram_bank_sel <= fetch_counter[2:0];
                        fetch_counter <= fetch_counter + 1;
                        
                        if (fetch_counter >= (tile_m * tile_n + tile_n * tile_k)) begin
                            fetch_complete <= 1'b1;
                            gl_buffer_read_req <= 1'b0;
                        end
                    end else begin
                        local_sram_write_en <= 1'b0;
                    end
                end
                
                COMPUTE_PREP: begin
                    compute_counter <= 16'd0;
                    compute_complete <= 1'b0;
                    pe_array_enable <= 1'b1;
                end
                
                COMPUTE: begin
                    compute_counter <= compute_counter + 1;
                    if (pe_array_done || compute_counter >= (tile_k * PIPELINE_STAGES)) begin
                        compute_complete <= 1'b1;
                        pe_array_enable <= 1'b0;
                    end
                end
                
                WRITEBACK_PREP: begin
                    writeback_counter <= 16'd0;
                    writeback_complete <= 1'b0;
                    result_out <= 32'd0;
                end
                
                WRITEBACK: begin
                    if (writeback_counter < PE_ARRAY_DIM * PE_ARRAY_DIM) begin
                        gl_buffer_write_addr <= {CLUSTER_ID[3:0], base_addr_c} + writeback_counter;
                        gl_buffer_write_data <= {224'd0, pe_results[writeback_counter/PE_ARRAY_DIM][writeback_counter%PE_ARRAY_DIM]};
                        gl_buffer_write_en <= 1'b1;
                        
                        if (gl_buffer_write_ack) begin
                            writeback_counter <= writeback_counter + 1;
                            result_out <= result_out + pe_results[writeback_counter/PE_ARRAY_DIM][writeback_counter%PE_ARRAY_DIM];
                        end
                    end else begin
                        gl_buffer_write_en <= 1'b0;
                        writeback_complete <= 1'b1;
                        result_valid <= 1'b1;
                    end
                end
                
                default: begin
                    gl_buffer_read_req <= 1'b0;
                    gl_buffer_write_en <= 1'b0;
                    local_sram_write_en <= 1'b0;
                    result_valid <= 1'b0;
                end
            endcase
        end
    end
    
endmodule

            </div>
            
            <div class="code-block">
// Chisel版本对比：
import chisel3._
import chisel3.util._

class ComputeCluster(clusterId: Int = 0,
                     numMacs: Int = 512,
                     localSramKB: Int = 1024,
                     peArrayDim: Int = 16) extends Module {
  val io = IO(new Bundle {
    // 控制接口
    val enable = Input(Bool())
    val instruction = Input(UInt(128.W))
    val instValid = Input(Bool())
    val busy = Output(Bool())
    val done = Output(Bool())
    val resultOut = Output(UInt(32.W))
    val resultValid = Output(Bool())
    
    // 全局缓冲器接口
    val glBuffer = new Bundle {
      val readAddr = Output(UInt(20.W))
      val readReq = Output(Bool())
      val readData = Input(UInt(256.W))
      val readValid = Input(Bool())
      val writeAddr = Output(UInt(20.W))
      val writeData = Output(UInt(256.W))
      val writeEn = Output(Bool())
      val writeAck = Input(Bool())
    }
  })
  
  // 状态机定义
  val idle :: decode :: fetchPrep :: fetch :: computePrep :: compute :: writebackPrep :: writeback :: done :: Nil = Enum(9)
  val state = RegInit(idle)
  
  // 指令解码寄存器
  val instructionReg = RegEnable(io.instruction, io.instValid && io.enable)
  val opcode = RegNext(instructionReg(127, 120))
  val dataflowMode = RegNext(instructionReg(119, 116))
  val tileM = RegNext(instructionReg(115, 108))
  val tileN = RegNext(instructionReg(107, 100))
  val tileK = RegNext(instructionReg(99, 92))
  val baseAddrA = RegNext(instructionReg(91, 76))
  val baseAddrB = RegNext(instructionReg(75, 60))
  val baseAddrC = RegNext(instructionReg(59, 44))
  
  // PE阵列实例化
  val peArray = Module(new ProcessingElementArrayPipelined(
    peArrayDim, 8, 32))
  
  // 计数器
  val fetchCounter = RegInit(0.U(16.W))
  val computeCounter = RegInit(0.U(16.W))
  val writebackCounter = RegInit(0.U(16.W))
  
  // 完成标志
  val fetchComplete = RegInit(false.B)
  val computeComplete = RegInit(false.B)
  val writebackComplete = RegInit(false.B)
  
  // 状态机转换
  switch(state) {
    is(idle) {
      when(io.enable && io.instValid) {
        state := decode
      }
    }
    is(decode) {
      state := fetchPrep
    }
    is(fetchPrep) {
      fetchCounter := 0.U
      fetchComplete := false.B
      state := fetch
    }
    is(fetch) {
      when(fetchComplete) {
        state := computePrep
      }
    }
    is(computePrep) {
      computeCounter := 0.U
      computeComplete := false.B
      state := compute
    }
    is(compute) {
      when(computeComplete) {
        state := writebackPrep
      }
    }
    is(writebackPrep) {
      writebackCounter := 0.U
      writebackComplete := false.B
      state := writeback
    }
    is(writeback) {
      when(writebackComplete) {
        state := done
      }
    }
    is(done) {
      state := idle
    }
  }
  
  // Fetch逻辑
  when(state === fetch) {
    io.glBuffer.readReq := true.B
    io.glBuffer.readAddr := Cat(clusterId.U(4.W), baseAddrA) + fetchCounter
    
    when(io.glBuffer.readValid) {
      fetchCounter := fetchCounter + 1.U
      when(fetchCounter >= (tileM * tileN + tileN * tileK)) {
        fetchComplete := true.B
      }
    }
  }.otherwise {
    io.glBuffer.readReq := false.B
  }
  
  // Compute逻辑
  peArray.io.enable := state === compute
  peArray.io.dataflowMode := dataflowMode
  
  when(state === compute) {
    computeCounter := computeCounter + 1.U
    when(peArray.io.done || computeCounter >= (tileK * 4.U)) {
      computeComplete := true.B
    }
  }
  
  // Writeback逻辑
  when(state === writeback) {
    io.glBuffer.writeEn := true.B
    io.glBuffer.writeAddr := Cat(clusterId.U(4.W), baseAddrC) + writebackCounter
    io.glBuffer.writeData := peArray.io.results(writebackCounter)
    
    when(io.glBuffer.writeAck) {
      writebackCounter := writebackCounter + 1.U
      when(writebackCounter >= (peArrayDim * peArrayDim).U) {
        writebackComplete := true.B
      }
    }
  }.otherwise {
    io.glBuffer.writeEn := false.B
  }
  
  // 输出
  io.busy := state =/= idle
  io.done := state === done
  io.resultValid := state === done
  io.resultOut := RegEnable(
    peArray.io.results.reduce(_ + _),
    state === writebackPrep
  )
}
            </div>
            
            <div class="code-block">
// 可重构PE阵列
module ProcessingElementArray #(
    parameter ARRAY_DIM = 16,
    parameter DATA_WIDTH = 8,
    parameter ACCUM_WIDTH = 32
)(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire [3:0] dataflow_mode,
    
    // 数据输入
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] data_in_h,
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] data_in_v,
    
    // 结果输出
    output wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][ACCUM_WIDTH-1:0] results_out
);
    
    // 数据流模式
    localparam WS_MODE = 4'b0000;  // Weight Stationary
    localparam OS_MODE = 4'b0001;  // Output Stationary
    localparam IS_MODE = 4'b0010;  // Input Stationary
    localparam RS_MODE = 4'b0011;  // Row Stationary
    
    // PE间连接
    wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][DATA_WIDTH-1:0] h_links;
    wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][DATA_WIDTH-1:0] v_links;
    wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][ACCUM_WIDTH-1:0] partial_sums;
    
    // 生成PE阵列
    genvar row, col;
    generate
        for (row = 0; row < ARRAY_DIM; row = row + 1) begin : pe_row
            for (col = 0; col < ARRAY_DIM; col = col + 1) begin : pe_col
                ProcessingElement #(
                    .DATA_WIDTH(DATA_WIDTH),
                    .ACCUM_WIDTH(ACCUM_WIDTH)
                ) pe (
                    .clk(clk),
                    .rst_n(rst_n),
                    .enable(enable),
                    .mode(dataflow_mode),
                    
                    // 数据输入
                    .data_in_h(col == 0 ? data_in_h[row] : h_links[row][col-1]),
                    .data_in_v(row == 0 ? data_in_v[col] : v_links[row-1][col]),
                    
                    // 数据输出
                    .data_out_h(h_links[row][col]),
                    .data_out_v(v_links[row][col]),
                    
                    // 部分和
                    .partial_sum_in(partial_sums[row][col]),
                    .result_out(results_out[row][col])
                );
            end
        end
    endgenerate
endmodule
            </div>

            <h4>12.2.3 存储层次设计</h4>
            <div class="code-block">
// 分层存储系统
module HierarchicalMemorySystem #(
    parameter L0_SIZE_KB = 2,      // PE本地寄存器
    parameter L1_SIZE_KB = 64,     // 簇内共享L1
    parameter L2_SIZE_KB = 1024,   // 簇私有L2
    parameter L3_SIZE_MB = 4       // 全局共享L3
)(
    input wire clk,
    input wire rst_n,
    
    // PE访问接口
    input wire [511:0] pe_read_req,      // 512个PE的读请求
    input wire [511:0][15:0] pe_read_addr,
    output wire [511:0][7:0] pe_read_data,
    output wire [511:0] pe_read_valid,
    
    // DMA接口
    input wire dma_req,
    input wire [31:0] dma_src_addr,
    input wire [31:0] dma_dst_addr,
    input wire [15:0] dma_length,
    output wire dma_done,
    
    // DDR接口
    output wire [31:0] ddr_addr,
    output wire ddr_read_en,
    input wire [255:0] ddr_read_data,
    input wire ddr_read_valid
);
    
    // L0寄存器文件（每个PE）
    genvar pe_id;
    generate
        for (pe_id = 0; pe_id < 512; pe_id = pe_id + 1) begin : l0_gen
            RegFile #(
                .SIZE_BYTES(L0_SIZE_KB * 1024),
                .DATA_WIDTH(8)
            ) l0_rf (
                .clk(clk),
                .read_addr(pe_read_addr[pe_id][7:0]),
                .read_data(l0_data[pe_id]),
                .write_addr(l0_write_addr[pe_id]),
                .write_data(l0_write_data[pe_id]),
                .write_en(l0_write_en[pe_id])
            );
        end
    endgenerate
    
    // L1缓存（簇内共享）
    wire [15:0] l1_req_addr [15:0];  // 16个L1 bank
    wire [15:0] l1_req_valid;
    wire [15:0][63:0] l1_resp_data;
    wire [15:0] l1_resp_valid;
    
    genvar bank;
    generate
        for (bank = 0; bank < 16; bank = bank + 1) begin : l1_gen
            L1Cache #(
                .SIZE_KB(L1_SIZE_KB / 16),
                .LINE_SIZE(64),
                .ASSOCIATIVITY(4)
            ) l1_bank (
                .clk(clk),
                .rst_n(rst_n),
                .req_addr(l1_req_addr[bank]),
                .req_valid(l1_req_valid[bank]),
                .resp_data(l1_resp_data[bank]),
                .resp_valid(l1_resp_valid[bank]),
                .miss_addr(l1_miss_addr[bank]),
                .miss_valid(l1_miss_valid[bank])
            );
        end
    endgenerate
    
    // L1仲裁器和路由
    L1Arbiter #(
        .NUM_PE(512),
        .NUM_BANKS(16)
    ) l1_arbiter (
        .clk(clk),
        .rst_n(rst_n),
        .pe_requests(pe_read_req),
        .pe_addresses(pe_read_addr),
        .bank_grant(l1_req_valid),
        .bank_addresses(l1_req_addr)
    );
    
    // L2缓存（簇私有）
    L2Cache #(
        .SIZE_KB(L2_SIZE_KB),
        .LINE_SIZE(256),
        .ASSOCIATIVITY(8),
        .NUM_BANKS(8)
    ) l2_cache (
        .clk(clk),
        .rst_n(rst_n),
        // L1 miss处理
        .l1_miss_addr(l1_miss_addr_merged),
        .l1_miss_valid(|l1_miss_valid),
        .l1_fill_data(l2_to_l1_data),
        .l1_fill_valid(l2_to_l1_valid),
        // L3接口
        .l3_req_addr(l2_to_l3_addr),
        .l3_req_valid(l2_to_l3_valid),
        .l3_resp_data(l3_to_l2_data),
        .l3_resp_valid(l3_to_l2_valid)
    );
    
    // L3全局缓存
    L3GlobalBuffer #(
        .SIZE_MB(L3_SIZE_MB),
        .LINE_SIZE(512),
        .NUM_PORTS(4),  // 4个簇
        .NUM_BANKS(16)
    ) l3_buffer (
        .clk(clk),
        .rst_n(rst_n),
        // 簇接口
        .cluster_req_addr(l2_to_l3_addr_all),
        .cluster_req_valid(l2_to_l3_valid_all),
        .cluster_resp_data(l3_to_l2_data_all),
        .cluster_resp_valid(l3_to_l2_valid_all),
        // DDR接口
        .ddr_req_addr(ddr_addr),
        .ddr_req_valid(ddr_read_en),
        .ddr_resp_data(ddr_read_data),
        .ddr_resp_valid(ddr_read_valid),
        // DMA接口
        .dma_req(dma_req),
        .dma_src_addr(dma_src_addr),
        .dma_dst_addr(dma_dst_addr),
        .dma_length(dma_length),
        .dma_done(dma_done)
    );
    
    // 预取引擎
    PrefetchEngine #(
        .PREFETCH_DEGREE(4),
        .PATTERN_TABLE_SIZE(256)
    ) prefetcher (
        .clk(clk),
        .rst_n(rst_n),
        .access_addr(pe_read_addr),
        .access_valid(pe_read_req),
        .prefetch_addr(prefetch_addr),
        .prefetch_valid(prefetch_valid)
    );
endmodule

// 智能缓存替换策略
module AdaptiveCacheReplacement #(
    parameter CACHE_WAYS = 8,
    parameter HISTORY_BITS = 4
)(
    input wire clk,
    input wire rst_n,
    
    // 访问信息
    input wire access_valid,
    input wire [2:0] access_way,
    input wire [1:0] access_type,  // 0:权重 1:激活 2:部分和
    
    // 替换决策
    input wire replace_req,
    output reg [2:0] victim_way,
    output reg victim_valid
);
    
    // 每路的元数据
    reg [CACHE_WAYS-1:0][HISTORY_BITS-1:0] access_history;
    reg [CACHE_WAYS-1:0][1:0] data_type;
    reg [CACHE_WAYS-1:0][15:0] reuse_counter;
    reg [CACHE_WAYS-1:0] dead_prediction;
    
    // 更新访问历史
    always @(posedge clk) begin
        if (!rst_n) begin
            access_history <= 0;
            reuse_counter <= 0;
        end else if (access_valid) begin
            // 更新LRU位
            access_history[access_way] <= {HISTORY_BITS{1'b1}};
            for (int i = 0; i < CACHE_WAYS; i++) begin
                if (i != access_way && access_history[i] > 0) begin
                    access_history[i] <= access_history[i] - 1;
                end
            end
            
            // 更新重用计数
            reuse_counter[access_way] <= reuse_counter[access_way] + 1;
            data_type[access_way] <= access_type;
        end
    end
    
    // 死亡预测逻辑
    always @(posedge clk) begin
        for (int i = 0; i < CACHE_WAYS; i++) begin
            // 权重数据通常重用度高
            if (data_type[i] == 2'b00) begin
                dead_prediction[i] <= 0;
            end
            // 激活值重用度取决于层类型
            else if (data_type[i] == 2'b01) begin
                dead_prediction[i] <= (reuse_counter[i] < 2);
            end
            // 部分和通常只使用一次
            else if (data_type[i] == 2'b10) begin
                dead_prediction[i] <= 1;
            end
        end
    end
    
    // 选择替换牺牲者
    always @(*) begin
        victim_valid = 0;
        victim_way = 0;
        
        if (replace_req) begin
            // 优先替换预测为死亡的行
            for (int i = 0; i < CACHE_WAYS; i++) begin
                if (dead_prediction[i]) begin
                    victim_way = i;
                    victim_valid = 1;
                    break;
                end
            end
            
            // 如果没有死亡预测，使用LRU
            if (!victim_valid) begin
                reg [HISTORY_BITS-1:0] min_history = {HISTORY_BITS{1'b1}};
                for (int i = 0; i < CACHE_WAYS; i++) begin
                    if (access_history[i] < min_history) begin
                        min_history = access_history[i];
                        victim_way = i;
                    end
                end
                victim_valid = 1;
            end
        end
    end
endmodule
            </div>

            <div class="exercise">
                <h4>练习 3：架构优化设计</h4>
                <p>基于上述NPU架构，进行以下优化设计：</p>
                <ol>
                    <li>设计一个支持稀疏计算的PE阵列，能够跳过零值计算</li>
                    <li>实现一个自适应的NoC路由算法，根据网络拥塞动态调整路径</li>
                    <li>设计一个混合精度计算单元，支持INT4/INT8/FP16动态切换</li>
                </ol>
                
                <details class="hint">
                    <summary>💡 提示</summary>
                    <p>思考方向：1) 稀疏计算需要零检测和索引管理，考虑压缩格式（CSR/CSC）。2) 自适应路由需要监控各链路负载，使用备选路径。3) 混合精度需要可配置的数据通路和位宽转换逻辑。</p>
                </details>
                <button class="toggle-answer">显示答案</button>
                <div class="answer">
                    <div class="code-block">
// 稀疏感知PE阵列
module SparsePEArray #(
    parameter ARRAY_DIM = 16,
    parameter DATA_WIDTH = 8,
    parameter SPARSE_THRESHOLD = 10  // 稀疏度阈值
)(
    input wire clk,
    input wire rst_n,
    
    // 稀疏数据输入
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] weight_values,
    input wire [ARRAY_DIM-1:0] weight_valid,  // 非零标志
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] activation_values,
    input wire [ARRAY_DIM-1:0] activation_valid,
    
    // 压缩索引
    input wire [ARRAY_DIM-1:0][3:0] weight_indices,
    input wire [ARRAY_DIM-1:0][3:0] activation_indices,
    
    // 输出
    output reg [ARRAY_DIM-1:0][31:0] sparse_results,
    output reg [ARRAY_DIM-1:0] result_valid
);
    
    // 稀疏度检测
    reg [7:0] weight_sparsity, activation_sparsity;
    always @(*) begin
        weight_sparsity = 0;
        activation_sparsity = 0;
        for (int i = 0; i < ARRAY_DIM; i++) begin
            if (!weight_valid[i]) weight_sparsity = weight_sparsity + 1;
            if (!activation_valid[i]) activation_sparsity = activation_sparsity + 1;
        end
    end
    
    // 动态选择计算模式
    wire sparse_mode = (weight_sparsity > SPARSE_THRESHOLD) || 
                       (activation_sparsity > SPARSE_THRESHOLD);
    
    // 稀疏计算引擎
    genvar pe_idx;
    generate
        for (pe_idx = 0; pe_idx < ARRAY_DIM; pe_idx = pe_idx + 1) begin : sparse_pe
            SparsePE #(
                .DATA_WIDTH(DATA_WIDTH)
            ) spe (
                .clk(clk),
                .rst_n(rst_n),
                .sparse_mode(sparse_mode),
                // 稠密输入
                .dense_weight(weight_values[pe_idx]),
                .dense_activation(activation_values[pe_idx]),
                // 稀疏输入
                .sparse_weight_val(weight_values[pe_idx]),
                .sparse_weight_idx(weight_indices[pe_idx]),
                .sparse_weight_valid(weight_valid[pe_idx]),
                .sparse_act_val(activation_values[pe_idx]),
                .sparse_act_idx(activation_indices[pe_idx]),
                .sparse_act_valid(activation_valid[pe_idx]),
                // 输出
                .result(sparse_results[pe_idx]),
                .result_valid(result_valid[pe_idx])
            );
        end
    endgenerate
    
    // 零值跳过控制器
    ZeroSkipController #(
        .ARRAY_DIM(ARRAY_DIM)
    ) skip_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .data_valid(weight_valid & activation_valid),
        .skip_enable(sparse_mode),
        .compute_enable(pe_compute_en)
    );
endmodule

// 自适应NoC路由
module AdaptiveRouter #(
    parameter NODE_ID = 0,
    parameter NETWORK_WIDTH = 4,
    parameter NETWORK_HEIGHT = 4,
    parameter FLIT_WIDTH = 128,
    parameter VC_NUM = 4
)(
    input wire clk,
    input wire rst_n,
    
    // 输入端口（5个方向：N,S,E,W,Local）
    input wire [4:0][FLIT_WIDTH-1:0] in_flits,
    input wire [4:0] in_valid,
    output wire [4:0] in_ready,
    
    // 输出端口
    output reg [4:0][FLIT_WIDTH-1:0] out_flits,
    output reg [4:0] out_valid,
    input wire [4:0] out_ready,
    
    // 拥塞信息
    input wire [4:0][7:0] congestion_level,
    output wire [7:0] local_congestion
);
    
    // 提取目标地址
    wire [7:0] dest_x[4:0], dest_y[4:0];
    genvar port;
    generate
        for (port = 0; port < 5; port = port + 1) begin : dest_extract
            assign dest_x[port] = in_flits[port][7:0];
            assign dest_y[port] = in_flits[port][15:8];
        end
    endgenerate
    
    // 计算最短路径
    reg [2:0] preferred_port[4:0];
    reg [2:0] alternate_port[4:0];
    
    always @(*) begin
        for (int i = 0; i < 5; i++) begin
            // XY路由作为基础
            if (dest_x[i] > NODE_ID % NETWORK_WIDTH) begin
                preferred_port[i] = 3'd2; // East
            end else if (dest_x[i] < NODE_ID % NETWORK_WIDTH) begin
                preferred_port[i] = 3'd3; // West
            end else if (dest_y[i] > NODE_ID / NETWORK_WIDTH) begin
                preferred_port[i] = 3'd0; // North
            end else if (dest_y[i] < NODE_ID / NETWORK_WIDTH) begin
                preferred_port[i] = 3'd1; // South
            end else begin
                preferred_port[i] = 3'd4; // Local
            end
            
            // 计算备选路径（YX路由）
            if (dest_y[i] > NODE_ID / NETWORK_WIDTH) begin
                alternate_port[i] = 3'd0; // North
            end else if (dest_y[i] < NODE_ID / NETWORK_WIDTH) begin
                alternate_port[i] = 3'd1; // South
            end else if (dest_x[i] > NODE_ID % NETWORK_WIDTH) begin
                alternate_port[i] = 3'd2; // East
            end else if (dest_x[i] < NODE_ID % NETWORK_WIDTH) begin
                alternate_port[i] = 3'd3; // West
            end else begin
                alternate_port[i] = 3'd4; // Local
            end
        end
    end
    
    // 自适应路由决策
    reg [2:0] selected_port[4:0];
    always @(*) begin
        for (int i = 0; i < 5; i++) begin
            // 比较拥塞程度
            if (congestion_level[preferred_port[i]] < 
                congestion_level[alternate_port[i]] + 8'd32) begin
                // 优选路径拥塞不严重，使用优选
                selected_port[i] = preferred_port[i];
            end else begin
                // 优选路径拥塞，使用备选
                selected_port[i] = alternate_port[i];
            end
        end
    end
    
    // 仲裁和交叉开关
    wire [4:0][4:0] request_matrix;  // request_matrix[i][j]: 输入i请求输出j
    wire [4:0][4:0] grant_matrix;
    
    genvar in_p, out_p;
    generate
        for (in_p = 0; in_p < 5; in_p = in_p + 1) begin : req_gen
            for (out_p = 0; out_p < 5; out_p = out_p + 1) begin : req_out
                assign request_matrix[in_p][out_p] = 
                    in_valid[in_p] && (selected_port[in_p] == out_p);
            end
        end
    endgenerate
    
    // Round-Robin仲裁器
    RoundRobinArbiter #(
        .NUM_PORTS(5)
    ) arbiter[4:0] (
        .clk(clk),
        .rst_n(rst_n),
        .requests(request_matrix),
        .grants(grant_matrix)
    );
    
    // 输出多路复用
    always @(posedge clk) begin
        if (!rst_n) begin
            out_valid <= 0;
        end else begin
            for (int out_p = 0; out_p < 5; out_p++) begin
                out_valid[out_p] <= 0;
                for (int in_p = 0; in_p < 5; in_p++) begin
                    if (grant_matrix[in_p][out_p]) begin
                        out_flits[out_p] <= in_flits[in_p];
                        out_valid[out_p] <= 1;
                    end
                end
            end
        end
    end
    
    // 本地拥塞度计算
    reg [7:0] buffer_occupancy[4:0];
    assign local_congestion = (buffer_occupancy[0] + buffer_occupancy[1] + 
                              buffer_occupancy[2] + buffer_occupancy[3] + 
                              buffer_occupancy[4]) / 5;
endmodule

// 混合精度计算单元
module MixedPrecisionUnit #(
    parameter MAX_WIDTH = 16  // 最大支持FP16
)(
    input wire clk,
    input wire rst_n,
    
    // 操作数输入
    input wire [MAX_WIDTH-1:0] operand_a,
    input wire [MAX_WIDTH-1:0] operand_b,
    input wire [31:0] accumulator,
    
    // 精度控制
    input wire [1:0] precision_mode,  // 00:INT4 01:INT8 10:FP16
    input wire [2:0] operation,       // 000:MAC 001:ADD 010:MUL
    
    // 输出
    output reg [31:0] result,
    output reg overflow,
    output reg underflow
);
    
    // 精度模式定义
    localparam INT4_MODE = 2'b00;
    localparam INT8_MODE = 2'b01;
    localparam FP16_MODE = 2'b10;
    
    // INT4计算单元（可以并行计算4个）
    wire [3:0] int4_a[3:0], int4_b[3:0];
    wire [7:0] int4_results[3:0];
    
    genvar i;
    generate
        for (i = 0; i < 4; i = i + 1) begin : int4_extract
            assign int4_a[i] = operand_a[i*4 +: 4];
            assign int4_b[i] = operand_b[i*4 +: 4];
            
            // INT4 MAC
            wire [7:0] int4_prod = $signed(int4_a[i]) * $signed(int4_b[i]);
            assign int4_results[i] = int4_prod;
        end
    endgenerate
    
    // INT8计算单元（可以并行计算2个）
    wire [7:0] int8_a[1:0], int8_b[1:0];
    wire [15:0] int8_results[1:0];
    
    generate
        for (i = 0; i < 2; i = i + 1) begin : int8_calc
            assign int8_a[i] = operand_a[i*8 +: 8];
            assign int8_b[i] = operand_b[i*8 +: 8];
            
            // INT8 MAC
            wire [15:0] int8_prod = $signed(int8_a[i]) * $signed(int8_b[i]);
            assign int8_results[i] = int8_prod;
        end
    endgenerate
    
    // FP16计算单元
    wire [15:0] fp16_a = operand_a[15:0];
    wire [15:0] fp16_b = operand_b[15:0];
    wire [31:0] fp16_result;
    
    FP16MAC fp16_mac (
        .a(fp16_a),
        .b(fp16_b),
        .c(accumulator),
        .result(fp16_result),
        .overflow(fp16_overflow),
        .underflow(fp16_underflow)
    );
    
    // 结果选择和累加
    always @(posedge clk) begin
        if (!rst_n) begin
            result <= 0;
            overflow <= 0;
            underflow <= 0;
        end else begin
            case (precision_mode)
                INT4_MODE: begin
                    // INT4模式：4路并行
                    result <= accumulator + 
                             $signed(int4_results[0]) + 
                             $signed(int4_results[1]) + 
                             $signed(int4_results[2]) + 
                             $signed(int4_results[3]);
                    overflow <= 0;
                    underflow <= 0;
                end
                
                INT8_MODE: begin
                    // INT8模式：2路并行
                    result <= accumulator + 
                             $signed(int8_results[0]) + 
                             $signed(int8_results[1]);
                    overflow <= 0;
                    underflow <= 0;
                end
                
                FP16_MODE: begin
                    // FP16模式：单路
                    result <= fp16_result;
                    overflow <= fp16_overflow;
                    underflow <= fp16_underflow;
                end
                
                default: begin
                    result <= accumulator;
                end
            endcase
        end
    end
    
    // 动态精度选择逻辑
    reg [1:0] auto_precision;
    reg [31:0] value_range;
    
    always @(*) begin
        // 根据数值范围自动选择精度
        value_range = (operand_a > operand_b) ? operand_a : operand_b;
        
        if (value_range < 16) begin
            auto_precision = INT4_MODE;  // 小数值用INT4
        end else if (value_range < 256) begin
            auto_precision = INT8_MODE;  // 中等数值用INT8
        end else begin
            auto_precision = FP16_MODE;  // 大数值用FP16
        end
    end
endmodule
                    </div>
                    <p><strong>解析：</strong></p>
                    <ul>
                        <li>稀疏PE阵列通过检测零值分布，动态切换计算模式，跳过零值MAC操作</li>
                        <li>自适应路由器基于实时拥塞信息选择XY或YX路由，避免热点</li>
                        <li>混合精度单元支持INT4/INT8/FP16，INT4模式下可4路并行提高吞吐量</li>
                        <li>包含自动精度选择逻辑，根据数值范围动态调整精度</li>
                        <li>这些优化可以显著提升NPU的能效和灵活性</li>
                    </ul>
                </div>
            </div>

            <h3>12.3 RTL实现与验证</h3>
            
            <p>本节将展示关键模块的RTL实现细节，并建立完整的验证环境。</p>

            <h4>12.3.1 MAC单元RTL实现</h4>
            <div class="code-block">
// 高性能MAC单元实现 - 改进版（严格遵循可综合规范）
module HighPerformanceMAC #(
    parameter DATA_WIDTH = 8,
    parameter ACCUM_WIDTH = 32,
    parameter PIPELINE_STAGES = 3
)(
    input wire clk,
    input wire rst_n,
    
    // 输入接口
    input wire signed [DATA_WIDTH-1:0] a,
    input wire signed [DATA_WIDTH-1:0] b,
    input wire signed [ACCUM_WIDTH-1:0] c,
    input wire valid_in,
    input wire [1:0] mode,  // 00:MAC 01:MUL 10:ADD 11:BYPASS
    
    // 输出接口
    output reg signed [ACCUM_WIDTH-1:0] result,
    output reg valid_out,
    output reg overflow
);
    
    // 确保所有内部信号声明
    wire signed [2*DATA_WIDTH-1:0] mult_result_comb;
    reg signed [ACCUM_WIDTH-1:0] add_result_next;
    reg overflow_next;
    
    // 流水线寄存器
    reg signed [DATA_WIDTH-1:0] a_r1, b_r1;
    reg signed [ACCUM_WIDTH-1:0] c_r1, c_r2;
    reg [1:0] mode_r1, mode_r2;
    reg valid_r1, valid_r2;
    
    // 乘法结果
    reg signed [2*DATA_WIDTH-1:0] mult_result;
    reg signed [ACCUM_WIDTH-1:0] mult_extended;
    
    // 第一级：输入寄存
    always @(posedge clk) begin
        if (!rst_n) begin
            a_r1 <= 0;
            b_r1 <= 0;
            c_r1 <= 0;
            mode_r1 <= 0;
            valid_r1 <= 0;
        end else begin
            a_r1 <= a;
            b_r1 <= b;
            c_r1 <= c;
            mode_r1 <= mode;
            valid_r1 <= valid_in;
        end
    end
    
    // 组合逻辑计算乘法结果
    assign mult_result_comb = a_r1 * b_r1;
    
    // 第二级：乘法结果寄存（使用非阻塞赋值）
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mult_result <= '0;
            c_r2 <= '0;
            mode_r2 <= 2'b00;
            valid_r2 <= 1'b0;
        end else begin
            mult_result <= mult_result_comb;
            c_r2 <= c_r1;
            mode_r2 <= mode_r1;
            valid_r2 <= valid_r1;
        end
    end
    
    // 符号扩展
    always @(*) begin
        mult_extended = {{(ACCUM_WIDTH-2*DATA_WIDTH){mult_result[2*DATA_WIDTH-1]}}, 
                        mult_result};
    end
    
    // 组合逻辑计算下一个结果
    always @(*) begin
        // 先给所有输出赋默认值，避免锁存器
        add_result_next = result;
        overflow_next = 1'b0;
        
        case (mode_r2)
            2'b00: begin  // MAC
                {overflow_next, add_result_next} = {mult_extended[ACCUM_WIDTH-1], mult_extended} + 
                                                   {c_r2[ACCUM_WIDTH-1], c_r2};
            end
            2'b01: begin  // MUL only
                add_result_next = mult_extended;
                overflow_next = 1'b0;
            end
            2'b10: begin  // ADD only
                add_result_next = c_r2 + {{(ACCUM_WIDTH-DATA_WIDTH){a_r1[DATA_WIDTH-1]}}, a_r1};
                overflow_next = 1'b0;
            end
            2'b11: begin  // BYPASS
                add_result_next = c_r2;
                overflow_next = 1'b0;
            end
            default: begin  // 确保完备性
                add_result_next = c_r2;
                overflow_next = 1'b0;
            end
        endcase
    end
    
    // 第三级：结果寄存
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            result <= '0;
            valid_out <= 1'b0;
            overflow <= 1'b0;
        end else begin
            result <= add_result_next;
            valid_out <= valid_r2;
            overflow <= overflow_next;
        end
    end
    
    // 断言检查
    // synthesis translate_off
    always @(posedge clk) begin
        if (valid_in && valid_r1 && valid_r2) begin
            assert(valid_out) else $error("Pipeline stall detected");
        end
    end
    // synthesis translate_on
endmodule

// 脉动阵列实现
module SystolicArray #(
    parameter ARRAY_SIZE = 16,
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    
    // 权重加载接口
    input wire weight_load,
    input wire [ARRAY_SIZE-1:0][ARRAY_SIZE-1:0][DATA_WIDTH-1:0] weights,
    
    // 数据流接口
    input wire [ARRAY_SIZE-1:0][DATA_WIDTH-1:0] input_data,
    input wire input_valid,
    
    // 输出接口
    output wire [ARRAY_SIZE-1:0][31:0] output_data,
    output wire [ARRAY_SIZE-1:0] output_valid
);
    
    // PE间连接
    wire [ARRAY_SIZE:0][ARRAY_SIZE:0][DATA_WIDTH-1:0] h_data;
    wire [ARRAY_SIZE:0][ARRAY_SIZE:0][31:0] v_data;
    wire [ARRAY_SIZE:0][ARRAY_SIZE:0] h_valid, v_valid;
    
    // 边界连接
    genvar i;
    generate
        for (i = 0; i < ARRAY_SIZE; i = i + 1) begin : boundary
            // 左边界输入
            assign h_data[i][0] = input_data[i];
            assign h_valid[i][0] = input_valid;
            
            // 上边界输入（部分和初始化为0）
            assign v_data[0][i] = 32'h0;
            assign v_valid[0][i] = 1'b1;
            
            // 下边界输出
            assign output_data[i] = v_data[ARRAY_SIZE][i];
            assign output_valid[i] = v_valid[ARRAY_SIZE][i];
        end
    endgenerate
    
    // PE阵列实例化
    genvar row, col;
    generate
        for (row = 0; row < ARRAY_SIZE; row = row + 1) begin : pe_row
            for (col = 0; col < ARRAY_SIZE; col = col + 1) begin : pe_col
                SystolicPE #(
                    .DATA_WIDTH(DATA_WIDTH)
                ) pe (
                    .clk(clk),
                    .rst_n(rst_n),
                    
                    // 权重接口
                    .weight_load(weight_load),
                    .weight_in(weights[row][col]),
                    
                    // 水平数据流（激活值）
                    .h_data_in(h_data[row][col]),
                    .h_valid_in(h_valid[row][col]),
                    .h_data_out(h_data[row][col+1]),
                    .h_valid_out(h_valid[row][col+1]),
                    
                    // 垂直数据流（部分和）
                    .v_data_in(v_data[row][col]),
                    .v_valid_in(v_valid[row][col]),
                    .v_data_out(v_data[row+1][col]),
                    .v_valid_out(v_valid[row+1][col])
                );
            end
        end
    endgenerate
endmodule

// 脉动PE单元
module SystolicPE #(
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    
    // 权重接口
    input wire weight_load,
    input wire [DATA_WIDTH-1:0] weight_in,
    
    // 水平数据流
    input wire [DATA_WIDTH-1:0] h_data_in,
    input wire h_valid_in,
    output reg [DATA_WIDTH-1:0] h_data_out,
    output reg h_valid_out,
    
    // 垂直数据流
    input wire [31:0] v_data_in,
    input wire v_valid_in,
    output reg [31:0] v_data_out,
    output reg v_valid_out
);
    
    // 权重寄存器
    reg [DATA_WIDTH-1:0] weight_reg;
    
    // 权重加载
    always @(posedge clk) begin
        if (!rst_n) begin
            weight_reg <= 0;
        end else if (weight_load) begin
            weight_reg <= weight_in;
        end
    end
    
    // MAC计算
    wire [31:0] mac_result;
    wire mac_valid;
    
    HighPerformanceMAC #(
        .DATA_WIDTH(DATA_WIDTH),
        .ACCUM_WIDTH(32),
        .PIPELINE_STAGES(1)
    ) mac_unit (
        .clk(clk),
        .rst_n(rst_n),
        .a(h_data_in),
        .b(weight_reg),
        .c(v_data_in),
        .valid_in(h_valid_in & v_valid_in),
        .mode(2'b00),  // MAC mode
        .result(mac_result),
        .valid_out(mac_valid),
        .overflow()
    );
    
    // 数据传递
    always @(posedge clk) begin
        if (!rst_n) begin
            h_data_out <= 0;
            h_valid_out <= 0;
            v_data_out <= 0;
            v_valid_out <= 0;
        end else begin
            // 水平传递（激活值）
            h_data_out <= h_data_in;
            h_valid_out <= h_valid_in;
            
            // 垂直传递（部分和）
            v_data_out <= mac_result;
            v_valid_out <= mac_valid;
        end
    end
endmodule
            </div>

            <h4>12.3.2 UVM验证环境</h4>
            <div class="code-block">
// 改进的UVM测试环境 - 完整的自校验和覆盖率驱动
class npu_env extends uvm_env;
    `uvm_component_utils(npu_env)
    
    // 环境组件
    npu_agent           input_agent;
    npu_agent           output_agent;
    npu_scoreboard      scoreboard;
    npu_coverage        coverage;
    npu_ref_model       ref_model;
    npu_assertion_monitor assertion_mon;  // 新增：断言监测器
    npu_performance_monitor perf_mon;     // 新增：性能监测器
    
    // 配置对象
    npu_env_config      env_cfg;
    
    function new(string name = "npu_env", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 获取配置
        if (!uvm_config_db#(npu_env_config)::get(this, "", "env_cfg", env_cfg))
            `uvm_fatal("ENV", "Failed to get env_cfg")
        
        // 创建代理
        input_agent = npu_agent::type_id::create("input_agent", this);
        output_agent = npu_agent::type_id::create("output_agent", this);
        
        // 创建记分板和覆盖率
        scoreboard = npu_scoreboard::type_id::create("scoreboard", this);
        coverage = npu_coverage::type_id::create("coverage", this);
        ref_model = npu_ref_model::type_id::create("ref_model", this);
        
        // 配置代理
        input_agent.is_active = UVM_ACTIVE;
        output_agent.is_active = UVM_PASSIVE;
    endfunction
    
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        // 连接TLM端口
        input_agent.monitor.ap.connect(ref_model.input_fifo.analysis_export);
        input_agent.monitor.ap.connect(coverage.analysis_export);
        
        ref_model.output_ap.connect(scoreboard.expected_fifo.analysis_export);
        output_agent.monitor.ap.connect(scoreboard.actual_fifo.analysis_export);
    endfunction
endclass

// NPU代理
class npu_agent extends uvm_agent;
    `uvm_component_utils(npu_agent)
    
    npu_driver      driver;
    npu_monitor     monitor;
    npu_sequencer   sequencer;
    
    function new(string name = "npu_agent", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        monitor = npu_monitor::type_id::create("monitor", this);
        
        if (is_active == UVM_ACTIVE) begin
            driver = npu_driver::type_id::create("driver", this);
            sequencer = npu_sequencer::type_id::create("sequencer", this);
        end
    endfunction
    
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        if (is_active == UVM_ACTIVE) begin
            driver.seq_item_port.connect(sequencer.seq_item_export);
        end
    endfunction
endclass

// 增强的NPU事务 - 支持更多约束和灵活性
class npu_transaction extends uvm_sequence_item;
    `uvm_object_utils(npu_transaction)
    
    // 事务类型
    typedef enum {CONV, FC, POOL, ACTIVATION, SPARSE_CONV, DEPTHWISE} op_type_e;
    rand op_type_e op_type;
    
    // 数据字段
    rand bit [7:0] input_data[];
    rand bit [7:0] weight_data[];
    rand bit [31:0] output_data[];
    
    // 配置参数
    rand int input_height, input_width, input_channels;
    rand int output_height, output_width, output_channels;
    rand int kernel_size, stride, padding;
    rand int sparsity_ratio;  // 新增：稀疏度
    rand bit use_bias;        // 新增：是否使用偏置
    rand bit [2:0] precision_mode; // 新增：INT4/INT8/FP16
    
    // 增强的约束 - 更接近实际应用
    constraint data_size_c {
        input_data.size() == input_height * input_width * input_channels;
        if (op_type == DEPTHWISE) {
            weight_data.size() == kernel_size * kernel_size * input_channels;
        } else {
            weight_data.size() == kernel_size * kernel_size * input_channels * output_channels;
        }
        output_data.size() == output_height * output_width * output_channels;
    }
    
    constraint dimension_c {
        input_height inside {[8:256]};
        input_width inside {[8:256]};
        input_channels inside {[16:512]};
        output_channels inside {[16:512]};
        kernel_size inside {1, 3, 5, 7};
        stride inside {1, 2};
        padding inside {[0:3]};
        
        // 输出尺寸计算约束
        output_height == (input_height + 2*padding - kernel_size) / stride + 1;
        output_width == (input_width + 2*padding - kernel_size) / stride + 1;
        
        // 稀疏度约束
        sparsity_ratio inside {[0:90]}; // 0-90%稀疏度
        
        // 精度模式约束
        precision_mode inside {[0:2]}; // 0:INT4, 1:INT8, 2:FP16
    }
    
    // 稀疏数据生成约束
    constraint sparsity_c {
        if (op_type == SPARSE_CONV) {
            // 根据稀疏度比例设置零值
            foreach (weight_data[i]) {
                (sparsity_ratio > 50) -> (weight_data[i] dist {0 := sparsity_ratio, [1:255] := 100-sparsity_ratio});
            }
        }
    }
    
    function new(string name = "npu_transaction");
        super.new(name);
    endfunction
    
    function void do_copy(uvm_object rhs);
        npu_transaction tr;
        super.do_copy(rhs);
        $cast(tr, rhs);
        op_type = tr.op_type;
        input_data = tr.input_data;
        weight_data = tr.weight_data;
        output_data = tr.output_data;
    endfunction
endclass

// 增强的约束随机测试序列
class constrained_random_sequence extends uvm_sequence#(npu_transaction);
    `uvm_object_utils(constrained_random_sequence)
    
    // 可配置参数
    rand int num_transactions = 1000;
    rand bit enable_sparse = 1;
    rand bit enable_mixed_precision = 1;
    
    function new(string name = "constrained_random_sequence");
        super.new(name);
    endfunction
    
    task body();
        npu_transaction tr;
        
        // 随机生成多种类型的事务
        repeat(num_transactions) begin
            tr = npu_transaction::type_id::create("tr");
            start_item(tr);
            
            // 复杂的约束随机化
            assert(tr.randomize() with {
                // 操作类型分布
                op_type dist {CONV := 40, FC := 20, POOL := 10, 
                             ACTIVATION := 10, SPARSE_CONV := 15, DEPTHWISE := 5};
                
                // 根据操作类型调整参数
                if (op_type == CONV || op_type == SPARSE_CONV) {
                    kernel_size dist {1 := 10, 3 := 60, 5 := 20, 7 := 10};
                    stride dist {1 := 70, 2 := 30};
                }
                
                if (op_type == POOL) {
                    kernel_size inside {2, 3};
                    stride == kernel_size; // 无重叠池化
                }
                
                // 精度模式随机化
                if (enable_mixed_precision) {
                    precision_mode dist {0 := 30, 1 := 50, 2 := 20}; // INT4:30%, INT8:50%, FP16:20%
                } else {
                    precision_mode == 1; // 仅INT8
                }
                
                // 稀疏度控制
                if (enable_sparse && op_type == SPARSE_CONV) {
                    sparsity_ratio dist {[0:30] := 20, [31:70] := 60, [71:90] := 20};
                } else {
                    sparsity_ratio == 0;
                }
            }) else `uvm_error("RAND", "Randomization failed");
            
            finish_item(tr);
        end
    endtask
endclass

// 增强的参考模型 - 位精确性能模型
class npu_ref_model extends uvm_component;
    `uvm_component_utils(npu_ref_model)
    
    uvm_tlm_analysis_fifo#(npu_transaction) input_fifo;
    uvm_analysis_port#(npu_transaction) output_ap;
    
    // 性能统计
    int total_operations = 0;
    int sparse_operations_skipped = 0;
    real average_sparsity = 0.0;
    
    // 配置
    bit enable_performance_modeling = 1;
    bit enable_precision_modeling = 1;
    
    function new(string name = "npu_ref_model", uvm_component parent = null);
        super.new(name, parent);
        input_fifo = new("input_fifo", this);
        output_ap = new("output_ap", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        npu_transaction input_tr, output_tr;
        
        forever begin
            input_fifo.get(input_tr);
            
            // 克隆事务
            $cast(output_tr, input_tr.clone());
            
            // 根据操作类型计算期望输出
            case (input_tr.op_type)
                npu_transaction::CONV: compute_conv(input_tr, output_tr);
                npu_transaction::FC: compute_fc(input_tr, output_tr);
                npu_transaction::POOL: compute_pool(input_tr, output_tr);
                npu_transaction::ACTIVATION: compute_activation(input_tr, output_tr);
            endcase
            
            // 发送期望输出
            output_ap.write(output_tr);
        end
    endtask
    
    // 卷积计算
    function void compute_conv(npu_transaction input_tr, output npu_transaction output_tr);
        int in_idx, w_idx, out_idx;
        int h, w, c, k_h, k_w, oc;
        int in_h, in_w;
        int accumulator;
        
        // 清空输出
        foreach (output_tr.output_data[i])
            output_tr.output_data[i] = 0;
        
        // 执行卷积
        for (h = 0; h < output_tr.output_height; h++) begin
            for (w = 0; w < output_tr.output_width; w++) begin
                for (oc = 0; oc < output_tr.output_channels; oc++) begin
                    accumulator = 0;
                    
                    for (k_h = 0; k_h < input_tr.kernel_size; k_h++) begin
                        for (k_w = 0; k_w < input_tr.kernel_size; k_w++) begin
                            for (c = 0; c < input_tr.input_channels; c++) begin
                                in_h = h * input_tr.stride - input_tr.padding + k_h;
                                in_w = w * input_tr.stride - input_tr.padding + k_w;
                                
                                if (in_h >= 0 && in_h < input_tr.input_height &&
                                    in_w >= 0 && in_w < input_tr.input_width) begin
                                    
                                    in_idx = (in_h * input_tr.input_width + in_w) * 
                                            input_tr.input_channels + c;
                                    w_idx = ((k_h * input_tr.kernel_size + k_w) * 
                                            input_tr.input_channels + c) * 
                                            output_tr.output_channels + oc;
                                    
                                    accumulator += input_tr.input_data[in_idx] * 
                                                  input_tr.weight_data[w_idx];
                                end
                            end
                        end
                    end
                    
                    out_idx = (h * output_tr.output_width + w) * 
                             output_tr.output_channels + oc;
                    output_tr.output_data[out_idx] = accumulator;
                end
            end
        end
    endfunction
endclass
            </div>

            <h4>12.3.3 性能验证与分析</h4>
            <div class="code-block">
// 性能监控模块
module PerformanceMonitor #(
    parameter NUM_COUNTERS = 16,
    parameter COUNTER_WIDTH = 48
)(
    input wire clk,
    input wire rst_n,
    
    // 事件输入
    input wire mac_valid,
    input wire cache_hit,
    input wire cache_miss,
    input wire ddr_read_valid,
    input wire ddr_write_valid,
    input wire [3:0] active_clusters,
    
    // 控制接口
    input wire [3:0] counter_select,
    output reg [COUNTER_WIDTH-1:0] counter_value,
    
    // 性能指标输出
    output reg [31:0] ops_per_second,
    output reg [31:0] bandwidth_utilization,
    output reg [31:0] cache_hit_rate,
    output reg [31:0] power_efficiency
);
    
    // 性能计数器
    reg [COUNTER_WIDTH-1:0] perf_counters [NUM_COUNTERS-1:0];
    
    // 计数器定义
    localparam CNT_CYCLES = 0;
    localparam CNT_MAC_OPS = 1;
    localparam CNT_CACHE_HITS = 2;
    localparam CNT_CACHE_MISSES = 3;
    localparam CNT_DDR_READS = 4;
    localparam CNT_DDR_WRITES = 5;
    localparam CNT_ACTIVE_CYCLES = 6;
    
    // 更新计数器
    always @(posedge clk) begin
        if (!rst_n) begin
            for (int i = 0; i < NUM_COUNTERS; i++)
                perf_counters[i] <= 0;
        end else begin
            // 周期计数
            perf_counters[CNT_CYCLES] <= perf_counters[CNT_CYCLES] + 1;
            
            // MAC操作计数
            if (mac_valid)
                perf_counters[CNT_MAC_OPS] <= perf_counters[CNT_MAC_OPS] + 1;
            
            // 缓存统计
            if (cache_hit)
                perf_counters[CNT_CACHE_HITS] <= perf_counters[CNT_CACHE_HITS] + 1;
            if (cache_miss)
                perf_counters[CNT_CACHE_MISSES] <= perf_counters[CNT_CACHE_MISSES] + 1;
            
            // DDR访问统计
            if (ddr_read_valid)
                perf_counters[CNT_DDR_READS] <= perf_counters[CNT_DDR_READS] + 1;
            if (ddr_write_valid)
                perf_counters[CNT_DDR_WRITES] <= perf_counters[CNT_DDR_WRITES] + 1;
            
            // 活跃周期统计
            if (|active_clusters)
                perf_counters[CNT_ACTIVE_CYCLES] <= perf_counters[CNT_ACTIVE_CYCLES] + 1;
        end
    end
    
    // 性能指标计算
    reg [31:0] sample_counter;
    localparam SAMPLE_PERIOD = 1000000; // 1M cycles
    
    always @(posedge clk) begin
        if (!rst_n) begin
            sample_counter <= 0;
            ops_per_second <= 0;
            bandwidth_utilization <= 0;
            cache_hit_rate <= 0;
            power_efficiency <= 0;
        end else begin
            sample_counter <= sample_counter + 1;
            
            if (sample_counter == SAMPLE_PERIOD) begin
                sample_counter <= 0;
                
                // 计算OPS (假设1GHz时钟)
                ops_per_second <= (perf_counters[CNT_MAC_OPS] * 1000);
                
                // 带宽利用率 (假设峰值16GB/s，每次传输32B)
                bandwidth_utilization <= ((perf_counters[CNT_DDR_READS] + 
                                         perf_counters[CNT_DDR_WRITES]) * 32 * 100) / 
                                        (16 * SAMPLE_PERIOD / 1000);
                
                // 缓存命中率
                if (perf_counters[CNT_CACHE_HITS] + perf_counters[CNT_CACHE_MISSES] > 0)
                    cache_hit_rate <= (perf_counters[CNT_CACHE_HITS] * 100) / 
                                     (perf_counters[CNT_CACHE_HITS] + 
                                      perf_counters[CNT_CACHE_MISSES]);
                
                // 功耗效率 (GOPS/W，假设)
                power_efficiency <= ops_per_second / 5000; // 假设5W功耗
                
                // 重置统计计数器
                for (int i = 1; i < NUM_COUNTERS; i++)
                    perf_counters[i] <= 0;
            end
        end
    end
    
    // 读取计数器
    always @(*) begin
        counter_value = perf_counters[counter_select];
    end
endmodule

// 功能覆盖率收集
class npu_coverage extends uvm_subscriber#(npu_transaction);
    `uvm_component_utils(npu_coverage)
    
    // 覆盖率组
    covergroup operation_cg;
        // 操作类型覆盖
        op_type_cp: coverpoint trans.op_type {
            bins conv = {npu_transaction::CONV};
            bins fc = {npu_transaction::FC};
            bins pool = {npu_transaction::POOL};
            bins act = {npu_transaction::ACTIVATION};
        }
        
        // 卷积核大小覆盖
        kernel_size_cp: coverpoint trans.kernel_size {
            bins small = {1};
            bins medium = {3};
            bins large = {5, 7};
        }
        
        // 通道数覆盖
        channels_cp: coverpoint trans.input_channels {
            bins low = {[16:63]};
            bins medium = {[64:255]};
            bins high = {[256:512]};
        }
        
        // 交叉覆盖
        op_kernel_cross: cross op_type_cp, kernel_size_cp {
            ignore_bins invalid = binsof(op_type_cp.fc) || 
                                 binsof(op_type_cp.pool);
        }
    endgroup
    
    // 性能覆盖
    covergroup performance_cg;
        // MAC利用率
        mac_utilization_cp: coverpoint get_mac_utilization() {
            bins low = {[0:25]};
            bins medium = {[26:75]};
            bins high = {[76:100]};
        }
        
        // 内存带宽利用率
        memory_bandwidth_cp: coverpoint get_memory_bandwidth() {
            bins low = {[0:30]};
            bins medium = {[31:70]};
            bins high = {[71:100]};
        }
    endgroup
    
    npu_transaction trans;
    
    function new(string name = "npu_coverage", uvm_component parent = null);
        super.new(name, parent);
        operation_cg = new();
        performance_cg = new();
    endfunction
    
    function void write(npu_transaction t);
        trans = t;
        operation_cg.sample();
        performance_cg.sample();
    endfunction
    
    function int get_mac_utilization();
        // 从DUT获取MAC利用率
        return 80; // 示例值
    endfunction
    
    function int get_memory_bandwidth();
        // 从DUT获取内存带宽利用率
        return 65; // 示例值
    endfunction
endclass
            </div>

            <div class="exercise">
                <h4>练习 4：验证方案设计</h4>
                <p>设计一个完整的NPU验证方案，包括：</p>
                <ol>
                    <li>针对Transformer模型的专用测试序列</li>
                    <li>压力测试场景，验证极限性能</li>
                    <li>功耗验证环境，确保满足TDP要求</li>
                </ol>
                
                <button class="toggle-answer">显示答案</button>
                <div class="answer">
                    <div class="code-block">
// Transformer测试序列
class transformer_test_sequence extends uvm_sequence#(npu_transaction);
    `uvm_object_utils(transformer_test_sequence)
    
    // Transformer参数
    int seq_length = 512;
    int hidden_dim = 768;
    int num_heads = 12;
    int batch_size = 1;
    
    function new(string name = "transformer_test_sequence");
        super.new(name);
    endfunction
    
    task body();
        // 生成自注意力测试
        generate_self_attention_test();
        
        // 生成前馈网络测试
        generate_ffn_test();
        
        // 生成完整Transformer层测试
        generate_full_transformer_test();
    endtask
    
    task generate_self_attention_test();
        npu_transaction tr;
        
        // Q, K, V矩阵乘法
        repeat(3) begin
            tr = npu_transaction::type_id::create("tr");
            start_item(tr);
            
            assert(tr.randomize() with {
                op_type == npu_transaction::FC;
                input_height == seq_length;
                input_width == hidden_dim;
                input_channels == 1;
                output_height == seq_length;
                output_width == hidden_dim;
                output_channels == 1;
            });
            
            finish_item(tr);
        end
        
        // QK^T矩阵乘法
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::FC;
            input_height == seq_length;
            input_width == hidden_dim / num_heads;
            output_height == seq_length;
            output_width == seq_length;
        });
        
        finish_item(tr);
        
        // Softmax (使用activation操作)
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::ACTIVATION;
            input_height == seq_length;
            input_width == seq_length;
        });
        
        finish_item(tr);
    endtask
    
    task generate_ffn_test();
        npu_transaction tr;
        
        // 第一个线性层 (扩展维度)
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::FC;
            input_width == hidden_dim;
            output_width == hidden_dim * 4;
        });
        
        finish_item(tr);
        
        // GELU激活
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::ACTIVATION;
            input_width == hidden_dim * 4;
        });
        
        finish_item(tr);
        
        // 第二个线性层 (压缩维度)
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::FC;
            input_width == hidden_dim * 4;
            output_width == hidden_dim;
        });
        
        finish_item(tr);
    endtask
endclass

// 压力测试环境
class stress_test extends uvm_test;
    `uvm_component_utils(stress_test)
    
    npu_env env;
    
    function new(string name = "stress_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        env = npu_env::type_id::create("env", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        stress_sequence seq;
        
        phase.raise_objection(this);
        
        // 运行压力测试序列
        seq = stress_sequence::type_id::create("seq");
        seq.start(env.input_agent.sequencer);
        
        // 等待所有事务完成
        #100000ns;
        
        phase.drop_objection(this);
    endtask
endclass

// 压力测试序列
class stress_sequence extends uvm_sequence#(npu_transaction);
    `uvm_object_utils(stress_sequence)
    
    function new(string name = "stress_sequence");
        super.new(name);
    endfunction
    
    task body();
        npu_transaction tr;
        
        // 并发生成多个大规模计算任务
        fork
            // 线程1: 大尺寸卷积
            begin
                repeat(50) begin
                    tr = npu_transaction::type_id::create("tr1");
                    start_item(tr);
                    assert(tr.randomize() with {
                        op_type == npu_transaction::CONV;
                        input_height == 224;
                        input_width == 224;
                        input_channels == 256;
                        output_channels == 512;
                        kernel_size == 3;
                    });
                    finish_item(tr);
                end
            end
            
            // 线程2: 大规模全连接
            begin
                repeat(30) begin
                    tr = npu_transaction::type_id::create("tr2");
                    start_item(tr);
                    assert(tr.randomize() with {
                        op_type == npu_transaction::FC;
                        input_width == 4096;
                        output_width == 4096;
                    });
                    finish_item(tr);
                end
            end
            
            // 线程3: 混合操作
            begin
                repeat(100) begin
                    tr = npu_transaction::type_id::create("tr3");
                    start_item(tr);
                    assert(tr.randomize());
                    finish_item(tr);
                end
            end
        join
    endtask
endclass

// 功耗验证模块
module PowerVerification #(
    parameter VOLTAGE_LEVELS = 8,
    parameter FREQ_LEVELS = 8
)(
    input wire clk,
    input wire rst_n,
    
    // DUT功耗相关信号
    input wire [2:0] voltage_level,
    input wire [2:0] frequency_level,
    input wire [3:0] active_clusters,
    input wire [15:0] mac_activity,
    input wire [15:0] memory_activity,
    
    // 功耗测量
    output reg [31:0] instant_power_mw,
    output reg [31:0] average_power_mw,
    output reg [31:0] peak_power_mw,
    output reg tdp_violation
);
    
    // 功耗查找表 (mW)
    reg [15:0] voltage_power_table [VOLTAGE_LEVELS-1:0];
    reg [15:0] frequency_power_table [FREQ_LEVELS-1:0];
    
    // 初始化功耗表
    initial begin
        // 电压功耗表 (二次关系)
        voltage_power_table[0] = 500;   // 0.6V
        voltage_power_table[1] = 800;   // 0.65V
        voltage_power_table[2] = 1200;  // 0.7V
        voltage_power_table[3] = 1700;  // 0.75V
        voltage_power_table[4] = 2300;  // 0.8V
        voltage_power_table[5] = 3000;  // 0.85V
        voltage_power_table[6] = 3800;  // 0.9V
        voltage_power_table[7] = 4700;  // 0.95V
        
        // 频率功耗表 (线性关系)
        frequency_power_table[0] = 100;   // 250MHz
        frequency_power_table[1] = 200;   // 500MHz
        frequency_power_table[2] = 300;   // 625MHz
        frequency_power_table[3] = 400;   // 750MHz
        frequency_power_table[4] = 500;   // 875MHz
        frequency_power_table[5] = 600;   // 1000MHz
        frequency_power_table[6] = 700;   // 1125MHz
        frequency_power_table[7] = 800;   // 1250MHz
    end
    
    // 计算瞬时功耗
    reg [31:0] static_power, dynamic_power;
    reg [31:0] compute_power, memory_power;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            instant_power_mw <= 0;
            static_power <= 0;
            dynamic_power <= 0;
        end else begin
            // 静态功耗
            static_power = voltage_power_table[voltage_level] * active_clusters / 4;
            
            // 动态功耗
            compute_power = (mac_activity * frequency_power_table[frequency_level]) >> 8;
            memory_power = (memory_activity * voltage_power_table[voltage_level]) >> 10;
            dynamic_power = compute_power + memory_power;
            
            // 总功耗
            instant_power_mw <= static_power + dynamic_power;
        end
    end
    
    // 计算平均功耗
    reg [39:0] power_accumulator;
    reg [31:0] sample_count;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            power_accumulator <= 0;
            sample_count <= 0;
            average_power_mw <= 0;
            peak_power_mw <= 0;
        end else begin
            power_accumulator <= power_accumulator + instant_power_mw;
            sample_count <= sample_count + 1;
            
            // 每1000个周期更新平均值
            if (sample_count[9:0] == 0) begin
                average_power_mw <= power_accumulator / 1000;
                power_accumulator <= 0;
            end
            
            // 更新峰值
            if (instant_power_mw > peak_power_mw) begin
                peak_power_mw <= instant_power_mw;
            end
        end
    end
    
    // TDP违规检测
    localparam TDP_LIMIT_MW = 5000; // 5W TDP
    
    always @(posedge clk) begin
        if (!rst_n) begin
            tdp_violation <= 0;
        end else begin
            tdp_violation <= (average_power_mw > TDP_LIMIT_MW);
        end
    end
    
    // 断言检查
    // synthesis translate_off
    property tdp_check;
        @(posedge clk) disable iff (!rst_n)
        average_power_mw <= TDP_LIMIT_MW;
    endproperty
    
    assert property(tdp_check) else
        $error("TDP violation: average power %0d mW exceeds limit %0d mW", 
               average_power_mw, TDP_LIMIT_MW);
    
    property power_state_transition;
        @(posedge clk) disable iff (!rst_n)
        ($changed(voltage_level) || $changed(frequency_level)) |-> 
        ##[1:100] $stable(instant_power_mw);
    endproperty
    
    assert property(power_state_transition) else
        $error("Power state transition not stable");
    // synthesis translate_on
endmodule
                    </div>
                    <p><strong>解析：</strong></p>
                    <ul>
                        <li>Transformer测试序列覆盖了自注意力、前馈网络等关键操作</li>
                        <li>压力测试通过并发执行多种大规模计算任务，验证NPU极限性能</li>
                        <li>功耗验证模块实时监测瞬时功耗、平均功耗和峰值功耗</li>
                        <li>包含TDP违规检测和功耗状态转换的断言检查</li>
                        <li>通过查找表模拟不同电压频率下的功耗特性</li>
                    </ul>
                </div>
            </div>

            <h3>12.4 综合与后端实现</h3>
            
            <p>本节将介绍NPU的逻辑综合、物理设计和后端实现流程。</p>

            <h4>12.4.1 逻辑综合</h4>
            <div class="code-block">
# 改进的Design Compiler综合脚本 - 更接近工业实践
# npu_synthesis_enhanced.tcl

# 设置库路径和工艺库
set TECH_NODE "16nm"
set search_path ". /tools/libraries/$TECH_NODE ./rtl ./include"
set target_library "${TECH_NODE}_hvt.db ${TECH_NODE}_svt.db ${TECH_NODE}_lvt.db"
set link_library "* $target_library"
set symbol_library "${TECH_NODE}.sdb"

# 设置TLU+文件用于精确的RC提取
set_tlu_plus_files -max_tluplus /tools/libraries/$TECH_NODE/tluplus/maxTLU+ \
                   -min_tluplus /tools/libraries/$TECH_NODE/tluplus/minTLU+ \
                   -tech2itf_map /tools/libraries/$TECH_NODE/tech2itf.map

# 读取设计文件
set RTL_LIST {
    ./rtl/npu_top.v
    ./rtl/compute_cluster.v
    ./rtl/pe_array.v
    ./rtl/memory_system.v
    ./rtl/noc_router.v
    ./rtl/sparse_accelerator.v
    ./rtl/power_management.v
}

analyze -format verilog $RTL_LIST
elaborate EdgeNPU_Top -parameters "NUM_CLUSTERS=4,MACS_PER_CLUSTER=512"
current_design EdgeNPU_Top
link

# 检查设计一致性
check_design -summary
report_design > reports/design_check.rpt

# ===========================================
# 时序约束 - 多模式多角(MMMC)
# ===========================================

# 主时钟定义
create_clock -period 1.0 -name sys_clk [get_ports clk]
create_clock -period 0.8 -name noc_clk [get_ports noc_clk]

# 时钟不确定性 - 考虑抖动和偏移
set_clock_uncertainty -setup 0.05 [get_clocks sys_clk]
set_clock_uncertainty -hold 0.03 [get_clocks sys_clk]
set_clock_transition 0.08 [get_clocks sys_clk]

# 虚拟时钟用于DFT
create_clock -period 10.0 -name test_clk [get_ports test_clk]

# 输入输出延迟 - 基于系统级时序预算
# 输入延迟 = Tco(上游芯片) + Tpcb(板级走线) + Tmargin
set INPUT_DELAY_MAX 0.3
set INPUT_DELAY_MIN 0.1
set_input_delay -clock sys_clk -max $INPUT_DELAY_MAX [remove_from_collection [all_inputs] [get_ports {clk rst_n}]]
set_input_delay -clock sys_clk -min $INPUT_DELAY_MIN [remove_from_collection [all_inputs] [get_ports {clk rst_n}]]

# 输出延迟 = Tsu(下游芯片) + Tpcb + Tmargin  
set OUTPUT_DELAY_MAX 0.25
set OUTPUT_DELAY_MIN 0.05
set_output_delay -clock sys_clk -max $OUTPUT_DELAY_MAX [all_outputs]
set_output_delay -clock sys_clk -min $OUTPUT_DELAY_MIN [all_outputs]

# 异步路径和多周期路径
set_false_path -from [get_clocks sys_clk] -to [get_clocks noc_clk]
set_false_path -from [get_clocks noc_clk] -to [get_clocks sys_clk]
set_false_path -from [get_ports rst_n] -to [all_registers]

# MAC阵列的多周期路径
set_multicycle_path -setup 2 -from [get_pins mac_array/*/mult_reg*] -to [get_pins mac_array/*/acc_reg*]
set_multicycle_path -hold 1 -from [get_pins mac_array/*/mult_reg*] -to [get_pins mac_array/*/acc_reg*]

# 设置面积和功耗约束
set_max_area 25000000  # 25mm²
set_max_dynamic_power 3.0  # 3W动态功耗
set_max_leakage_power 0.5  # 0.5W泄漏功耗

# 多阈值电压优化
set_multi_vth_constraint -lvth_percentage 10 \
                        -hvth_percentage 60

# 时钟门控插入
set_clock_gating_style -sequential_cell latch \
                      -positive_edge_logic {and} \
                      -negative_edge_logic {or} \
                      -control_point before \
                      -control_signal scan_enable

insert_clock_gating

# 设置优化策略
set_optimize_registers true
set_boundary_optimization true
set compile_ultra_ungroup_dw false

# ===========================================
# 综合策略和优化
# ===========================================

# 启用高级优化选项
set_app_var compile_enable_register_merging true
set_app_var compile_seqmap_enable_output_inversion true
set_app_var placer_channel_detect_mode true

# 时序驱动综合配置
set_app_var compile_timing_high_effort true
set_app_var psynopt_area_recovery_high_effort true

# 开始综合 - 分阶段进行
echo "========== Starting Synthesis =========="
date

# 第一阶段：高级综合
compile_ultra -no_autoungroup -no_boundary_optimization

# 第二阶段：寄存器优化
optimize_registers -print_critical_loop

# 第三阶段：增量优化
compile_ultra -incremental -scan

# ===========================================
# DFT插入
# ===========================================

# 设置DFT配置
set_dft_configuration -scan_style muxed_scan \
                     -test_mode_port test_mode \
                     -scan_enable_port scan_enable

# 定义扫描链
set_scan_configuration -chain_count 16 \
                      -clock_mixing mix_clocks \
                      -add_lockup true \
                      -test_mode test_mode

# 插入DFT结构
insert_dft

# ===========================================
# 最终优化和报告
# ===========================================

# 最终时序优化
optimize_netlist -area

# 生成详细报告
echo "========== Generating Reports =========="

# 时序报告
report_timing -delay_type max -nworst 1 -max_paths 100 -sort_by group > reports/setup_timing.rpt
report_timing -delay_type min -nworst 1 -max_paths 100 -sort_by group > reports/hold_timing.rpt
report_clock -skew -attribute > reports/clock_report.rpt

# 面积和功耗报告  
report_area -hierarchy -physical > reports/area_physical.rpt
report_power -analysis_effort high -verbose > reports/power_analysis.rpt
report_saif > reports/switching_activity.rpt

# 约束违例报告
report_constraint -all_violators -verbose > reports/all_violations.rpt
report_timing -loops > reports/timing_loops.rpt

# QoR报告
report_qor > reports/qor_summary.rpt

# DFT报告
report_dft > reports/dft_summary.rpt
report_scan_chain > reports/scan_chains.rpt

# ===========================================
# 输出文件
# ===========================================

# 保存设计
write_file -format ddc -hierarchy -output results/npu_top.ddc

# 输出网表
change_names -rules verilog -hierarchy
write_file -format verilog -hierarchy -output netlists/npu_top_synth.v

# 输出约束
write_sdc -nosplit constraints/npu_top_final.sdc

# 输出延迟文件
write_sdf delays/npu_top_max.sdf -context verilog
write_sdf delays/npu_top_min.sdf -context verilog -min_view

# 输出形式验证文件
set_svf -off

date
echo "========== Synthesis Complete =========="
            </div>

            <h4>12.4.2 物理设计</h4>
            <div class="code-block">
# 改进的Innovus物理设计脚本 - 多模式多角(MMMC)和迭代优化
# npu_physical_design_enhanced.tcl

# ===========================================
# MMMC设置
# ===========================================

# 定义工艺角
create_library_set -name SS_125C -timing {/tools/libs/16nm/ss_125c.lib} \
                   -si {/tools/libs/16nm/ss_125c.cdb}
create_library_set -name TT_25C -timing {/tools/libs/16nm/tt_25c.lib} \
                   -si {/tools/libs/16nm/tt_25c.cdb}  
create_library_set -name FF_M40C -timing {/tools/libs/16nm/ff_m40c.lib} \
                   -si {/tools/libs/16nm/ff_m40c.cdb}

# 定义RC角
create_rc_corner -name RC_worst -cap_table /tools/tech/16nm/capTbl_worst \
                 -T 125 -preRoute_res 1.2 -preRoute_cap 1.2 \
                 -postRoute_res 1.2 -postRoute_cap 1.2
create_rc_corner -name RC_typ -cap_table /tools/tech/16nm/capTbl_typ \
                 -T 25 -preRoute_res 1 -preRoute_cap 1 \
                 -postRoute_res 1 -postRoute_cap 1
create_rc_corner -name RC_best -cap_table /tools/tech/16nm/capTbl_best \
                 -T -40 -preRoute_res 0.8 -preRoute_cap 0.8 \
                 -postRoute_res 0.8 -postRoute_cap 0.8

# 定义延迟角
create_delay_corner -name DC_max -library_set SS_125C -rc_corner RC_worst
create_delay_corner -name DC_typ -library_set TT_25C -rc_corner RC_typ  
create_delay_corner -name DC_min -library_set FF_M40C -rc_corner RC_best

# 定义约束模式
create_constraint_mode -name FUNC -sdc_files {./constraints/npu_func.sdc}
create_constraint_mode -name TEST -sdc_files {./constraints/npu_test.sdc}

# 定义分析视图
create_analysis_view -name av_func_max -constraint_mode FUNC -delay_corner DC_max
create_analysis_view -name av_func_typ -constraint_mode FUNC -delay_corner DC_typ
create_analysis_view -name av_func_min -constraint_mode FUNC -delay_corner DC_min
create_analysis_view -name av_test_max -constraint_mode TEST -delay_corner DC_max

set_analysis_view -setup {av_func_max av_test_max} -hold {av_func_min}

# ===========================================
# 设计初始化
# ===========================================

# 读取设计
init_design -netlist ./netlists/npu_top_synth.v \
           -top EdgeNPU_Top \
           -lef {/tools/tech/16nm/tech.lef /tools/libs/16nm/cells.lef} \
           -mmmc_file ./scripts/mmmc.tcl \
           -powerNet {VDD} \
           -groundNet {VSS}

# 全局变量设置
setDesignMode -process 16
setUsefulSkew true
setOptMode -usefulSkew true -preserveAllSequential false
setNanoRouteMode -routeInsertAntennaDiode true -routeAntennaCellName ANTENNA

# ===========================================
# Floorplan规划
# ===========================================

# 计算芯片尺寸 - 基于利用率和面积估算
set CORE_UTILIZATION 0.7
set CORE_ASPECT_RATIO 1.0
set CORE_MARGIN 10

floorPlan -site core_site -r $CORE_ASPECT_RATIO $CORE_UTILIZATION \
          $CORE_MARGIN $CORE_MARGIN $CORE_MARGIN $CORE_MARGIN

# 创建电压域
createVoltageArea -name CORE_PD -coordinate {500 500 4500 4500} \
                  -powerDomain PD_CORE -netNames {VDD VSS}
createVoltageArea -name AON_PD -coordinate {100 100 500 4900} \
                  -powerDomain PD_AON -netNames {VDDAON VSSAON}

# SRAM宏单元的自动化布局
# 定义宏单元列表
set sram_macros [get_cells -hierarchical -filter "ref_name=~SRAM*"]

# 创建Macro放置组 - 确保对齐和间距
createMacroArray -macros $sram_macros \
                 -rows 2 -cols 2 \
                 -xSpace 100 -ySpace 100 \
                 -site core_site

# 为SRAM创建框区和Halo
foreach macro $sram_macros {
    createHaloFromPin -allBlock -topleft 20 20 -bottomright 20 20
    createRouteBlk -layer {M1 M2 M3} -box [getObjBBox $macro] -exceptPGNet
}

# 计算簇的分区规划
set cluster_width 800
set cluster_height 800
set cluster_spacing 50

for {set i 0} {$i < 4} {incr i} {
    set x [expr 1000 + $i * ($cluster_width + $cluster_spacing)]
    set y 1000
    
    createRegion cluster_${i}_region $x $y \
                 [expr $x + $cluster_width] [expr $y + $cluster_height]
    
    assignInstToRegion [get_cells compute_cluster_${i}/*] cluster_${i}_region
    
    # 为每个簇设置密度约束
    setPlaceMode -region cluster_${i}_region -density 0.85
}

# IO规划
loadIoFile ./scripts/io_assignment.io

# ===========================================
# 电源规划 - 考虑功耗密度和IR Drop
# ===========================================

# 计算电源需求
set POWER_BUDGET 5.0 ;# 5W TDP
set VDD_VOLTAGE 0.8  ;# 0.8V
set CURRENT_TOTAL [expr $POWER_BUDGET / $VDD_VOLTAGE]
set IR_DROP_TARGET 0.05 ;# 5% IR drop

# 全局电源网格创建
# 电源环 - 顶层金属
addRing -nets {VDD VSS} -type core_rings \
        -layer {top M9 bottom M9 left M10 right M10} \
        -width {top 30 bottom 30 left 30 right 30} \
        -spacing {top 10 bottom 10 left 10 right 10} \
        -offset {top 5 bottom 5 left 5 right 5} \
        -center 1

# 分层电源条带规划
# M10 - 主要水平电源条带
addStripe -nets {VDD VSS} -layer M10 -direction horizontal \
          -width 20 -spacing 10 -set_to_set_distance 200 \
          -start_offset 100 -stop_offset 100 \
          -extend_to design_boundary

# M9 - 主要垂直电源条带  
addStripe -nets {VDD VSS} -layer M9 -direction vertical \
          -width 20 -spacing 10 -set_to_set_distance 200 \
          -start_offset 100 -stop_offset 100 \
          -extend_to design_boundary

# M8 - 次级水平电源条带
addStripe -nets {VDD VSS} -layer M8 -direction horizontal \
          -width 10 -spacing 5 -set_to_set_distance 100 \
          -start_offset 50 -stop_offset 50 \
          -extend_to design_boundary

# 针对高功耗区域的加密电源网格
# MAC阵列区域 - 需要更密集的电源网格
foreach region [get_db regions cluster_*_region] {
    selectInst [get_db $region .insts]
    
    addStripe -nets {VDD VSS} -layer M7 -direction vertical \
              -width 5 -spacing 2.5 -set_to_set_distance 25 \
              -area [get_db $region .bbox]
    
    addStripe -nets {VDD VSS} -layer M6 -direction horizontal \
              -width 5 -spacing 2.5 -set_to_set_distance 25 \
              -area [get_db $region .bbox]
}

# Via阵列优化 - 减少层间电阻
setViaGenMode -optimize_cross_via true \
              -optimize_via_on_routing_track true \
              -viarule_preference generated

# 标准单元电源轨连接
sroute -connect {blockPin padPin corePin floatingStripe} \
       -layerChangeRange {M1 M10} \
       -blockPinTarget {nearestTarget} \
       -deleteExistingRoutes \
       -allowJogging 1 \
       -crossoverViaLayerRange {M1 M10} \
       -allowLayerChange 1 \
       -nets {VDD VSS}

# 电源分析
analyzeRail -type ir
report_rail -type ir > reports/ir_drop_initial.rpt

# 标准单元电源轨
sroute -connect {blockPin padPin padRing corePin floatingStripe} \
       -layerChangeRange {M1 M10} -blockPinTarget {nearestTarget} \
       -padPinPortConnect {allPort oneGeom} -padPinTarget {nearestTarget} \
       -corePinTarget {firstAfterRowEnd} -floatingStripeTarget {blockring padring ring stripe ringpin blockpin followpin} \
       -allowJogging 1 -crossoverViaLayerRange {M1 M10} \
       -nets {VDD VSS}

# ===========================================
# 布局优化 - 迭代式
# ===========================================

# 布局前设置
setPlaceMode -reset
setPlaceMode -congEffort high \
             -timingDriven true \
             -modulePlan true \
             -clkGateAware true \
             -powerDriven true \
             -ignoreScan false \
             -reorderScan true \
             -ignoreSpare false \
             -placeIOPins false \
             -moduleAwareSpare true \
             -preserveRouting false \
             -rmAffectedRouting false \
             -checkRoute false \
             -swapEEQ false

# 设置布局密度目标
setPlaceMode -uniformDensity true -maxDensity 0.85

# 阶段1：全局布局
place_global_opt

# 拥塞分析
reportCongestion -hotSpot -overflow -includeBlockage > reports/congestion_global.rpt

# 阶段2：详细布局
setOptMode -fixCap true -fixTran true -fixFanoutLoad true
placeDesign -incremental -timingDriven

# 阶段3：布局后优化
optDesign -prePlaceOpt

# 扫描链重排
scanReorder

# ===========================================
# 时钟树综合(CTS) - 使用CCOpt
# ===========================================

# 设置CCOpt选项
set_ccopt_property buffer_cells {CKBUF_X16M CKBUF_X20M CKBUF_X24M}
set_ccopt_property inverter_cells {CKINV_X16M CKINV_X20M CKINV_X24M}
set_ccopt_property clock_gating_cells {CKLHQD_X2M CKLHQD_X4M}
set_ccopt_property target_skew 0.02
set_ccopt_property target_insertion_delay 0.3

# 创建时钟树规范
create_ccopt_clock_tree_spec -file ccopt.spec \
                             -immediate

# 设置时钟树约束
set_ccopt_property -clock_tree sys_clk routing_rule clk_rule
set_ccopt_property -clock_tree sys_clk max_fanout 32
set_ccopt_property -clock_tree sys_clk max_transition 0.08

# 执行CTS
ccopt_design -cts

# CTS后报告
report_ccopt_clock_trees -summary > reports/cts_summary.rpt
report_ccopt_skew_groups > reports/cts_skew.rpt

# ===========================================
# 后CTS优化
# ===========================================

# 修复保持时间违例
optDesign -postCTS -hold

# 有用偏移优化
setOptMode -usefulSkew true
optDesign -postCTS -setup

# 布线
setNanoRouteMode -quiet -timingEngine {}
setNanoRouteMode -quiet -routeWithTimingDriven 1
setNanoRouteMode -quiet -routeWithSiDriven 1
setNanoRouteMode -quiet -routeTopRoutingLayer 10
setNanoRouteMode -quiet -routeBottomRoutingLayer 1
setNanoRouteMode -quiet -drouteEndIteration 10
setNanoRouteMode -quiet -routeWithTimingDriven true
setNanoRouteMode -quiet -routeWithSiDriven true

routeDesign -globalDetail

# 后布线优化
optDesign -postRoute -hold

# 填充单元插入
addFiller -cell {FILL1 FILL2 FILL4 FILL8} -prefix FILLER

# DRC/LVS修复
fixVia -minCut
fixMetalFill

# SI分析和修复
setDelayCalMode -engine default -siAware true
setAnalysisMode -analysisType onChipVariation
timeDesign -postRoute -pathReports -drvReports -slackReports -numPaths 50 -prefix postRoute -outDir timingReports

# 功耗分析
report_power -outfile reports/final_power.rpt

# 输出设计
saveDesign final_design.enc
defOut -floorplan -netlist -routing npu_final.def
            </div>

            <h4>12.4.3 时序收敛与签核</h4>
            <div class="code-block">
# PrimeTime时序签核脚本
# timing_signoff.tcl

# 读取设计
read_verilog ./netlists/npu_final.v
current_design EdgeNPU_Top
link_design

# 读取寄生参数
read_parasitics -format SPEF ./spef/npu_final.spef

# 设置操作条件
set_operating_conditions -analysis_type on_chip_variation

# 定义时钟
create_clock -period 1.0 [get_ports clk]
set_clock_uncertainty -setup 0.05 [get_clocks clk]
set_clock_uncertainty -hold 0.03 [get_clocks clk]
set_clock_transition 0.08 [get_clocks clk]

# AOCV设置
set_aocvm_mode manual
read_aocvm 16nm_aocvm.table

# CPPR分析
set timing_remove_clock_reconvergence_pessimism true

# 多模式多角分析
# 定义角
create_scenario -name func_ss_125c
set_operating_conditions SS_125C
set_voltage 0.72 -object_list VDD

create_scenario -name func_ff_m40c
set_operating_conditions FF_M40C
set_voltage 0.88 -object_list VDD

# 执行时序分析
update_timing -full
report_timing -delay_type max -nworst 1 -max_paths 1000 > timing_setup.rpt
report_timing -delay_type min -nworst 1 -max_paths 1000 > timing_hold.rpt

# 时序违规分析
report_constraint -all_violators > violations.rpt

# 功耗分析
set power_enable_analysis true
set power_analysis_mode averaged

read_saif ./saif/npu_vectors.saif -strip_path testbench/dut
update_power
report_power -hierarchy > power_signoff.rpt

# ECO修复脚本生成
write_changes -format icctcl -output eco_fixes.tcl

# 时序模型生成
extract_model -output ./models/npu_timing.lib -format liberty \
              -timing -power -test

# 生成最终报告
report_design > design_summary.rpt
report_clock_timing -type summary > clock_summary.rpt
report_analysis_coverage > coverage.rpt
            </div>

            <h4>12.4.4 DFT与可测试性设计</h4>
            <div class="code-block">
// DFT控制器
module DFTController (
    input wire clk,
    input wire rst_n,
    
    // 测试模式控制
    input wire test_mode,
    input wire scan_enable,
    input wire mbist_mode,
    
    // 扫描链接口
    input wire scan_in,
    output wire scan_out,
    
    // MBIST接口
    output wire mbist_start,
    output wire mbist_done,
    output wire mbist_fail,
    
    // JTAG接口
    input wire tck,
    input wire tms,
    input wire tdi,
    output wire tdo,
    input wire trst_n
);
    
    // 扫描链配置
    localparam NUM_SCAN_CHAINS = 16;
    localparam SCAN_LENGTH = 10000;
    
    // 扫描链多路复用
    wire [NUM_SCAN_CHAINS-1:0] chain_scan_in;
    wire [NUM_SCAN_CHAINS-1:0] chain_scan_out;
    
    // 扫描链分配
    genvar i;
    generate
        for (i = 0; i < NUM_SCAN_CHAINS; i = i + 1) begin : scan_chain
            assign chain_scan_in[i] = (i == 0) ? scan_in : chain_scan_out[i-1];
        end
    endgenerate
    assign scan_out = chain_scan_out[NUM_SCAN_CHAINS-1];
    
    // MBIST控制器
    MBISTController #(
        .NUM_MEMORIES(32),
        .ADDR_WIDTH(18),
        .DATA_WIDTH(256)
    ) mbist_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .mbist_mode(mbist_mode),
        .start(mbist_start),
        .done(mbist_done),
        .fail(mbist_fail),
        // 内存接口连接
        .mem_en(),
        .mem_we(),
        .mem_addr(),
        .mem_wdata(),
        .mem_rdata()
    );
    
    // JTAG TAP控制器
    JTAGController jtag_ctrl (
        .tck(tck),
        .tms(tms),
        .tdi(tdi),
        .tdo(tdo),
        .trst_n(trst_n),
        // 内部寄存器访问
        .reg_addr(),
        .reg_data(),
        .reg_we()
    );
    
    // ATPG测试点插入
    // 提高可测试性的观察点和控制点
    reg [31:0] test_point_observe;
    reg [31:0] test_point_control;
    
    always @(posedge clk) begin
        if (test_mode) begin
            // 在测试模式下激活测试点
            test_point_observe <= internal_hard_to_observe_signals;
            internal_hard_to_control_signals <= test_point_control;
        end
    end
endmodule

// MBIST算法实现
module MBISTController #(
    parameter NUM_MEMORIES = 32,
    parameter ADDR_WIDTH = 18,
    parameter DATA_WIDTH = 256
)(
    input wire clk,
    input wire rst_n,
    input wire mbist_mode,
    input wire start,
    output reg done,
    output reg fail,
    
    // 内存接口
    output reg [NUM_MEMORIES-1:0] mem_en,
    output reg [NUM_MEMORIES-1:0] mem_we,
    output reg [ADDR_WIDTH-1:0] mem_addr,
    output reg [DATA_WIDTH-1:0] mem_wdata,
    input wire [DATA_WIDTH-1:0] mem_rdata [NUM_MEMORIES-1:0]
);
    
    // MBIST状态机
    typedef enum logic [3:0] {
        IDLE,
        MARCH_C_W0,    // March C- Write 0
        MARCH_C_R0W1,  // March C- Read 0, Write 1
        MARCH_C_R1W0,  // March C- Read 1, Write 0
        MARCH_C_R0,    // March C- Read 0
        CHECKERBOARD,  // Checkerboard测试
        ADDRESS_DECODE, // 地址解码测试
        RETENTION,     // 数据保持测试
        REPORT
    } mbist_state_t;
    
    mbist_state_t state;
    reg [7:0] current_memory;
    reg [ADDR_WIDTH-1:0] current_addr;
    reg [DATA_WIDTH-1:0] expected_data;
    reg [31:0] error_count;
    reg [7:0] failing_memory;
    reg [ADDR_WIDTH-1:0] failing_addr;
    
    // March C-算法实现
    always @(posedge clk) begin
        if (!rst_n) begin
            state <= IDLE;
            done <= 0;
            fail <= 0;
            error_count <= 0;
        end else if (mbist_mode) begin
            case (state)
                IDLE: begin
                    if (start) begin
                        state <= MARCH_C_W0;
                        current_memory <= 0;
                        current_addr <= 0;
                        error_count <= 0;
                        done <= 0;
                        fail <= 0;
                    end
                end
                
                MARCH_C_W0: begin
                    // 向所有地址写0
                    mem_en[current_memory] <= 1;
                    mem_we[current_memory] <= 1;
                    mem_addr <= current_addr;
                    mem_wdata <= {DATA_WIDTH{1'b0}};
                    
                    if (current_addr == {ADDR_WIDTH{1'b1}}) begin
                        if (current_memory == NUM_MEMORIES - 1) begin
                            state <= MARCH_C_R0W1;
                            current_memory <= 0;
                            current_addr <= 0;
                        end else begin
                            current_memory <= current_memory + 1;
                            current_addr <= 0;
                        end
                    end else begin
                        current_addr <= current_addr + 1;
                    end
                end
                
                MARCH_C_R0W1: begin
                    // 读0写1，地址递增
                    if (mem_we[current_memory]) begin
                        // 写周期
                        mem_wdata <= {DATA_WIDTH{1'b1}};
                    end else begin
                        // 读周期
                        mem_we[current_memory] <= 0;
                        expected_data <= {DATA_WIDTH{1'b0}};
                        
                        if (mem_rdata[current_memory] !== expected_data) begin
                            error_count <= error_count + 1;
                            failing_memory <= current_memory;
                            failing_addr <= current_addr;
                        end
                        
                        // 准备写1
                        mem_we[current_memory] <= 1;
                    end
                    
                    // 地址和内存推进逻辑...
                end
                
                // 其他测试模式实现...
                
                REPORT: begin
                    done <= 1;
                    fail <= (error_count > 0);
                    state <= IDLE;
                end
            endcase
        end
    end
endmodule

# DFT插入脚本
# dft_insertion.tcl

# 设置DFT配置
set_dft_configuration -scan_style muxed_scan
set_scan_configuration -chain_count 16
set_scan_configuration -clock_mixing mix_edges

# 定义测试模式
define_test_mode functional -usage scan
define_test_mode mbist -usage mbist_mode

# 扫描链插入
set_scan_path chain1 -view spec -scan_data_in scan_in_1 -scan_data_out scan_out_1
set_scan_path chain2 -view spec -scan_data_in scan_in_2 -scan_data_out scan_out_2
# ... 更多扫描链

# 插入测试结构
insert_dft

# MBIST插入
insert_mbist -memory_instances {sram_*} -algorithm march_c

# 测试点插入
set_test_point_configuration -control_points 100 -observe_points 200
insert_test_points -random

# 生成测试协议
write_test_protocol -output test_protocol.spf

# ATPG向量生成
set_atpg_options -capture_cycles 4 -patterns 10000
run_atpg -auto

# 故障覆盖率报告
report_dft -scan > reports/dft_scan.rpt
report_dft -test_coverage > reports/test_coverage.rpt
write_test -format stil -output patterns/npu_test.stil
            </div>

            <div class="exercise">
                <h4>练习 5：后端优化挑战</h4>
                <p>针对以下后端实现挑战，提出解决方案：</p>
                <ol>
                    <li>在16nm工艺下，如何优化NPU的功耗密度，避免热点？</li>
                    <li>设计一个时钟域交叉(CDC)验证方案</li>
                    <li>实现一个针对NPU特点的自定义单元库</li>
                </ol>
                
                <button class="toggle-answer">显示答案</button>
                <div class="answer">
                    <div class="code-block">
// 热点缓解设计
module ThermalManagement (
    input wire clk,
    input wire rst_n,
    
    // 温度传感器输入
    input wire [7:0] temp_sensors [15:0],
    
    // 功耗控制输出
    output reg [3:0] cluster_throttle,
    output reg [2:0] voltage_adjust,
    output reg [2:0] frequency_adjust,
    
    // 任务迁移控制
    output reg task_migration_req,
    output reg [3:0] migration_src_cluster,
    output reg [3:0] migration_dst_cluster
);
    
    // 温度阈值定义
    localparam TEMP_NORMAL = 70;    // 70°C
    localparam TEMP_WARNING = 85;   // 85°C
    localparam TEMP_CRITICAL = 95;  // 95°C
    localparam TEMP_SHUTDOWN = 105; // 105°C
    
    // 热点检测
    reg [3:0] hotspot_cluster;
    reg [7:0] max_temp;
    reg [7:0] avg_temp;
    
    always @(*) begin
        // 找出最热的簇
        max_temp = 0;
        hotspot_cluster = 0;
        avg_temp = 0;
        
        for (int i = 0; i < 16; i++) begin
            avg_temp = avg_temp + temp_sensors[i];
            if (temp_sensors[i] > max_temp) begin
                max_temp = temp_sensors[i];
                hotspot_cluster = i[3:0];
            end
        end
        avg_temp = avg_temp >> 4; // 除以16
    end
    
    // 热管理状态机
    typedef enum logic [2:0] {
        THERMAL_IDLE,
        THERMAL_MONITOR,
        THERMAL_THROTTLE,
        THERMAL_MIGRATE,
        THERMAL_EMERGENCY
    } thermal_state_t;
    
    thermal_state_t thermal_state;
    
    // 功耗密度均衡算法
    reg [7:0] power_density_map [15:0];
    reg [3:0] coolest_cluster;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            thermal_state <= THERMAL_IDLE;
            cluster_throttle <= 4'b0000;
            voltage_adjust <= 3'b100;  // 标称电压
            frequency_adjust <= 3'b100; // 标称频率
            task_migration_req <= 0;
        end else begin
            case (thermal_state)
                THERMAL_IDLE: begin
                    thermal_state <= THERMAL_MONITOR;
                end
                
                THERMAL_MONITOR: begin
                    if (max_temp > TEMP_SHUTDOWN) begin
                        thermal_state <= THERMAL_EMERGENCY;
                    end else if (max_temp > TEMP_CRITICAL) begin
                        thermal_state <= THERMAL_THROTTLE;
                    end else if (max_temp > TEMP_WARNING) begin
                        // 检查是否需要任务迁移
                        if (find_coolest_cluster() < TEMP_NORMAL) begin
                            thermal_state <= THERMAL_MIGRATE;
                        end else begin
                            thermal_state <= THERMAL_THROTTLE;
                        end
                    end
                end
                
                THERMAL_THROTTLE: begin
                    // 降低热点簇的性能
                    cluster_throttle[hotspot_cluster[1:0]] <= 1;
                    
                    // 全局降频降压
                    if (voltage_adjust > 3'b001) begin
                        voltage_adjust <= voltage_adjust - 1;
                        frequency_adjust <= frequency_adjust - 1;
                    end
                    
                    thermal_state <= THERMAL_MONITOR;
                end
                
                THERMAL_MIGRATE: begin
                    // 请求任务迁移
                    task_migration_req <= 1;
                    migration_src_cluster <= hotspot_cluster;
                    migration_dst_cluster <= coolest_cluster;
                    
                    if (task_migration_ack) begin
                        task_migration_req <= 0;
                        thermal_state <= THERMAL_MONITOR;
                    end
                end
                
                THERMAL_EMERGENCY: begin
                    // 紧急关闭热点簇
                    cluster_throttle <= 4'b1111;
                    voltage_adjust <= 3'b001;  // 最低电压
                    frequency_adjust <= 3'b001; // 最低频率
                    
                    if (max_temp < TEMP_CRITICAL) begin
                        thermal_state <= THERMAL_MONITOR;
                    end
                end
            endcase
        end
    end
    
    // 功耗密度计算
    function [3:0] find_coolest_cluster;
        reg [7:0] min_temp;
        reg [3:0] coolest_idx;
        begin
            min_temp = 8'hFF;
            coolest_idx = 0;
            
            for (int i = 0; i < 16; i++) begin
                if (temp_sensors[i] < min_temp && !cluster_throttle[i[1:0]]) begin
                    min_temp = temp_sensors[i];
                    coolest_idx = i[3:0];
                end
            end
            
            find_coolest_cluster = coolest_idx;
        end
    endfunction
endmodule

// CDC验证环境
module CDCVerification (
    // 源时钟域
    input wire clk_src,
    input wire rst_src_n,
    input wire [31:0] data_src,
    input wire valid_src,
    output wire ready_src,
    
    // 目标时钟域
    input wire clk_dst,
    input wire rst_dst_n,
    output wire [31:0] data_dst,
    output wire valid_dst,
    input wire ready_dst
);
    
    // 格雷码同步器
    GrayCodeSync #(
        .WIDTH(32)
    ) gray_sync (
        .clk_src(clk_src),
        .rst_src_n(rst_src_n),
        .data_src(data_src),
        .clk_dst(clk_dst),
        .rst_dst_n(rst_dst_n),
        .data_dst(data_gray_sync)
    );
    
    // 双触发器同步器
    reg valid_sync_1, valid_sync_2;
    always @(posedge clk_dst) begin
        if (!rst_dst_n) begin
            valid_sync_1 <= 0;
            valid_sync_2 <= 0;
        end else begin
            valid_sync_1 <= valid_src;
            valid_sync_2 <= valid_sync_1;
        end
    end
    
    // 异步FIFO
    AsyncFIFO #(
        .DATA_WIDTH(32),
        .ADDR_WIDTH(4)
    ) async_fifo (
        .wr_clk(clk_src),
        .wr_rst_n(rst_src_n),
        .wr_data(data_src),
        .wr_en(valid_src),
        .wr_full(fifo_full),
        
        .rd_clk(clk_dst),
        .rd_rst_n(rst_dst_n),
        .rd_data(data_dst),
        .rd_en(ready_dst),
        .rd_empty(fifo_empty)
    );
    
    assign ready_src = !fifo_full;
    assign valid_dst = !fifo_empty;
    
    // CDC协议检查器
    // synthesis translate_off
    property cdc_handshake_check;
        @(posedge clk_src) disable iff (!rst_src_n)
        valid_src && !ready_src |=> valid_src;
    endproperty
    
    assert property(cdc_handshake_check) else
        $error("CDC: Source dropped valid during backpressure");
    
    property cdc_data_stability;
        @(posedge clk_src) disable iff (!rst_src_n)
        valid_src && !ready_src |=> $stable(data_src);
    endproperty
    
    assert property(cdc_data_stability) else
        $error("CDC: Data changed while valid was high");
    // synthesis translate_on
endmodule

// NPU专用标准单元库
module NPUCustomCells;
    
    // 高性能8位乘法器单元
    module MAC8x8_HP (
        input wire [7:0] a,
        input wire [7:0] b,
        input wire [15:0] c,
        output wire [15:0] result
    );
        // 优化的Wallace树乘法器
        wire [15:0] partial_products [7:0];
        wire [15:0] mult_result;
        
        // Booth编码减少部分积
        BoothEncoder booth_enc (
            .multiplicand(a),
            .multiplier(b),
            .partial_products(partial_products)
        );
        
        // Wallace树归约
        WallaceTree wallace (
            .partial_products(partial_products),
            .product(mult_result)
        );
        
        // 最终加法器（Kogge-Stone）
        KoggeStoneAdder #(16) final_adder (
            .a(mult_result),
            .b(c),
            .sum(result)
        );
    endmodule
    
    // 低功耗SRAM位单元
    module SRAM_BitCell_LP (
        input wire wl,      // 字线
        input wire bl,      // 位线
        input wire blb,     // 位线反
        inout wire q,       // 存储节点
        inout wire qb       // 存储节点反
    );
        // 6T SRAM单元，优化漏电
        tranif1 pass1 (q, bl, wl);
        tranif1 pass2 (qb, blb, wl);
        
        // 交叉耦合反相器，使用高阈值晶体管
        pmos #(1) p1 (q, vdd, qb);
        nmos #(1) n1 (q, gnd, qb);
        pmos #(1) p2 (qb, vdd, q);
        nmos #(1) n2 (qb, gnd, q);
    endmodule
    
    // 时钟门控单元
    module ClockGate_NPU (
        input wire clk,
        input wire enable,
        input wire scan_enable,
        output wire gated_clk
    );
        reg latch_out;
        
        // 低电平锁存器
        always @(*) begin
            if (!clk)
                latch_out <= enable || scan_enable;
        end
        
        // AND门输出
        assign gated_clk = clk && latch_out;
        
        // 保持时间检查
        // synthesis translate_off
        always @(posedge clk) begin
            assert($stable(enable)) else
                $error("Clock gate enable changed during high phase");
        end
        // synthesis translate_on
    endmodule
    
    // 优化的低延迟互连单元 - Verilog版本
    module NPU_Interconnect_Cell #(
        parameter DATA_WIDTH = 8,
        parameter SEL_WIDTH = 4,
        parameter PIPELINE_STAGES = 2
    )(
        input wire clk,
        input wire rst_n,
        input wire [DATA_WIDTH-1:0] data_in,
        input wire [SEL_WIDTH-1:0] sel,
        input wire valid_in,
        output reg [DATA_WIDTH-1:0] data_out,
        output reg valid_out
    );
        // 流水线寄存器
        reg [DATA_WIDTH-1:0] data_reg [PIPELINE_STAGES-1:0];
        reg [SEL_WIDTH-1:0] sel_reg [PIPELINE_STAGES-1:0];
        reg valid_reg [PIPELINE_STAGES-1:0];
        
        // 中间结果寄存器
        reg [DATA_WIDTH-1:0] rotated_data;
        reg [DATA_WIDTH-1:0] mux_result;
        
        // 第一级流水线：输入寄存
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                data_reg[0] <= {DATA_WIDTH{1'b0}};
                sel_reg[0] <= {SEL_WIDTH{1'b0}};
                valid_reg[0] <= 1'b0;
            end else begin
                data_reg[0] <= data_in;
                sel_reg[0] <= sel;
                valid_reg[0] <= valid_in;
            end
        end
        
        // 第二级流水线：部分选择逻辑
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                data_reg[1] <= {DATA_WIDTH{1'b0}};
                sel_reg[1] <= {SEL_WIDTH{1'b0}};
                valid_reg[1] <= 1'b0;
                rotated_data <= {DATA_WIDTH{1'b0}};
            end else if (valid_reg[0]) begin
                data_reg[1] <= data_reg[0];
                sel_reg[1] <= sel_reg[0];
                valid_reg[1] <= valid_reg[0];
                
                // 使用二级MUX树优化时序
                case (sel_reg[0][1:0])
                    2'b00: rotated_data <= data_reg[0];
                    2'b01: rotated_data <= {data_reg[0][DATA_WIDTH-2:0], data_reg[0][DATA_WIDTH-1]};
                    2'b10: rotated_data <= {data_reg[0][DATA_WIDTH-3:0], data_reg[0][DATA_WIDTH-1:DATA_WIDTH-2]};
                    2'b11: rotated_data <= {data_reg[0][DATA_WIDTH-4:0], data_reg[0][DATA_WIDTH-1:DATA_WIDTH-3]};
                endcase
            end else begin
                valid_reg[1] <= 1'b0;
            end
        end
        
        // 第三级流水线：完成选择
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                mux_result <= {DATA_WIDTH{1'b0}};
                valid_out <= 1'b0;
            end else if (valid_reg[1]) begin
                // 第二级MUX
                case (sel_reg[1][3:2])
                    2'b00: mux_result <= rotated_data;
                    2'b01: mux_result <= {rotated_data[DATA_WIDTH-5:0], rotated_data[DATA_WIDTH-1:DATA_WIDTH-4]};
                    2'b10: mux_result <= {rotated_data[DATA_WIDTH-6:0], rotated_data[DATA_WIDTH-1:DATA_WIDTH-5]};
                    2'b11: mux_result <= {rotated_data[DATA_WIDTH-7:0], rotated_data[DATA_WIDTH-1:DATA_WIDTH-6]};
                endcase
                valid_out <= valid_reg[1];
            end else begin
                valid_out <= 1'b0;
            end
        end
        
        // 输出寄存器
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                data_out <= {DATA_WIDTH{1'b0}};
            end else begin
                data_out <= mux_result;
            end
        end
        
    endmodule
endmodule
                    </div>
                    
                    <div class="code-block">
// Chisel版本对比：
import chisel3._
import chisel3.util._

class NPUInterconnectCell(dataWidth: Int = 8,
                         selWidth: Int = 4,
                         pipelineStages: Int = 2) extends Module {
  val io = IO(new Bundle {
    val dataIn = Input(UInt(dataWidth.W))
    val sel = Input(UInt(selWidth.W))
    val validIn = Input(Bool())
    val dataOut = Output(UInt(dataWidth.W))
    val validOut = Output(Bool())
  })
  
  // 流水线寄存器
  val dataReg = Reg(Vec(pipelineStages, UInt(dataWidth.W)))
  val selReg = Reg(Vec(pipelineStages, UInt(selWidth.W)))
  val validReg = RegInit(VecInit(Seq.fill(pipelineStages)(false.B)))
  
  // 第一级：输入寄存
  dataReg(0) := io.dataIn
  selReg(0) := io.sel
  validReg(0) := io.validIn
  
  // 第二级：部分旋转
  val rotatedData = RegInit(0.U(dataWidth.W))
  
  when(validReg(0)) {
    dataReg(1) := dataReg(0)
    selReg(1) := selReg(0)
    validReg(1) := validReg(0)
    
    // 一级MUX
    rotatedData := MuxCase(dataReg(0), Seq(
      (selReg(0)(1, 0) === 0.U) -> dataReg(0),
      (selReg(0)(1, 0) === 1.U) -> Cat(dataReg(0)(dataWidth-2, 0), dataReg(0)(dataWidth-1)),
      (selReg(0)(1, 0) === 2.U) -> Cat(dataReg(0)(dataWidth-3, 0), dataReg(0)(dataWidth-1, dataWidth-2)),
      (selReg(0)(1, 0) === 3.U) -> Cat(dataReg(0)(dataWidth-4, 0), dataReg(0)(dataWidth-1, dataWidth-3))
    ))
  }.otherwise {
    validReg(1) := false.B
  }
  
  // 第三级：完成选择
  val muxResult = RegInit(0.U(dataWidth.W))
  
  when(validReg(1)) {
    // 二级MUX
    muxResult := MuxCase(rotatedData, Seq(
      (selReg(1)(3, 2) === 0.U) -> rotatedData,
      (selReg(1)(3, 2) === 1.U) -> Cat(rotatedData(dataWidth-5, 0), rotatedData(dataWidth-1, dataWidth-4)),
      (selReg(1)(3, 2) === 2.U) -> Cat(rotatedData(dataWidth-6, 0), rotatedData(dataWidth-1, dataWidth-5)),
      (selReg(1)(3, 2) === 3.U) -> Cat(rotatedData(dataWidth-7, 0), rotatedData(dataWidth-1, dataWidth-6))
    ))
  }
  
  io.dataOut := RegNext(muxResult)
  io.validOut := RegNext(validReg(1))
}
                    </div>
                    <p><strong>解析：</strong></p>
                    <ul>
                        <li>热管理模块通过温度传感器监控各簇温度，支持降频、任务迁移等策略</li>
                        <li>CDC验证包含格雷码同步、异步FIFO和协议检查断言</li>
                        <li>自定义单元库包含优化的MAC单元、低功耗SRAM、时钟门控等</li>
                        <li>采用Wallace树和Kogge-Stone加法器优化关键路径</li>
                        <li>通过高阈值晶体管和时钟门控降低静态功耗</li>
                    </ul>
                </div>
            </div>

            <h3>综合项目练习</h3>
            
            <div class="exercise">
                <h4>项目：完整NPU设计实现</h4>
                <p>基于本章所学内容，完成一个面向边缘AI的NPU完整设计，要求：</p>
                <ol>
                    <li>支持ResNet-50和BERT-Base模型的高效推理</li>
                    <li>峰值算力8 TOPS，功耗不超过5W</li>
                    <li>支持INT8/INT4量化和稀疏计算</li>
                    <li>包含完整的验证环境和后端实现</li>
                    <li>达到90%以上的测试覆盖率</li>
                </ol>
                
                <p>项目交付物：</p>
                <ul>
                    <li>架构设计文档</li>
                    <li>RTL代码（Verilog/SystemVerilog）</li>
                    <li>UVM验证环境</li>
                    <li>综合脚本和时序报告</li>
                    <li>物理设计数据（DEF/GDS）</li>
                    <li>功耗和性能分析报告</li>
                </ul>
                
                <button class="toggle-answer">显示答案</button>
                <div class="answer">
                    <p><strong>项目实施指南：</strong></p>
                    
                    <h5>1. 架构设计阶段（第1-2周）</h5>
                    <div class="code-block">
// 顶层架构参数定义
module EdgeAI_NPU_Config;
    // 系统配置
    parameter NUM_CLUSTERS = 4;
    parameter MACS_PER_CLUSTER = 512;  // 总计2048 MACs
    parameter SYSTOLIC_ARRAY_SIZE = 16;  // 16x16 systolic array per cluster
    
    // 存储层次
    parameter L1_BUFFER_KB = 64;      // 每个cluster的L1缓存
    parameter L2_BUFFER_MB = 4;       // 共享L2缓存
    parameter DRAM_BANDWIDTH_GB = 32; // 外部内存带宽
    
    // 数据精度支持
    parameter SUPPORT_INT8 = 1;
    parameter SUPPORT_INT4 = 1;
    parameter SUPPORT_MIXED_PRECISION = 1;
    
    // 稀疏计算
    parameter SPARSITY_SUPPORT = 1;
    parameter MIN_SPARSITY_GRANULARITY = 4; // 4x4块稀疏
    
    // 功耗目标
    parameter TARGET_FREQ_MHZ = 1000;
    parameter TARGET_POWER_W = 5.0;
endmodule

// 性能建模框架
class PerformanceModel {
    // ResNet-50性能估算
    float estimate_resnet50_fps() {
        float total_ops = 3.8e9;  // ResNet-50 FLOPs
        float mac_efficiency = 0.85;  // 考虑数据传输开销
        float sparsity_speedup = 1.3; // 30%稀疏度带来的加速
        
        float peak_ops = NUM_CLUSTERS * MACS_PER_CLUSTER * 2 * TARGET_FREQ_MHZ * 1e6;
        float effective_ops = peak_ops * mac_efficiency * sparsity_speedup;
        
        return effective_ops / total_ops;
    }
    
    // BERT-Base性能估算
    float estimate_bert_latency(int seq_length) {
        float attention_ops = 12 * seq_length * seq_length * 768 * 4;
        float ffn_ops = 12 * seq_length * 768 * 3072 * 2;
        float total_ops = attention_ops + ffn_ops;
        
        // 考虑内存带宽限制
        float compute_time = total_ops / (8e12 * 0.7); // 70%利用率
        float memory_time = estimate_memory_bound_time();
        
        return max(compute_time, memory_time);
    }
}
</div>
                    
                    <h5>2. RTL设计实现（第3-6周）</h5>
                    <div class="code-block">
// 计算簇顶层设计
module ComputeCluster #(
    parameter CLUSTER_ID = 0,
    parameter NUM_PES = 256,
    parameter ARRAY_SIZE = 16,
    parameter WEIGHT_BUFFER_KB = 32,
    parameter ACTIVATION_BUFFER_KB = 32
)(
    input wire clk,
    input wire rst_n,
    
    // NoC接口
    input wire [511:0] noc_data_in,
    input wire noc_valid_in,
    output wire noc_ready_out,
    
    output wire [511:0] noc_data_out,
    output wire noc_valid_out,
    input wire noc_ready_in,
    
    // 控制接口
    input wire [31:0] config_data,
    input wire config_valid,
    input wire start_compute,
    output wire compute_done,
    
    // 性能监控
    output wire [63:0] perf_counters [7:0]
);
    
    // 内部模块实例化
    // Weight Stationary Systolic Array
    SystolicArray_WS #(
        .ARRAY_SIZE(ARRAY_SIZE),
        .DATA_WIDTH(8),
        .SUPPORT_INT4(1)
    ) systolic_array (
        .clk(clk),
        .rst_n(rst_n),
        .weights(weight_data),
        .activations(activation_data),
        .partial_sums_in(ps_in),
        .partial_sums_out(ps_out),
        .config(array_config),
        .compute_enable(array_enable)
    );
    
    // 稀疏计算加速器
    SparseAccelerator #(
        .NUM_ENGINES(16),
        .BLOCK_SIZE(4)
    ) sparse_acc (
        .clk(clk),
        .rst_n(rst_n),
        .sparse_weights(sparse_weight_data),
        .sparse_indices(sparse_indices),
        .dense_activations(activation_data),
        .results(sparse_results),
        .sparse_enable(sparse_mode)
    );
    
    // 本地存储管理
    LocalMemorySystem #(
        .WEIGHT_BUFFER_SIZE(WEIGHT_BUFFER_KB * 1024),
        .ACTIVATION_BUFFER_SIZE(ACTIVATION_BUFFER_KB * 1024),
        .NUM_BANKS(16)
    ) local_mem (
        .clk(clk),
        .rst_n(rst_n),
        .weight_addr(weight_addr),
        .weight_data(weight_data),
        .weight_we(weight_we),
        .activation_addr(activation_addr),
        .activation_data(activation_data),
        .activation_we(activation_we)
    );
    
    // DMA控制器
    DMAController dma_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .noc_interface(noc_if),
        .local_mem_interface(mem_if),
        .transfer_config(dma_config),
        .start_transfer(dma_start),
        .transfer_done(dma_done)
    );
    
    // 流水线控制器
    PipelineController pipeline_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .layer_config(layer_config),
        .start_layer(start_compute),
        .layer_done(compute_done),
        .array_control(array_ctrl),
        .memory_control(mem_ctrl),
        .dma_control(dma_ctrl)
    );
endmodule
</div>
                    
                    <h5>3. 验证环境开发（第4-7周，与RTL并行）</h5>
                    <div class="code-block">
// 增强的UVM验证环境
class npu_test_base extends uvm_test;
    `uvm_component_utils(npu_test_base)
    
    npu_env env;
    npu_config cfg;
    
    // 测试场景配置
    rand int num_layers;
    rand layer_config_t layer_configs[];
    rand bit enable_sparsity;
    rand bit enable_mixed_precision;
    
    constraint test_constraints {
        num_layers inside {[1:50]};  // ResNet-50级别
        layer_configs.size() == num_layers;
        foreach(layer_configs[i]) {
            layer_configs[i].layer_type inside {CONV, FC, ATTENTION};
            if (layer_configs[i].layer_type == CONV) {
                layer_configs[i].kernel_size inside {1, 3, 5, 7};
                layer_configs[i].stride inside {1, 2};
            }
        }
    }
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 创建配置
        cfg = npu_config::type_id::create("cfg");
        cfg.num_clusters = 4;
        cfg.enable_coverage = 1;
        cfg.enable_scoreboard = 1;
        cfg.enable_performance_monitor = 1;
        
        // 设置配置
        uvm_config_db#(npu_config)::set(this, "env", "cfg", cfg);
        
        // 创建环境
        env = npu_env::type_id::create("env", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        npu_sequence seq;
        
        phase.raise_objection(this);
        
        // 运行测试序列
        seq = npu_sequence::type_id::create("seq");
        seq.num_transactions = 1000;
        seq.randomize();
        seq.start(env.agent.sequencer);
        
        // 等待DUT空闲
        wait_for_idle();
        
        // 检查结果
        check_test_results();
        
        phase.drop_objection(this);
    endtask
endclass

// ResNet-50专项测试
class resnet50_test extends npu_test_base;
    `uvm_component_utils(resnet50_test)
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 配置ResNet-50层
        num_layers = 50;
        layer_configs = new[num_layers];
        
        // Conv1: 7x7, stride 2
        layer_configs[0].layer_type = CONV;
        layer_configs[0].in_channels = 3;
        layer_configs[0].out_channels = 64;
        layer_configs[0].kernel_size = 7;
        layer_configs[0].stride = 2;
        
        // 后续层配置...
    endfunction
    
    task run_phase(uvm_phase phase);
        resnet50_sequence seq;
        real start_time, end_time;
        
        phase.raise_objection(this);
        
        // 记录开始时间
        start_time = $realtime;
        
        // 运行ResNet-50推理
        seq = resnet50_sequence::type_id::create("seq");
        seq.batch_size = 1;
        seq.image_size = 224;
        seq.start(env.agent.sequencer);
        
        // 记录结束时间
        end_time = $realtime;
        
        // 性能分析
        `uvm_info("PERF", $sformatf("ResNet-50 inference time: %0.2f ms", 
                  (end_time - start_time) / 1000000), UVM_LOW)
        
        // 验证精度
        check_inference_accuracy();
        
        phase.drop_objection(this);
    endtask
endclass
</div>
                    
                    <h5>4. 综合与时序优化（第8-9周）</h5>
                    <div class="code-block">
# 增强的综合脚本 - 包含功耗优化
# power_aware_synthesis.tcl

# 读取UPF文件
read_power_intent -upf ./upf/npu_power_intent.upf

# 设置功耗优化选项
set_dynamic_optimization true
set_leakage_optimization true

# 多Vt策略
set_attribute [get_lib_cells */LVT] dont_use false
set_attribute [get_lib_cells */RVT] dont_use false  
set_attribute [get_lib_cells */HVT] dont_use false

# 设置功耗约束
set_max_total_power 5.0 W
set_max_leakage_power 0.5 W

# 关键路径约束
group_path -name CLK2Q -from [all_registers] -to [all_outputs]
group_path -name REG2REG -from [all_registers] -to [all_registers]
group_path -name IN2REG -from [all_inputs] -to [all_registers]

set_critical_range 0.1 [current_design]

# 运行综合
compile_ultra -no_autoungroup -no_boundary_optimization

# 增量优化
optimize_registers -print_critical_loop
optimize_netlist -area

# 功耗优化
optimize_power -effort high -include {leakage dynamic}

# 生成报告
report_power -hierarchy > reports/power_report.txt
report_timing -max_paths 100 -nworst 10 > reports/timing_report.txt
report_area -hierarchy > reports/area_report.txt
report_qor > reports/qor_report.txt

# 检查设计规则
check_design -summary
check_timing -include {no_clock no_input_delay}
</div>
                    
                    <h5>5. 物理设计实现（第10-12周）</h5>
                    <div class="code-block">
# 自动化物理设计流程
# auto_pnr_flow.tcl

# 定义检查点和迭代优化
proc run_pnr_with_checkpoints {} {
    global design_name
    
    # Floorplan阶段
    source scripts/floorplan.tcl
    timeDesign -prePlace -prefix ${design_name}_preplace
    
    if {[get_metric timing.setup.wns] < -0.1} {
        # Floorplan优化
        optimize_floorplan_for_timing
    }
    
    # Placement阶段
    placeDesign -concurrent_optimization
    timeDesign -preCTS -prefix ${design_name}_prects
    
    # 检查placement质量
    if {[check_placement_quality] == "FAIL"} {
        # 重新placement，调整参数
        deleteAllGlobalNets
        placeDesign -congestion_effort high -timing_driven
    }
    
    # CTS阶段
    create_ccopt_clock_tree_spec
    ccopt_design -cts
    timeDesign -postCTS -prefix ${design_name}_postcts
    
    # Route阶段
    routeDesign -globalDetail
    
    # 迭代优化
    set iteration 0
    while {[get_metric timing.setup.wns] < 0 && $iteration < 5} {
        optDesign -postRoute -setup -drv
        incr iteration
    }
    
    # 最终优化
    optDesign -postRoute -hold
    
    # 添加填充单元
    addFiller -cell {FILL1 FILL2 FILL4 FILL8} -prefix FILLER
    
    # 金属填充
    addMetalFill -layer {1 2 3 4 5 6} -minDensity 0.20 -maxDensity 0.80
}

# 功耗网格优化
proc optimize_power_grid {} {
    # 分析IR drop
    analyze_power_grid -net {VDD VSS}
    
    # 识别热点
    set hotspots [identify_ir_hotspots -threshold 50mV]
    
    foreach hotspot $hotspots {
        # 局部加强电源网格
        add_power_stripes -area $hotspot -layer M6 -width 2.0
    }
    
    # 重新分析
    analyze_power_grid -net {VDD VSS} -report power_grid_final.rpt
}
</div>
                    
                    <h5>6. 测试与部署（第13-14周）</h5>
                    <div class="code-block">
// 芯片测试程序
class NPU_TestProgram {
    // 结构测试
    void run_structural_tests() {
        // 扫描链测试
        scan_test_controller.run_atpg_patterns();
        
        // MBIST测试
        mbist_controller.test_all_memories();
        
        // 边界扫描测试
        jtag_controller.run_boundary_scan();
    }
    
    // 功能测试
    void run_functional_tests() {
        // 基本功能测试
        test_single_mac_operation();
        test_systolic_array_operation();
        test_memory_subsystem();
        test_noc_communication();
        
        // 复杂场景测试
        test_conv2d_layers();
        test_fully_connected_layers();
        test_attention_mechanism();
        
        // 边界条件测试
        test_maximum_throughput();
        test_minimum_latency();
        test_power_modes();
    }
    
    // 性能验证
    void validate_performance() {
        PerformanceResults results;
        
        // ResNet-50测试
        results.resnet50_fps = benchmark_resnet50();
        assert(results.resnet50_fps >= 30);  // 目标: 30 FPS
        
        // BERT测试
        results.bert_latency = benchmark_bert_base();
        assert(results.bert_latency <= 10);  // 目标: <10ms
        
        // 功耗测试
        results.avg_power = measure_average_power();
        assert(results.avg_power <= 5.0);  // 目标: ≤5W
        
        generate_performance_report(results);
    }
}

// 软件SDK示例
class EdgeNPU_SDK {
    // 模型部署API
    NPUModel* deploy_model(const string& model_path) {
        // 加载模型
        auto model = load_onnx_model(model_path);
        
        // 图优化
        optimize_graph(model);
        
        // 量化
        quantize_model(model, QuantizationMode::INT8);
        
        // 编译到NPU指令
        auto compiled = compile_for_npu(model);
        
        return compiled;
    }
    
    // 推理API
    Tensor inference(NPUModel* model, const Tensor& input) {
        // 分配设备内存
        auto d_input = allocate_device_memory(input.size());
        auto d_output = allocate_device_memory(model->output_size());
        
        // 数据传输
        copy_to_device(input, d_input);
        
        // 执行推理
        npu_runtime.execute(model, d_input, d_output);
        
        // 获取结果
        Tensor output;
        copy_from_device(d_output, output);
        
        return output;
    }
};
</div>
                    
                    <h5>7. 项目交付与文档（第14周）</h5>
                    <ul>
                        <li><strong>设计文档</strong>：
                            <ul>
                                <li>架构规格说明书（包含性能模型和功耗分析）</li>
                                <li>微架构设计文档（详细的模块划分和接口定义）</li>
                                <li>验证计划和覆盖率报告</li>
                                <li>PPA（功耗、性能、面积）分析报告</li>
                            </ul>
                        </li>
                        <li><strong>代码交付</strong>：
                            <ul>
                                <li>RTL源码（含详细注释）</li>
                                <li>UVM验证环境</li>
                                <li>综合和物理设计脚本</li>
                                <li>SDK和编译器</li>
                            </ul>
                        </li>
                        <li><strong>测试报告</strong>：
                            <ul>
                                <li>功能测试报告（覆盖率>95%）</li>
                                <li>性能基准测试结果</li>
                                <li>功耗测试数据</li>
                                <li>可靠性分析</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h5>关键设计决策与权衡：</h5>
                    <ol>
                        <li><strong>数据流选择</strong>：Weight Stationary在边缘场景下能最大化权重重用，减少外部内存访问</li>
                        <li><strong>精度策略</strong>：INT8为主，INT4用于非关键层，混合精度提升灵活性</li>
                        <li><strong>稀疏支持</strong>：4x4块稀疏在硬件复杂度和加速效果间取得平衡</li>
                        <li><strong>内存层次</strong>：两级缓存设计，L1靠近计算单元，L2实现跨簇共享</li>
                        <li><strong>功耗优化</strong>：多电压域、动态时钟门控、细粒度电源管理</li>
                        <li><strong>可测试性</strong>：完整的DFT设计，支持量产测试需求</li>
                    </ol>
                </div>
            </div>
        </section>
        
        <section id="conclusion">
            <h2>总结与展望</h2>
            
            <h3>NPU技术发展趋势</h3>
            <p>通过本教程的学习，我们深入了解了NPU从架构设计到芯片实现的完整流程。展望未来，NPU技术将在以下几个方向持续演进：</p>
            
            <div class="info-box">
                <h4>1. 架构创新</h4>
                <ul>
                    <li><strong>存算一体化</strong>：将计算单元与存储深度融合，突破冯·诺依曼瓶颈</li>
                    <li><strong>可重构计算</strong>：支持动态架构调整，适应不同AI工作负载</li>
                    <li><strong>近数据计算</strong>：在数据产生和存储的地方进行计算，减少数据移动</li>
                    <li><strong>量子-经典混合</strong>：结合量子计算优势，加速特定AI算法</li>
                </ul>
            </div>
            
            <div class="info-box">
                <h4>2. 工艺与封装</h4>
                <ul>
                    <li><strong>3D堆叠技术</strong>：垂直集成计算和存储，大幅提升带宽密度</li>
                    <li><strong>Chiplet生态</strong>：标准化接口推动模块化设计和快速创新</li>
                    <li><strong>先进节点</strong>：2nm及以下工艺带来的机遇与挑战</li>
                    <li><strong>新型器件</strong>：忆阻器、自旋电子器件等新型计算元件</li>
                </ul>
            </div>
            
            <div class="info-box">
                <h4>3. 软件与算法协同</h4>
                <ul>
                    <li><strong>编译器优化</strong>：更智能的图优化和硬件映射策略</li>
                    <li><strong>自动化设计</strong>：AI驱动的芯片设计和优化</li>
                    <li><strong>软硬件协同设计</strong>：算法与架构的深度融合</li>
                    <li><strong>开源生态</strong>：推动NPU技术的普及和创新</li>
                </ul>
            </div>
            
            <h3>学习资源推荐</h3>
            
            <h4>📚 推荐书籍</h4>
            <ul>
                <li>《Efficient Processing of Deep Neural Networks》- Vivienne Sze等</li>
                <li>《Computer Architecture: A Quantitative Approach》- Hennessy & Patterson</li>
                <li>《Deep Learning》- Ian Goodfellow等</li>
                <li>《CMOS VLSI Design》- Weste & Harris</li>
            </ul>
            
            <h4>📝 学术论文</h4>
            <ul>
                <li>EIE: Efficient Inference Engine on Compressed Deep Neural Network</li>
                <li>In-Datacenter Performance Analysis of a Tensor Processing Unit</li>
                <li>Eyeriss: An Energy-Efficient Reconfigurable Accelerator</li>
                <li>DaDianNao: A Machine-Learning Supercomputer</li>
            </ul>
            
            <h4>🛠 开源项目</h4>
            <ul>
                <li><strong>NVDLA</strong>：NVIDIA深度学习加速器开源项目</li>
                <li><strong>VTA</strong>：Versatile Tensor Accelerator (TVM项目)</li>
                <li><strong>Gemmini</strong>：Berkeley的开源DNN加速器生成器</li>
                <li><strong>SCALE-Sim</strong>：Systolic阵列性能模拟器</li>
            </ul>
            
            <h4>💻 在线课程</h4>
            <ul>
                <li>MIT 6.888: Hardware Architecture for Deep Learning</li>
                <li>Stanford CS217: Hardware Accelerators for Machine Learning</li>
                <li>Cornell ECE5745: Complex Digital ASIC Design</li>
                <li>ETH Zurich: Digital Design and Computer Architecture</li>
            </ul>
            
            <h4>🔧 开发工具</h4>
            <div class="code-block">
# EDA工具
- Synopsys: Design Compiler, IC Compiler II, PrimeTime
- Cadence: Genus, Innovus, Tempus
- Mentor: Calibre, Tessent

# 开源工具
- Verilator: 开源Verilog仿真器
- OpenROAD: 开源数字芯片设计流程
- Yosys: 开源综合工具
- Magic: 开源版图工具

# AI框架
- TensorFlow Lite: 边缘AI推理框架
- ONNX Runtime: 跨平台推理引擎
- Apache TVM: 深度学习编译器
- MLIR: 多级中间表示
            </div>
            
            <h3>职业发展建议</h3>
            
            <p>NPU设计是一个交叉学科领域，需要掌握多方面的知识和技能：</p>
            
            <div class="exercise">
                <h4>技能发展路线图</h4>
                <ol>
                    <li><strong>基础阶段（0-2年）</strong>
                        <ul>
                            <li>掌握数字电路设计基础</li>
                            <li>熟悉Verilog/SystemVerilog</li>
                            <li>理解计算机体系结构</li>
                            <li>学习深度学习基础知识</li>
                        </ul>
                    </li>
                    <li><strong>进阶阶段（2-5年）</strong>
                        <ul>
                            <li>深入理解NPU架构设计</li>
                            <li>掌握UVM验证方法学</li>
                            <li>参与完整芯片项目</li>
                            <li>了解后端设计流程</li>
                        </ul>
                    </li>
                    <li><strong>专家阶段（5年+）</strong>
                        <ul>
                            <li>领导架构定义和创新</li>
                            <li>优化PPA（功耗、性能、面积）</li>
                            <li>推动软硬件协同设计</li>
                            <li>参与行业标准制定</li>
                        </ul>
                    </li>
                </ol>
            </div>
            
            <h3>结语</h3>
            
            <p>NPU作为AI时代的核心基础设施，正在深刻改变着计算范式。从云端数据中心到边缘设备，从自动驾驶到智能手机，NPU无处不在。希望通过本教程的学习，你能够：</p>
            
            <ul>
                <li>建立对NPU完整的认知体系</li>
                <li>掌握NPU设计的核心技术</li>
                <li>具备独立设计NPU的能力</li>
                <li>为AI芯片创新贡献力量</li>
            </ul>
            
            <p class="highlight-box">
                记住，芯片设计既是一门科学，也是一门艺术。它需要严谨的工程思维，也需要创新的设计理念。在追求极致性能的同时，不要忘记考虑实际应用的需求。祝你在NPU设计的道路上不断进步，创造出改变世界的AI芯片！
            </p>
            
            <div class="info-box" style="text-align: center; margin-top: 40px;">
                <p><strong>感谢阅读本教程！</strong></p>
                <p>如有问题或建议，欢迎通过GitHub Issues反馈</p>
                <p>让我们一起推动AI芯片技术的发展！</p>
            </div>
        </section>
        </div>
        
        <div class="section-summary">
                <h4>本章小结</h4>
                <ul>
                    <li><strong>NPU设计是一个完整的系统工程，</strong>从需求分析到流片验证，每个环节都需要精心规划和执行</li>
                    <li><strong>需求分析决定项目方向，</strong>准确理解应用场景、性能指标、功耗约束是成功的第一步</li>
                    <li><strong>架构设计需要全局视野，</strong>计算核心、存储系统、互连网络、控制逻辑必须协同设计才能达到最优效果</li>
                    <li><strong>RTL实现考验工程能力，</strong>模块化设计、参数化配置、代码复用提高开发效率和设计质量</li>
                    <li><strong>验证策略确保设计正确性，</strong>分层验证、随机测试、形式化验证等方法相结合才能充分覆盖</li>
                    <li><strong>综合优化追求PPA平衡，</strong>时序、功耗、面积的权衡需要反复迭代才能达到最优</li>
                    <li><strong>后端实现面临物理挑战，</strong>布局规划、时钟树设计、信号完整性等问题需要丰富经验</li>
                    <li><strong>系统集成需要软硬件协同，</strong>驱动开发、编译器适配、性能调优缺一不可</li>
                    <li><strong>持续改进是长期任务，</strong>通过实际应用反馈不断优化设计，为下一代产品积累经验</li>
                    <li><strong>团队协作是项目成功的保障，</strong>架构、RTL、验证、后端、软件各团队的紧密配合至关重要</li>
                </ul>
            </div>
        </div>
        
        <div class="chapter-nav">
            <a href="chapter11.html" class="prev">上一章</a>
            
        </div>
    </div>
</body>
</html>