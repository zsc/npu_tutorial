<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬12ç« ï¼šNPUè®¾è®¡å®æˆ˜ - NPUè®¾è®¡æ•™ç¨‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .nav-bar {
            background: #34495e;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .nav-bar ul {
            list-style: none;
            display: flex;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        .nav-bar li {
            margin: 0 15px;
        }

        .nav-bar a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .nav-bar a:hover {
            background: #2c3e50;
        }

        .nav-bar .current {
            background: #2c3e50;
            font-weight: bold;
        }

        .chapter {
            background: white;
            margin: 20px 0;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chapter h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .chapter h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        .chapter h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
        }
        
        /* Language label */
        .code-block::before {
            content: attr(data-language);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            color: #95a5a6;
            text-transform: uppercase;
        }
        
        /* Syntax highlighting classes */
        .code-block .keyword { color: #e74c3c; font-weight: bold; }
        .code-block .type { color: #3498db; }
        .code-block .comment { color: #95a5a6; font-style: italic; }
        .code-block .number { color: #e67e22; }
        .code-block .string { color: #2ecc71; }
        .code-block .function { color: #3498db; }

        .exercise {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .exercise h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .question {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .answer {
            margin-top: 10px;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 5px;
            display: none;
            border-left: 4px solid #4caf50;
        }

        .answer.show {
            display: block;
        }
        
        .hint {
            margin: 10px 0;
            padding: 10px 15px;
            background: #fff8dc;
            border-left: 4px solid #ffa500;
            border-radius: 5px;
            font-size: 0.95em;
        }
        
        .hint summary {
            cursor: pointer;
            font-weight: bold;
            color: #ff8c00;
            outline: none;
        }
        
        .hint summary:hover {
            color: #ff6347;
        }
        
        .hint p {
            margin-top: 10px;
            color: #666;
        }

        .toggle-answer {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.3s;
        }

        .toggle-answer:hover {
            background: #2980b9;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .chapter-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
        }

        .chapter-nav a {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .chapter-nav a:hover {
            background: #2980b9;
        }

        .chapter-nav .prev::before {
            content: "â† ";
        }

        .chapter-nav .next::after {
            content: " â†’";
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            header {
                padding: 20px 10px;
            }
            
            header h1 {
                font-size: 1.5em;
            }
            
            .chapter {
                padding: 15px;
                margin: 10px 0;
            }
            
            .chapter h2 {
                font-size: 1.5em;
            }
            
            .chapter h3 {
                font-size: 1.2em;
            }
            
            .nav-bar ul {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .nav-bar li {
                margin: 5px;
            }
            
            .code-block {
                padding: 10px;
                font-size: 12px;
            }
            
            table {
                font-size: 14px;
            }
            
            th, td {
                padding: 8px;
            }
        }

        /* List styles for proper indentation */
        .chapter ul, .chapter ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .chapter li {
            margin-bottom: 8px;
            line-height: 1.8;
        }
        
        .chapter ul ul, .chapter ol ol, .chapter ul ol, .chapter ol ul {
            margin-left: 20px;
            margin-top: 5px;
        }
        
        .info-box ul, .warning-box ul, .answer ul {
            margin-left: 20px;
        }
        
        .info-box li, .warning-box li, .answer li {
            margin-bottom: 10px;
        }
        
        /* Keep nav-bar lists unstyled */
        .nav-bar ul {
            margin-left: 0;
        }
        
        .nav-bar li {
            margin-bottom: 0;
        }
    </style>
    <script>
        // Syntax highlighting functions
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        function highlightSyntax() {
            const codeBlocks = document.querySelectorAll('.code-block');
            
            codeBlocks.forEach(block => {
                const content = block.textContent;
                let language = 'text';
                let highlighted = content;
                
                // Auto-detect language based on content
                if (content.includes('module ') || content.includes('always @') || content.includes('wire ') || content.includes('reg ')) {
                    language = 'verilog';
                    highlighted = highlightVerilog(content);
                } else if (content.includes('import ') || content.includes('def ') || content.includes('class ')) {
                    language = 'python';
                    highlighted = highlightPython(content);
                }
                
                block.innerHTML = highlighted;
                block.classList.add(language);
                block.setAttribute('data-language', language);
            });
        }
        
        function highlightVerilog(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments with placeholders
            code = code.replace(/(\/\/.*$|\/\*[\s\S]*?\*\/)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings with placeholders
            code = code.replace(/("[^"]*")/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(module|endmodule|input|output|wire|reg|always|assign|begin|end|if|else|for|while|parameter|posedge|negedge)\b/g;
            const types = /\b(bit|logic|byte|shortint|int|longint|integer|time|real)\b/g;
            const numbers = /\b(\d+'[hbdo][\da-fA-F_]+|\d+)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(types, '<span class="type">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        function highlightPython(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments
            code = code.replace(/(#.*$)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings
            code = code.replace(/("[^"]*"|'[^']*')/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(and|as|assert|break|class|continue|def|del|elif|else|except|False|finally|for|from|global|if|import|in|is|lambda|None|not|or|pass|raise|return|True|try|while|with|yield)\b/g;
            const builtins = /\b(abs|all|any|bin|bool|dict|float|format|hex|input|int|len|list|map|max|min|open|print|range|round|set|sorted|str|sum|tuple|type|zip)\b/g;
            const numbers = /\b(\d+\.?\d*)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(builtins, '<span class="function">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        // Toggle answer visibility
        document.addEventListener('DOMContentLoaded', function() {
            highlightSyntax();
            
            const toggleButtons = document.querySelectorAll('.toggle-answer');
            toggleButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const answer = this.nextElementSibling;
                    answer.classList.toggle('show');
                    this.textContent = answer.classList.contains('show') ? 'éšè—ç­”æ¡ˆ' : 'æ˜¾ç¤ºç­”æ¡ˆ';
                });
            });
        });
    </script>
</head>
<body>
    <header>
        <h1>ç¬¬12ç« ï¼šNPUè®¾è®¡å®æˆ˜</h1>
    </header>
    
    <nav class="nav-bar">
        <ul>
            <li><a href="index.html">é¦–é¡µ</a></li>
            <li><a href="chapter1.html">ç¬¬1ç« </a></li>
            <li><a href="chapter2.html">ç¬¬2ç« </a></li>
            <li><a href="chapter3.html">ç¬¬3ç« </a></li>
            <li><a href="chapter4.html">ç¬¬4ç« </a></li>
            <li><a href="chapter5.html">ç¬¬5ç« </a></li>
            <li><a href="chapter6.html">ç¬¬6ç« </a></li>
            <li><a href="chapter7.html">ç¬¬7ç« </a></li>
            <li><a href="chapter8.html">ç¬¬8ç« </a></li>
            <li><a href="chapter9.html">ç¬¬9ç« </a></li>
            <li><a href="chapter10.html">ç¬¬10ç« </a></li>
            <li><a href="chapter11.html">ç¬¬11ç« </a></li>
            <li><a href="chapter12.html" class="current">ç¬¬12ç« </a></li>
        </ul>
    </nav>
    
    <div class="container">
        <div class="chapter">
            <h2>ç¬¬12ç« ï¼šNPUè®¾è®¡å®æˆ˜</h2>
            
            <p>æ¬¢è¿æ¥åˆ°NPUè®¾è®¡çš„ç»¼åˆå®æˆ˜ã€‚åœ¨å‰é¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å·²ç»åˆ†åˆ«æ¢è®¨äº†ç¥ç»ç½‘ç»œçš„åŸºæœ¬åŸç†ã€ç¡¬ä»¶åŠ é€Ÿçš„æ ¸å¿ƒæ€æƒ³ã€å…³é”®è®¡ç®—å•å…ƒï¼ˆå¦‚MACé˜µåˆ—ï¼‰ä»¥åŠå­˜å‚¨æ¶æ„ã€‚æœ¬ç« å°†æ‰®æ¼”ä¸€ä¸ª"æ€»è£…è½¦é—´"çš„è§’è‰²ï¼Œå¸¦é¢†è¯»è€…ä»é›¶å¼€å§‹ï¼Œç»å†ä¸€ä¸ªå®Œæ•´çš„ã€ç¬¦åˆå·¥ä¸šç•Œè®¾è®¡æµç¨‹çš„è¾¹ç¼˜è®¡ç®—NPUé¡¹ç›®ã€‚</p>
            
            <p>æˆ‘ä»¬å°†ä¸ä»…ä»…æ˜¯å±•ç¤ºæœ€ç»ˆçš„ä»£ç ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨"ä¸ºä»€ä¹ˆ"è¿™ä¹ˆè®¾è®¡ã€‚æ¯ä¸€è¡Œä»£ç ã€æ¯ä¸€ä¸ªæ¶æ„å†³ç­–èƒŒåï¼Œéƒ½æœ‰å…¶æ€§èƒ½ã€åŠŸè€—ã€é¢ç§¯ï¼ˆPPAï¼‰ä¸Šçš„æƒè¡¡ã€‚æœ¬ç« çš„ç›®æ ‡æ˜¯è®©è¯»è€…ä¸ä»…èƒ½çœ‹æ‡‚ä¸€ä¸ªNPUè®¾è®¡ï¼Œæ›´èƒ½ç†è§£å…¶èƒŒåçš„è®¾è®¡å“²å­¦å’Œå·¥ç¨‹å®è·µï¼Œä»è€Œå…·å¤‡ç‹¬ç«‹è®¾è®¡å’Œè¯„ä¼°NPUçš„èƒ½åŠ›ã€‚è®©æˆ‘ä»¬ä»é¡¹ç›®çš„ç¬¬ä¸€æ­¥â€”â€”éœ€æ±‚åˆ†æå¼€å§‹ã€‚</p>

            <h3>12.1 é¡¹ç›®éœ€æ±‚åˆ†æ</h3>
            
            <p>æ‰€æœ‰è®¾è®¡çš„æºå¤´æ˜¯éœ€æ±‚ã€‚ç¡¬ä»¶è®¾è®¡ä¸æ˜¯å‡­ç©ºåˆ›é€ ï¼Œè€Œæ˜¯ä¸ºäº†è§£å†³ç‰¹å®šé—®é¢˜ã€‚åœ¨å¼€å§‹è®¾è®¡ä¹‹å‰ï¼Œéœ€è¦æ˜ç¡®é¡¹ç›®ç›®æ ‡ã€åº”ç”¨åœºæ™¯å’Œå…³é”®æ€§èƒ½æŒ‡æ ‡ã€‚æœ¬èŠ‚å°†è¯¦ç»†åˆ†æè¾¹ç¼˜AI NPUçš„éœ€æ±‚ã€‚</p>

            <h4>12.1.1 åº”ç”¨åœºæ™¯å®šä¹‰</h4>
            
            <div class="info-box">
                <h5>ä»€ä¹ˆæ˜¯è¾¹ç¼˜AIï¼Ÿ</h5>
                <p>è¾¹ç¼˜AIæ˜¯ç›¸å¯¹äºäº‘ç«¯AIçš„æ¦‚å¿µã€‚å®ƒå°†AIè®¡ç®—èƒ½åŠ›éƒ¨ç½²åœ¨é è¿‘æ•°æ®æºçš„"è¾¹ç¼˜"è®¾å¤‡ä¸Šï¼Œå…·æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š</p>
                <ul>
                    <li><strong>ä½å»¶è¿Ÿ</strong>ï¼šæ— éœ€å°†æ•°æ®ä¼ è¾“åˆ°äº‘ç«¯ï¼Œå®æ—¶å“åº”ï¼ˆæ¯«ç§’çº§ï¼‰</li>
                    <li><strong>æ•°æ®éšç§</strong>ï¼šæ•æ„Ÿæ•°æ®æ— éœ€ç¦»å¼€æœ¬åœ°è®¾å¤‡</li>
                    <li><strong>ä½åŠŸè€—</strong>ï¼šä¸“ç”¨ç¡¬ä»¶è®¾è®¡ï¼Œèƒ½æ•ˆæ¯”è¿œè¶…é€šç”¨å¤„ç†å™¨</li>
                    <li><strong>ç½‘ç»œæ— å…³æ€§</strong>ï¼šå³ä½¿æ²¡æœ‰ç½‘ç»œè¿æ¥ä¹Ÿèƒ½æ­£å¸¸å·¥ä½œ</li>
                </ul>
            </div>
            
            <p>æˆ‘ä»¬é€‰æ‹©ä»¥ä¸‹å››ä¸ªåº”ç”¨åœºæ™¯ä½œä¸ºè®¾è®¡ç›®æ ‡ï¼Œå®ƒä»¬ä»£è¡¨äº†ä¸åŒçš„å·¥ä½œè´Ÿè½½ç±»å‹å’Œæ€§èƒ½è¦æ±‚ï¼š</p>
            
            <ul>
                <li><strong>æ™ºèƒ½æ‘„åƒå¤´</strong>ï¼š
                    <ul>
                        <li>åº”ç”¨ï¼šå®æ—¶ç›®æ ‡æ£€æµ‹ã€äººè„¸è¯†åˆ«</li>
                        <li>ç‰¹ç‚¹ï¼šå…¸å‹CNNåº”ç”¨ï¼Œå¯¹ååç‡ï¼ˆFPSï¼‰å’Œå»¶è¿Ÿè¦æ±‚é«˜</li>
                        <li>æŒ‘æˆ˜ï¼šéœ€è¦å¤„ç†é«˜åˆ†è¾¨ç‡è§†é¢‘æµï¼ˆ1080p@30fpsï¼‰</li>
                    </ul>
                </li>
                <li><strong>æ™ºèƒ½å®¶å±…ï¼ˆè¯­éŸ³å¤„ç†ï¼‰</strong>ï¼š
                    <ul>
                        <li>åº”ç”¨ï¼šè¯­éŸ³è¯†åˆ«ã€è‡ªç„¶è¯­è¨€å¤„ç†</li>
                        <li>ç‰¹ç‚¹ï¼šå¯èƒ½æ˜¯RNNæˆ–å°å‹Transformerï¼Œå¯¹å®æ—¶å“åº”å’Œä½åŠŸè€—å¾…æœºè¦æ±‚é«˜</li>
                        <li>æŒ‘æˆ˜ï¼šéœ€è¦æ”¯æŒé•¿æ—¶é—´å¾…æœºï¼Œå“åº”å»¶è¿Ÿ<200ms</li>
                    </ul>
                </li>
                <li><strong>å·¥ä¸šæ£€æµ‹</strong>ï¼š
                    <ul>
                        <li>åº”ç”¨ï¼šç¼ºé™·æ£€æµ‹ã€è´¨é‡æ§åˆ¶</li>
                        <li>ç‰¹ç‚¹ï¼šå¯¹ç²¾åº¦å’Œå¯é æ€§è¦æ±‚æé«˜ï¼Œæ¨¡å‹å¯èƒ½æ›´å¤æ‚</li>
                        <li>æŒ‘æˆ˜ï¼šéœ€è¦æ”¯æŒé«˜ç²¾åº¦æ¨ç†ï¼ˆFP16ï¼‰ï¼Œé”™è¯¯ç‡<0.1%</li>
                    </ul>
                </li>
                <li><strong>ç§»åŠ¨è®¾å¤‡</strong>ï¼š
                    <ul>
                        <li>åº”ç”¨ï¼šå›¾åƒå¢å¼ºã€AR/VRå¤„ç†</li>
                        <li>ç‰¹ç‚¹ï¼šå¯¹èƒ½æ•ˆï¼ˆç”µæ± å¯¿å‘½ï¼‰çš„è¦æ±‚æ˜¯ç¬¬ä¸€ä½çš„</li>
                        <li>æŒ‘æˆ˜ï¼šåŠŸè€—é¢„ç®—æå…¶æœ‰é™ï¼ˆ<2Wï¼‰ï¼Œéœ€è¦å¤„ç†å¤šç§æ··åˆä»»åŠ¡</li>
                    </ul>
                </li>
                <li><strong>å…·èº«æ™ºèƒ½</strong>ï¼š
                    <ul>
                        <li>åº”ç”¨ï¼šæœºå™¨äººæ„ŸçŸ¥ä¸æ§åˆ¶ã€è‡ªä¸»å¯¼èˆªã€äººæœºäº¤äº’</li>
                        <li>ç‰¹ç‚¹ï¼šéœ€è¦èåˆå¤šæ¨¡æ€æ„ŸçŸ¥ï¼ˆè§†è§‰ã€è§¦è§‰ã€åŠ›è§‰ï¼‰å’Œå®æ—¶å†³ç­–</li>
                        <li>æŒ‘æˆ˜ï¼šè¶…ä½å»¶è¿Ÿæ§åˆ¶ç¯è·¯ï¼ˆ<10msï¼‰ï¼Œå¤šä¼ æ„Ÿå™¨æ•°æ®èåˆï¼ŒåŠ¨æ€ç¯å¢ƒé€‚åº”</li>
                    </ul>
                </li>
            </ul>
            
            <p class="highlight-box">
                <strong>è®¾è®¡å¯ç¤ºï¼š</strong>è¿™äº›ä¸åŒçš„åº”ç”¨åœºæ™¯ä¼šç›´æ¥å½±å“æˆ‘ä»¬åœ¨ç¬¬2ç« å’Œç¬¬3ç« å­¦åˆ°çš„ä¸åŒç½‘ç»œæ¨¡å‹ï¼ˆå¦‚CNNã€Transformerï¼‰çš„é€‰æ‹©ï¼Œå¹¶æœ€ç»ˆå†³å®šäº†æˆ‘ä»¬åœ¨12.2èŠ‚ä¸­æ¶æ„è®¾è®¡çš„ä¾§é‡ç‚¹ã€‚ä¸€ä¸ªä¼˜ç§€çš„NPUè®¾è®¡åº”è¯¥èƒ½å¤Ÿçµæ´»åœ°é€‚åº”è¿™äº›ä¸åŒçš„å·¥ä½œè´Ÿè½½ã€‚
            </p>

            <h4>12.1.2 æ€§èƒ½éœ€æ±‚åˆ†æ</h4>
            
            <p>ä¸ºäº†å°†æ¨¡ç³Šçš„åº”ç”¨éœ€æ±‚è½¬åŒ–ä¸ºæ¸…æ™°çš„å·¥ç¨‹ç›®æ ‡ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ç³»åˆ—å¯é‡åŒ–çš„æ€§èƒ½æŒ‡æ ‡ï¼ˆKey Performance Indicators, KPIsï¼‰ã€‚è¿™å°±åƒåœ¨å»ºé€ ä¸€åº§å¤§æ¥¼å‰ï¼Œå¿…é¡»æœ‰æ˜ç¡®çš„å›¾çº¸ï¼Œæ ‡æ˜é«˜åº¦ã€æ‰¿é‡ã€é¢ç§¯ç­‰ã€‚åœ¨NPUè®¾è®¡ä¸­ï¼Œè¿™äº›æŒ‡æ ‡å°†æˆä¸ºæˆ‘ä»¬åç»­æ‰€æœ‰è®¾è®¡ã€éªŒè¯å’Œä¼˜åŒ–å·¥ä½œçš„"é»„é‡‘æ ‡å‡†"ã€‚ä¸‹é¢çš„<code>NPU_Requirements</code>ç»“æ„ä½“ï¼Œå°±æ˜¯æˆ‘ä»¬å°†è¿™äº›éœ€æ±‚ä»£ç åŒ–çš„ç¬¬ä¸€æ­¥ï¼Œå®ƒå°†ä½œä¸ºæˆ‘ä»¬è®¾è®¡å’ŒéªŒè¯çš„"åˆåŒ"ï¼ˆSpecification as Codeï¼‰ã€‚</p>
            
            <div class="code-block">
// NPUæ€§èƒ½éœ€æ±‚å®šä¹‰
typedef struct {
    // ç®—åŠ›éœ€æ±‚
    uint32_t peak_tops;        // å³°å€¼ç®—åŠ› (TOPS)
    uint32_t sustained_tops;   // æŒç»­ç®—åŠ› (TOPS)
    
    // åŠŸè€—çº¦æŸ
    uint16_t tdp_watts;        // çƒ­è®¾è®¡åŠŸè€— (W)
    uint16_t idle_mw;          // å¾…æœºåŠŸè€— (mW)
    
    // å†…å­˜éœ€æ±‚
    uint32_t sram_size_mb;     // ç‰‡ä¸ŠSRAM (MB)
    uint32_t ddr_bandwidth_gb; // DDRå¸¦å®½ (GB/s)
    
    // æ”¯æŒçš„æ¨¡å‹
    uint8_t support_cnn;       // CNNæ”¯æŒ
    uint8_t support_rnn;       // RNNæ”¯æŒ
    uint8_t support_transformer; // Transformeræ”¯æŒ
    
    // ç²¾åº¦æ”¯æŒ
    uint8_t fp32_support;      // FP32
    uint8_t fp16_support;      // FP16
    uint8_t int8_support;      // INT8
    uint8_t int4_support;      // INT4
} NPU_Requirements;

// è¾¹ç¼˜AI NPUéœ€æ±‚å®ä¾‹
NPU_Requirements edge_npu_req = {
    .peak_tops = 8,            // 8 TOPSå³°å€¼ç®—åŠ›
    .sustained_tops = 6,       // 6 TOPSæŒç»­ç®—åŠ›
    .tdp_watts = 5,            // 5W TDP
    .idle_mw = 100,            // 100mWå¾…æœº
    .sram_size_mb = 4,         // 4MBç‰‡ä¸ŠSRAM
    .ddr_bandwidth_gb = 16,    // 16GB/s DDRå¸¦å®½
    .support_cnn = 1,          // æ”¯æŒCNN
    .support_rnn = 1,          // æ”¯æŒRNN
    .support_transformer = 1,   // æ”¯æŒTransformer
    .fp32_support = 0,         // ä¸æ”¯æŒFP32
    .fp16_support = 1,         // æ”¯æŒFP16
    .int8_support = 1,         // æ”¯æŒINT8
    .int4_support = 1          // æ”¯æŒINT4
};
            </div>

            <h4>12.1.3 ç›®æ ‡æ¨¡å‹åˆ†æ</h4>
            <div class="code-block">
// ç›®æ ‡æ¨¡å‹å·¥ä½œè´Ÿè½½åˆ†æ
module WorkloadAnalyzer #(
    parameter MODEL_COUNT = 8,
    parameter LAYER_MAX = 256
)(
    input wire clk,
    input wire rst_n,
    
    // æ¨¡å‹è¾“å…¥
    input wire [7:0] model_id,
    input wire model_load,
    
    // å±‚ä¿¡æ¯è¾“å…¥
    input wire [7:0] layer_type,      // 0:CONV 1:FC 2:POOL 3:ATTN
    input wire [31:0] layer_ops,      // æ“ä½œæ•°
    input wire [31:0] layer_params,   // å‚æ•°é‡
    input wire [31:0] layer_activations, // æ¿€æ´»å€¼å¤§å°
    
    // åˆ†æè¾“å‡º
    output reg [63:0] total_ops,
    output reg [63:0] total_params,
    output reg [63:0] total_activations,
    output reg [7:0] bottleneck_layer,
    output reg [2:0] bottleneck_type,  // 0:è®¡ç®— 1:å†…å­˜ 2:å¸¦å®½
    output reg analysis_done
);
    
    // æ¨¡å‹ç»Ÿè®¡å­˜å‚¨
    reg [63:0] model_ops [MODEL_COUNT-1:0];
    reg [63:0] model_params [MODEL_COUNT-1:0];
    reg [63:0] model_acts [MODEL_COUNT-1:0];
    
    // å±‚ç»Ÿè®¡
    reg [7:0] layer_count;
    reg [31:0] layer_compute_intensity [LAYER_MAX-1:0];
    reg [31:0] layer_memory_footprint [LAYER_MAX-1:0];
    reg [31:0] layer_bandwidth_req [LAYER_MAX-1:0];
    
    // åˆ†æçŠ¶æ€æœº
    typedef enum logic [2:0] {
        IDLE,
        COLLECT,
        ANALYZE,
        REPORT
    } analyzer_state_t;
    
    analyzer_state_t state;
    
    // è®¡ç®—å¼ºåº¦åˆ†æ
    function [31:0] calc_compute_intensity;
        input [31:0] ops, params, acts;
        begin
            // è®¡ç®—å¯†åº¦ = æ“ä½œæ•° / (å‚æ•°+æ¿€æ´»å€¼)
            calc_compute_intensity = ops / ((params + acts) >> 10); // KBä¸ºå•ä½
        end
    endfunction
    
    // å¸¦å®½éœ€æ±‚åˆ†æ
    function [31:0] calc_bandwidth_req;
        input [7:0] ltype;
        input [31:0] params, acts;
        begin
            case (ltype)
                8'd0: begin // CONV
                    // å·ç§¯å±‚éœ€è¦è¯»å–æƒé‡å’Œè¾“å…¥ï¼Œå†™å…¥è¾“å‡º
                    calc_bandwidth_req = (params + acts * 2) >> 20; // MB
                end
                8'd1: begin // FC
                    // å…¨è¿æ¥å±‚å¸¦å®½å¯†é›†
                    calc_bandwidth_req = (params + acts) >> 20;
                end
                8'd3: begin // ATTN
                    // æ³¨æ„åŠ›å±‚éœ€è¦å¤§é‡ä¸­é—´ç»“æœå­˜å‚¨
                    calc_bandwidth_req = (acts * 4) >> 20; // QKV + output
                end
                default: begin
                    calc_bandwidth_req = acts >> 20;
                end
            endcase
        end
    endfunction
    
    // ä¸»çŠ¶æ€æœº
    always @(posedge clk) begin
        if (!rst_n) begin
            state <= IDLE;
            layer_count <= 0;
            analysis_done <= 0;
            total_ops <= 0;
            total_params <= 0;
            total_activations <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (model_load) begin
                        state <= COLLECT;
                        layer_count <= 0;
                        analysis_done <= 0;
                    end
                end
                
                COLLECT: begin
                    // æ”¶é›†å±‚ä¿¡æ¯
                    layer_compute_intensity[layer_count] <= 
                        calc_compute_intensity(layer_ops, layer_params, layer_activations);
                    layer_memory_footprint[layer_count] <= 
                        (layer_params + layer_activations) >> 20; // MB
                    layer_bandwidth_req[layer_count] <= 
                        calc_bandwidth_req(layer_type, layer_params, layer_activations);
                    
                    // ç´¯è®¡ç»Ÿè®¡
                    total_ops <= total_ops + layer_ops;
                    total_params <= total_params + layer_params;
                    total_activations <= total_activations + layer_activations;
                    
                    layer_count <= layer_count + 1;
                    
                    if (layer_count == LAYER_MAX - 1) begin
                        state <= ANALYZE;
                    end
                end
                
                ANALYZE: begin
                    // æ‰¾å‡ºç“¶é¢ˆå±‚
                    reg [31:0] max_compute_req, max_memory_req, max_bandwidth_req;
                    reg [7:0] compute_bottleneck, memory_bottleneck, bandwidth_bottleneck;
                    
                    max_compute_req = 0;
                    max_memory_req = 0;
                    max_bandwidth_req = 0;
                    
                    for (int i = 0; i < layer_count; i++) begin
                        // è®¡ç®—ç“¶é¢ˆ
                        if (layer_ops[i] > max_compute_req) begin
                            max_compute_req = layer_ops[i];
                            compute_bottleneck = i;
                        end
                        
                        // å†…å­˜ç“¶é¢ˆ
                        if (layer_memory_footprint[i] > max_memory_req) begin
                            max_memory_req = layer_memory_footprint[i];
                            memory_bottleneck = i;
                        end
                        
                        // å¸¦å®½ç“¶é¢ˆ
                        if (layer_bandwidth_req[i] > max_bandwidth_req) begin
                            max_bandwidth_req = layer_bandwidth_req[i];
                            bandwidth_bottleneck = i;
                        end
                    end
                    
                    // ç¡®å®šä¸»è¦ç“¶é¢ˆ
                    if (max_compute_req > max_memory_req && max_compute_req > max_bandwidth_req) begin
                        bottleneck_layer <= compute_bottleneck;
                        bottleneck_type <= 3'b000; // è®¡ç®—ç“¶é¢ˆ
                    end else if (max_memory_req > max_bandwidth_req) begin
                        bottleneck_layer <= memory_bottleneck;
                        bottleneck_type <= 3'b001; // å†…å­˜ç“¶é¢ˆ
                    end else begin
                        bottleneck_layer <= bandwidth_bottleneck;
                        bottleneck_type <= 3'b010; // å¸¦å®½ç“¶é¢ˆ
                    end
                    
                    state <= REPORT;
                end
                
                REPORT: begin
                    // ä¿å­˜åˆ†æç»“æœ
                    model_ops[model_id] <= total_ops;
                    model_params[model_id] <= total_params;
                    model_acts[model_id] <= total_activations;
                    
                    analysis_done <= 1;
                    state <= IDLE;
                end
            endcase
        end
    end
endmodule
            </div>

            <h4>12.1.4 è®¾è®¡çº¦æŸå®šä¹‰</h4>
            <div class="code-block">
// è®¾è®¡çº¦æŸå‚æ•°
module DesignConstraints;
    // å·¥è‰ºçº¦æŸ
    parameter PROCESS_NODE = 16;        // 16nmå·¥è‰º
    parameter VOLTAGE_NOMINAL = 0.8;    // 0.8Væ ‡ç§°ç”µå‹
    parameter FREQ_TARGET = 1000;       // 1GHzç›®æ ‡é¢‘ç‡
    
    // é¢ç§¯çº¦æŸ
    parameter DIE_AREA_MM2 = 25;        // 25mmÂ²èŠ¯ç‰‡é¢ç§¯
    parameter COMPUTE_AREA_PCT = 60;    // 60%ç”¨äºè®¡ç®—
    parameter SRAM_AREA_PCT = 30;       // 30%ç”¨äºSRAM
    parameter IO_AREA_PCT = 10;         // 10%ç”¨äºIO
    
    // åŠŸè€—é¢„ç®—
    parameter POWER_COMPUTE = 3.0;      // 3Wè®¡ç®—åŠŸè€—
    parameter POWER_MEMORY = 1.5;       // 1.5Wå†…å­˜åŠŸè€—
    parameter POWER_IO = 0.5;           // 0.5W IOåŠŸè€—
    
    // æ€§èƒ½ç›®æ ‡
    parameter MAC_UNITS = 2048;         // 2048ä¸ªMACå•å…ƒ
    parameter SIMD_WIDTH = 128;         // 128ä½SIMDå®½åº¦
    parameter PIPELINE_DEPTH = 8;       // 8çº§æµæ°´çº¿
    
    // å†…å­˜å±‚æ¬¡
    parameter L1_SIZE_KB = 64;          // 64KB L1ç¼“å­˜
    parameter L2_SIZE_KB = 512;         // 512KB L2ç¼“å­˜
    parameter L3_SIZE_MB = 4;           // 4MB L3ç¼“å­˜
    
    // æ¥å£è§„æ ¼
    parameter PCIE_GEN = 4;             // PCIe Gen4
    parameter PCIE_LANES = 4;           // x4é€šé“
    parameter DDR_TYPE = "LPDDR4";      // LPDDR4å†…å­˜
    parameter DDR_WIDTH = 64;           // 64ä½å®½åº¦
endmodule
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  1ï¼šéœ€æ±‚åˆ†æä¸è§„æ ¼å®šä¹‰</h4>
                <p>å‡è®¾ä½ éœ€è¦ä¸ºè‡ªåŠ¨é©¾é©¶åº”ç”¨è®¾è®¡ä¸€ä¸ªNPUï¼Œè¯¥NPUéœ€è¦å®æ—¶å¤„ç†æ¥è‡ªå¤šä¸ªæ‘„åƒå¤´çš„è§†é¢‘æµï¼Œæ‰§è¡Œç›®æ ‡æ£€æµ‹ã€è¯­ä¹‰åˆ†å‰²å’Œè·¯å¾„è§„åˆ’ã€‚è¯·ï¼š</p>
                <ol>
                    <li>å®šä¹‰å…·ä½“çš„æ€§èƒ½éœ€æ±‚ï¼ˆç®—åŠ›ã€å»¶è¿Ÿã€åŠŸè€—ï¼‰</li>
                    <li>åˆ†æä¸»è¦çš„å·¥ä½œè´Ÿè½½ç‰¹å¾</li>
                    <li>ç¡®å®šå…³é”®çš„è®¾è®¡çº¦æŸ</li>
                    <li>ç¼–å†™éœ€æ±‚è§„æ ¼æ–‡æ¡£çš„RTLç»“æ„ä½“</li>
                </ol>
                
                <details class="hint">
                    <summary>ğŸ’¡ æç¤º</summary>
                    <p>æ€è€ƒæ–¹å‘ï¼šè‡ªåŠ¨é©¾é©¶éœ€è¦å®æ—¶æ€§ï¼ˆ<100mså»¶è¿Ÿï¼‰ã€é«˜å¯é æ€§ã€åŠŸè€—å—é™ï¼ˆè½¦è½½<50Wï¼‰ã€‚å·¥ä½œè´Ÿè½½åŒ…æ‹¬CNNï¼ˆæ£€æµ‹ï¼‰ã€FCNï¼ˆåˆ†å‰²ï¼‰ã€RNNï¼ˆé¢„æµ‹ï¼‰ã€‚è€ƒè™‘å¤šæ¨¡å‹å¹¶è¡Œã€ç¡®å®šæ€§å»¶è¿Ÿã€åŠŸèƒ½å®‰å…¨ç­‰çº¦æŸã€‚</p>
                </details>
                <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                <div class="answer">
                    <div class="code-block">
// è‡ªåŠ¨é©¾é©¶NPUéœ€æ±‚å®šä¹‰
typedef struct {
    // æ€§èƒ½éœ€æ±‚
    uint32_t min_fps;          // æœ€å°å¸§ç‡è¦æ±‚
    uint32_t camera_count;     // æ‘„åƒå¤´æ•°é‡
    uint32_t resolution;       // å¤„ç†åˆ†è¾¨ç‡
    uint32_t latency_ms;       // ç«¯åˆ°ç«¯å»¶è¿Ÿ
    
    // ç®—åŠ›éœ€æ±‚
    uint32_t detection_tops;   // ç›®æ ‡æ£€æµ‹ç®—åŠ›
    uint32_t segmentation_tops; // è¯­ä¹‰åˆ†å‰²ç®—åŠ›
    uint32_t planning_tops;    // è·¯å¾„è§„åˆ’ç®—åŠ›
    
    // åŠŸè€—çº¦æŸ
    uint16_t max_power_w;      // æœ€å¤§åŠŸè€—
    uint16_t typical_power_w;  // å…¸å‹åŠŸè€—
    uint8_t thermal_grade;     // æ¸©åº¦ç­‰çº§
    
    // å¯é æ€§éœ€æ±‚
    uint8_t asil_level;        // æ±½è½¦å®‰å…¨å®Œæ•´æ€§ç­‰çº§
    uint8_t ecc_support;       // ECCæ”¯æŒ
    uint8_t redundancy;        // å†—ä½™è®¾è®¡
} AutomotiveNPU_Spec;

// å…·ä½“éœ€æ±‚å®ä¾‹
AutomotiveNPU_Spec auto_npu_spec = {
    // æ€§èƒ½éœ€æ±‚
    .min_fps = 30,             // 30 FPSæœ€å°å¸§ç‡
    .camera_count = 8,         // 8ä¸ªæ‘„åƒå¤´
    .resolution = 1920*1080,   // 1080påˆ†è¾¨ç‡
    .latency_ms = 100,         // 100msæœ€å¤§å»¶è¿Ÿ
    
    // ç®—åŠ›éœ€æ±‚ï¼ˆæ€»è®¡50 TOPSï¼‰
    .detection_tops = 20,      // 20 TOPSç”¨äºæ£€æµ‹
    .segmentation_tops = 20,   // 20 TOPSç”¨äºåˆ†å‰²
    .planning_tops = 10,       // 10 TOPSç”¨äºè§„åˆ’
    
    // åŠŸè€—çº¦æŸ
    .max_power_w = 30,         // 30Wæœ€å¤§åŠŸè€—
    .typical_power_w = 20,     // 20Wå…¸å‹åŠŸè€—
    .thermal_grade = 125,      // 125Â°Cè½¦è§„çº§
    
    // å¯é æ€§éœ€æ±‚
    .asil_level = 3,           // ASIL-Cç­‰çº§
    .ecc_support = 1,          // æ”¯æŒECC
    .redundancy = 2            // åŒæ ¸å†—ä½™
};

// å·¥ä½œè´Ÿè½½ç‰¹å¾åˆ†æ
module AutomotiveWorkloadProfile;
    // YOLOç›®æ ‡æ£€æµ‹ç‰¹å¾
    parameter YOLO_LAYERS = 53;
    parameter YOLO_GFLOPS = 65;
    parameter YOLO_PARAMS_MB = 250;
    parameter YOLO_BATCH = 8;      // 8è·¯æ‘„åƒå¤´
    
    // DeepLabV3è¯­ä¹‰åˆ†å‰²ç‰¹å¾
    parameter DEEPLAB_LAYERS = 101;
    parameter DEEPLAB_GFLOPS = 120;
    parameter DEEPLAB_PARAMS_MB = 180;
    parameter DEEPLAB_RESOLUTION = 1024;
    
    // è·¯å¾„è§„åˆ’ç½‘ç»œç‰¹å¾
    parameter PLANNING_RNN_LAYERS = 4;
    parameter PLANNING_HIDDEN_SIZE = 512;
    parameter PLANNING_SEQUENCE_LEN = 100;
    
    // å†…å­˜éœ€æ±‚è®¡ç®—
    parameter TOTAL_PARAMS_MB = YOLO_PARAMS_MB + DEEPLAB_PARAMS_MB + 50;
    parameter ACTIVATION_BUFFER_MB = 512;  // ä¸­é—´æ¿€æ´»å€¼ç¼“å­˜
    parameter TOTAL_SRAM_MB = 16;          // ç‰‡ä¸ŠSRAMéœ€æ±‚
    
    // å¸¦å®½éœ€æ±‚è®¡ç®—
    parameter PIXEL_BANDWIDTH_GB = 8 * 1920 * 1080 * 3 * 30 / 1e9; // 11.9 GB/s
    parameter WEIGHT_BANDWIDTH_GB = TOTAL_PARAMS_MB * 30 / 1000;    // 14.1 GB/s
    parameter TOTAL_BANDWIDTH_GB = PIXEL_BANDWIDTH_GB + WEIGHT_BANDWIDTH_GB; // 26 GB/s
endmodule

// è®¾è®¡çº¦æŸå®šä¹‰
module AutomotiveDesignConstraints;
    // å®‰å…¨æ€§çº¦æŸ
    parameter LOCKSTEP_CORES = 1;      // é”æ­¥æ ¸å¿ƒ
    parameter ECC_PROTECTION = 1;      // ECCä¿æŠ¤
    parameter PARITY_CHECK = 1;        // å¥‡å¶æ ¡éªŒ
    parameter BIST_SUPPORT = 1;        // å†…å»ºè‡ªæµ‹è¯•
    
    // å®æ—¶æ€§çº¦æŸ
    parameter MAX_LATENCY_CYCLES = 100_000_000; // 1GHzä¸‹100ms
    parameter DETERMINISTIC_EXEC = 1;   // ç¡®å®šæ€§æ‰§è¡Œ
    parameter PRIORITY_LEVELS = 4;      // 4çº§ä¼˜å…ˆçº§
    
    // æ¥å£çº¦æŸ
    parameter CAMERA_INTERFACES = 8;    // 8è·¯MIPI CSI-2
    parameter CAN_FD_SUPPORT = 1;       // CAN-FDæ”¯æŒ
    parameter ETHERNET_AVB = 1;         // æ±½è½¦ä»¥å¤ªç½‘
    
    // æ¸©åº¦å’Œç”µå‹èŒƒå›´
    parameter TEMP_MIN = -40;           // -40Â°C
    parameter TEMP_MAX = 125;           // +125Â°C
    parameter VDD_MIN = 0.72;           // 0.72V
    parameter VDD_MAX = 0.88;           // 0.88V
endmodule
                    </div>
                    <p><strong>è§£æï¼š</strong></p>
                    <ul>
                        <li>è‡ªåŠ¨é©¾é©¶NPUéœ€è¦å¤„ç†å¤šè·¯é«˜åˆ†è¾¨ç‡è§†é¢‘ï¼Œç®—åŠ›éœ€æ±‚è¾¾50 TOPS</li>
                        <li>å®æ—¶æ€§è¦æ±‚ä¸¥æ ¼ï¼Œç«¯åˆ°ç«¯å»¶è¿Ÿä¸è¶…è¿‡100ms</li>
                        <li>éœ€è¦æ»¡è¶³æ±½è½¦å®‰å…¨æ ‡å‡†ï¼ˆASIL-Cï¼‰ï¼ŒåŒ…å«å†—ä½™è®¾è®¡å’ŒECCä¿æŠ¤</li>
                        <li>å·¥ä½œæ¸©åº¦èŒƒå›´å®½ï¼ˆ-40Â°Cåˆ°+125Â°Cï¼‰ï¼Œéœ€è¦è½¦è§„çº§è®¾è®¡</li>
                        <li>å¸¦å®½éœ€æ±‚é«˜ï¼ˆ26 GB/sï¼‰ï¼Œéœ€è¦ä¼˜åŒ–å†…å­˜è®¿é—®æ¨¡å¼</li>
                    </ul>
                </div>
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  2ï¼šæ€§èƒ½å»ºæ¨¡ä¸é¢„æµ‹</h4>
                <p>åŸºäºç»™å®šçš„NPUè§„æ ¼ï¼Œå»ºç«‹ä¸€ä¸ªæ€§èƒ½é¢„æµ‹æ¨¡å‹ï¼Œèƒ½å¤Ÿï¼š</p>
                <ol>
                    <li>æ ¹æ®ç¡¬ä»¶é…ç½®é¢„æµ‹ç†è®ºå³°å€¼æ€§èƒ½</li>
                    <li>è€ƒè™‘å†…å­˜å¸¦å®½é™åˆ¶çš„å®é™…æ€§èƒ½</li>
                    <li>è¯„ä¼°ä¸åŒå·¥ä½œè´Ÿè½½çš„æ€§èƒ½</li>
                </ol>
                
                <details class="hint">
                    <summary>ğŸ’¡ æç¤º</summary>
                    <p>æ€è€ƒæ–¹å‘ï¼šç†è®ºå³°å€¼=MACæ•°Ã—é¢‘ç‡Ã—2ã€‚å®é™…æ€§èƒ½å—é™äºmin(è®¡ç®—æ€§èƒ½, å†…å­˜å¸¦å®½/è®¡ç®—å¼ºåº¦)ã€‚ä¸åŒå±‚çš„è®¡ç®—å¼ºåº¦ä¸åŒï¼ˆFCå±‚é«˜ï¼ŒDWå·ç§¯ä½ï¼‰ã€‚å»ºç«‹rooflineæ¨¡å‹æ¥é¢„æµ‹æ€§èƒ½ã€‚</p>
                </details>
                <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                <div class="answer">
                    <div class="code-block">
module PerformanceModel #(
    parameter MAC_UNITS = 2048,
    parameter FREQUENCY_MHZ = 1000,
    parameter SRAM_SIZE_MB = 4,
    parameter DDR_BANDWIDTH_GB = 16,
    parameter DATA_WIDTH = 8  // INT8
)(
    input wire clk,
    input wire rst_n,
    
    // å·¥ä½œè´Ÿè½½å‚æ•°
    input wire [31:0] layer_macs,        // MACæ“ä½œæ•°
    input wire [31:0] weight_size_kb,    // æƒé‡å¤§å°
    input wire [31:0] activation_size_kb, // æ¿€æ´»å€¼å¤§å°
    input wire [7:0] reuse_factor,       // æ•°æ®é‡ç”¨å› å­
    
    // æ€§èƒ½é¢„æµ‹è¾“å‡º
    output reg [31:0] compute_cycles,
    output reg [31:0] memory_cycles,
    output reg [31:0] total_cycles,
    output reg [15:0] achieved_tops,
    output reg [7:0] efficiency_percent
);
    
    // è®¡ç®—ç†è®ºå³°å€¼æ€§èƒ½
    localparam PEAK_OPS_PER_CYCLE = MAC_UNITS * 2; // 2 ops per MAC
    localparam PEAK_TOPS = PEAK_OPS_PER_CYCLE * FREQUENCY_MHZ / 1000;
    
    // å†…å­˜å¸¦å®½å‚æ•°
    localparam SRAM_BANDWIDTH_GB = SRAM_SIZE_MB * FREQUENCY_MHZ / 250; // å‡è®¾4å‘¨æœŸè®¿é—®
    localparam EFFECTIVE_DDR_BW_GB = DDR_BANDWIDTH_GB * 70 / 100; // 70%æ•ˆç‡
    
    // è®¡ç®—æ‰€éœ€å‘¨æœŸ
    always @(*) begin
        // è®¡ç®—å‘¨æœŸ = MACæ“ä½œæ•° / æ¯å‘¨æœŸMACæ•°
        compute_cycles = layer_macs / MAC_UNITS;
        
        // å†…å­˜å‘¨æœŸè®¡ç®—
        reg [31:0] sram_data_kb, ddr_data_kb;
        reg [31:0] sram_cycles, ddr_cycles;
        
        // ä¼°ç®—SRAMå¯ä»¥å®¹çº³çš„æ•°æ®
        if (weight_size_kb + activation_size_kb <= SRAM_SIZE_MB * 1024) begin
            // å…¨éƒ¨åœ¨SRAMä¸­
            sram_data_kb = weight_size_kb + activation_size_kb;
            ddr_data_kb = 0;
        end else begin
            // éƒ¨åˆ†åœ¨SRAMï¼Œéƒ¨åˆ†éœ€è¦ä»DDRè¯»å–
            sram_data_kb = SRAM_SIZE_MB * 1024;
            ddr_data_kb = (weight_size_kb + activation_size_kb - sram_data_kb) / reuse_factor;
        end
        
        // è®¡ç®—å†…å­˜è®¿é—®å‘¨æœŸ
        sram_cycles = (sram_data_kb * 1024) / (SRAM_BANDWIDTH_GB * 1000 * 1000 / FREQUENCY_MHZ);
        ddr_cycles = (ddr_data_kb * 1024) / (EFFECTIVE_DDR_BW_GB * 1000 * 1000 / FREQUENCY_MHZ);
        
        memory_cycles = sram_cycles > ddr_cycles ? sram_cycles : ddr_cycles;
        
        // æ€»å‘¨æœŸå–è®¡ç®—å’Œå†…å­˜çš„æœ€å¤§å€¼
        total_cycles = compute_cycles > memory_cycles ? compute_cycles : memory_cycles;
        
        // å®é™…è¾¾åˆ°çš„æ€§èƒ½
        achieved_tops = (layer_macs * 2 * FREQUENCY_MHZ) / (total_cycles * 1000 * 1000);
        
        // æ•ˆç‡ç™¾åˆ†æ¯”
        efficiency_percent = (achieved_tops * 100) / PEAK_TOPS;
    end
    
    // æ€§èƒ½ç“¶é¢ˆåˆ†æ
    reg [2:0] bottleneck_type; // 0:è®¡ç®— 1:SRAMå¸¦å®½ 2:DDRå¸¦å®½
    always @(*) begin
        if (compute_cycles >= memory_cycles) begin
            bottleneck_type = 3'b000; // è®¡ç®—ç“¶é¢ˆ
        end else if (sram_cycles >= ddr_cycles) begin
            bottleneck_type = 3'b001; // SRAMå¸¦å®½ç“¶é¢ˆ
        end else begin
            bottleneck_type = 3'b010; // DDRå¸¦å®½ç“¶é¢ˆ
        end
    end
    
    // ä¼˜åŒ–å»ºè®®ç”Ÿæˆ
    reg [127:0] optimization_hint;
    always @(*) begin
        case (bottleneck_type)
            3'b000: optimization_hint = "Compute bound: consider increasing MAC units";
            3'b001: optimization_hint = "SRAM BW bound: optimize data layout and reuse";
            3'b010: optimization_hint = "DDR BW bound: increase on-chip buffer size";
            default: optimization_hint = "Balanced design";
        endcase
    end
endmodule

// å¤šå±‚ç½‘ç»œæ€§èƒ½è¯„ä¼°
module NetworkPerformanceEvaluator #(
    parameter MAX_LAYERS = 256
)(
    input wire clk,
    input wire rst_n,
    
    // ç½‘ç»œè¾“å…¥
    input wire network_start,
    input wire [7:0] network_id,
    input wire [7:0] num_layers,
    
    // é€å±‚æ€§èƒ½æ•°æ®
    input wire [31:0] layer_cycles [MAX_LAYERS-1:0],
    input wire [15:0] layer_tops [MAX_LAYERS-1:0],
    
    // ç½‘ç»œçº§æ€§èƒ½è¾“å‡º
    output reg [63:0] total_inference_cycles,
    output reg [31:0] average_tops,
    output reg [7:0] min_efficiency_layer,
    output reg [15:0] inference_latency_ms,
    output reg eval_done
);
    
    // è¯„ä¼°çŠ¶æ€æœº
    reg [2:0] eval_state;
    reg [7:0] layer_idx;
    reg [63:0] cycle_accumulator;
    reg [31:0] tops_accumulator;
    reg [7:0] min_eff_layer;
    reg [15:0] min_efficiency;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            eval_state <= 0;
            eval_done <= 0;
        end else begin
            case (eval_state)
                3'b000: begin // ç©ºé—²
                    if (network_start) begin
                        eval_state <= 3'b001;
                        layer_idx <= 0;
                        cycle_accumulator <= 0;
                        tops_accumulator <= 0;
                        min_efficiency <= 16'hFFFF;
                        eval_done <= 0;
                    end
                end
                
                3'b001: begin // ç´¯åŠ å±‚ç»Ÿè®¡
                    if (layer_idx < num_layers) begin
                        cycle_accumulator <= cycle_accumulator + layer_cycles[layer_idx];
                        tops_accumulator <= tops_accumulator + layer_tops[layer_idx];
                        
                        // è·Ÿè¸ªæœ€ä½æ•ˆç‡å±‚
                        if (layer_tops[layer_idx] < min_efficiency) begin
                            min_efficiency <= layer_tops[layer_idx];
                            min_eff_layer <= layer_idx;
                        end
                        
                        layer_idx <= layer_idx + 1;
                    end else begin
                        eval_state <= 3'b010;
                    end
                end
                
                3'b010: begin // è®¡ç®—ç½‘ç»œçº§æŒ‡æ ‡
                    total_inference_cycles <= cycle_accumulator;
                    average_tops <= tops_accumulator / num_layers;
                    min_efficiency_layer <= min_eff_layer;
                    
                    // è®¡ç®—æ¨ç†å»¶è¿Ÿ (ms)
                    inference_latency_ms <= (cycle_accumulator * 1000) / (1000 * 1000 * 1000); // å‡è®¾1GHz
                    
                    eval_done <= 1;
                    eval_state <= 3'b000;
                end
            endcase
        end
    end
endmodule
                    </div>
                    <p><strong>è§£æï¼š</strong></p>
                    <ul>
                        <li>æ€§èƒ½æ¨¡å‹è€ƒè™‘äº†è®¡ç®—èƒ½åŠ›å’Œå†…å­˜å¸¦å®½ä¸¤ä¸ªä¸»è¦å› ç´ </li>
                        <li>é€šè¿‡æ¯”è¾ƒè®¡ç®—å‘¨æœŸå’Œå†…å­˜è®¿é—®å‘¨æœŸï¼Œè¯†åˆ«æ€§èƒ½ç“¶é¢ˆ</li>
                        <li>æ•°æ®é‡ç”¨å› å­åæ˜ äº†ç®—æ³•ä¼˜åŒ–å¯¹å†…å­˜è®¿é—®çš„å½±å“</li>
                        <li>ç½‘ç»œçº§è¯„ä¼°å™¨å¯ä»¥åˆ†ææ•´ä¸ªæ¨¡å‹çš„æ€§èƒ½ï¼Œæ‰¾å‡ºæ•ˆç‡æœ€ä½çš„å±‚</li>
                        <li>æ¨¡å‹è¾“å‡ºåŒ…æ‹¬å®é™…TOPSã€æ•ˆç‡ç™¾åˆ†æ¯”å’Œä¼˜åŒ–å»ºè®®</li>
                    </ul>
                </div>
            </div>

            <h3>12.2 æ¶æ„è®¾è®¡å®è·µ</h3>
            
            <p>åŸºäºéœ€æ±‚åˆ†æï¼Œæœ¬èŠ‚å°†è®¾è®¡NPUçš„æ•´ä½“æ¶æ„ï¼ŒåŒ…æ‹¬è®¡ç®—æ ¸å¿ƒã€å­˜å‚¨å±‚æ¬¡ã€äº’è¿ç½‘ç»œå’Œæ§åˆ¶ç³»ç»Ÿã€‚</p>

            <h4>12.2.1 æ•´ä½“æ¶æ„è®¾è®¡</h4>
            <div class="code-block">
// NPUé¡¶å±‚æ¶æ„å®šä¹‰
module EdgeNPU_Top #(
    parameter NUM_CLUSTERS = 4,
    parameter MACS_PER_CLUSTER = 512,
    parameter SRAM_SIZE_PER_CLUSTER_KB = 1024,
    parameter GLOBAL_BUFFER_MB = 4
)(
    input wire clk,
    input wire rst_n,
    
    // ä¸»æœºæ¥å£
    input wire pcie_clk,
    input wire [63:0] pcie_data_in,
    output wire [63:0] pcie_data_out,
    input wire pcie_valid,
    output wire pcie_ready,
    
    // DDRæ¥å£
    output wire [31:0] ddr_addr,
    inout wire [63:0] ddr_data,
    output wire ddr_wen,
    output wire ddr_ren,
    input wire ddr_ready,
    
    // çŠ¶æ€å’Œæ§åˆ¶
    output wire [3:0] npu_state,
    output wire [31:0] performance_counter,
    output wire [15:0] power_state
);
    
    // å…¨å±€æ§åˆ¶å™¨
    wire [31:0] global_pc;
    wire [127:0] global_instruction;
    wire global_inst_valid;
    
    GlobalController #(
        .INST_CACHE_SIZE_KB(64)
    ) global_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .pc(global_pc),
        .instruction(global_instruction),
        .inst_valid(global_inst_valid),
        .pcie_cmd_in(pcie_data_in),
        .pcie_cmd_valid(pcie_valid),
        .state_out(npu_state)
    );
    
    // è®¡ç®—ç°‡é˜µåˆ—
    wire [NUM_CLUSTERS-1:0] cluster_enable;
    wire [NUM_CLUSTERS-1:0] cluster_busy;
    wire [31:0] cluster_results [NUM_CLUSTERS-1:0];
    
    genvar i;
    generate
        for (i = 0; i < NUM_CLUSTERS; i = i + 1) begin : cluster_gen
            ComputeCluster #(
                .CLUSTER_ID(i),
                .NUM_MACS(MACS_PER_CLUSTER),
                .LOCAL_SRAM_KB(SRAM_SIZE_PER_CLUSTER_KB)
            ) cluster (
                .clk(clk),
                .rst_n(rst_n),
                .enable(cluster_enable[i]),
                .instruction(global_instruction),
                .inst_valid(global_inst_valid),
                .busy(cluster_busy[i]),
                .result_out(cluster_results[i]),
                .gl_buffer_read_addr(),
                .gl_buffer_read_data(),
                .gl_buffer_write_addr(),
                .gl_buffer_write_data(),
                .gl_buffer_write_en()
            );
        end
    endgenerate
    
    // å…¨å±€ç¼“å†²å™¨
    GlobalBuffer #(
        .SIZE_MB(GLOBAL_BUFFER_MB),
        .NUM_BANKS(16),
        .NUM_PORTS(NUM_CLUSTERS * 2)
    ) global_buffer (
        .clk(clk),
        .rst_n(rst_n),
        // è¿æ¥åˆ°å„ä¸ªç°‡çš„è¯»å†™ç«¯å£
    );
    
    // NoCäº’è¿ç½‘ç»œ
    NetworkOnChip #(
        .NUM_NODES(NUM_CLUSTERS + 2), // +2 for global buffer and DDR
        .FLIT_WIDTH(128),
        .VC_NUM(4)
    ) noc (
        .clk(clk),
        .rst_n(rst_n)
        // è·¯ç”±å’Œä»²è£é€»è¾‘
    );
    
    // DDRæ§åˆ¶å™¨
    DDRController #(
        .DATA_WIDTH(64),
        .ADDR_WIDTH(32),
        .BURST_LENGTH(8)
    ) ddr_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .ddr_clk(clk),
        .addr_out(ddr_addr),
        .data_io(ddr_data),
        .wen(ddr_wen),
        .ren(ddr_ren),
        .ready_in(ddr_ready)
    );
    
    // ç”µæºç®¡ç†å•å…ƒ
    PowerManagementUnit #(
        .NUM_DOMAINS(NUM_CLUSTERS + 1)
    ) pmu (
        .clk(clk),
        .rst_n(rst_n),
        .activity_level(cluster_busy),
        .power_state(power_state),
        .dvfs_enable(),
        .power_gate_ctrl()
    );
endmodule
            </div>

            <h4>12.2.2 è®¡ç®—ç°‡è®¾è®¡</h4>
            <div class="code-block">
// ä¼˜åŒ–çš„è®¡ç®—ç°‡æ¶æ„ - Verilogç‰ˆæœ¬
module ComputeCluster #(
    parameter CLUSTER_ID = 0,
    parameter NUM_MACS = 512,
    parameter LOCAL_SRAM_KB = 1024,
    parameter PE_ARRAY_DIM = 16,  // 16x16 PEé˜µåˆ—
    parameter PIPELINE_STAGES = 4
)(
    input wire clk,
    input wire rst_n,
    
    // æ§åˆ¶æ¥å£
    input wire enable,
    input wire [127:0] instruction,
    input wire inst_valid,
    output reg busy,
    output reg done,
    output reg [31:0] result_out,
    output reg result_valid,
    
    // å…¨å±€ç¼“å†²å™¨æ¥å£ - æµæ°´çº¿åŒ–
    output reg [19:0] gl_buffer_read_addr,
    output reg gl_buffer_read_req,
    input wire [255:0] gl_buffer_read_data,
    input wire gl_buffer_read_valid,
    
    output reg [19:0] gl_buffer_write_addr,
    output reg [255:0] gl_buffer_write_data,
    output reg gl_buffer_write_en,
    input wire gl_buffer_write_ack,
    
    // æœ¬åœ°SRAMæ¥å£ - æµæ°´çº¿åŒ–
    output reg [16:0] local_sram_addr,
    output reg [255:0] local_sram_write_data,
    output reg local_sram_write_en,
    output reg [2:0] local_sram_bank_sel,
    input wire [255:0] local_sram_read_data,
    input wire local_sram_read_valid
);
    
    // æŒ‡ä»¤è§£ç  - æµæ°´çº¿å¯„å­˜å™¨
    reg [127:0] instruction_reg;
    reg [7:0] opcode;
    reg [3:0] dataflow_mode;
    reg [7:0] tile_m, tile_n, tile_k;
    reg [15:0] base_addr_a, base_addr_b, base_addr_c;
    reg decode_valid;
    
    // æŒ‡ä»¤è§£ç æµæ°´çº¿
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            instruction_reg <= 128'd0;
            opcode <= 8'd0;
            dataflow_mode <= 4'd0;
            {tile_m, tile_n, tile_k} <= 24'd0;
            {base_addr_a, base_addr_b, base_addr_c} <= 48'd0;
            decode_valid <= 1'b0;
        end else begin
            if (inst_valid && enable) begin
                instruction_reg <= instruction;
                decode_valid <= 1'b1;
            end else begin
                decode_valid <= 1'b0;
            end
            
            // æµæ°´çº¿çº§åˆ«1: è§£ç åŸºæœ¬å­—æ®µ
            if (decode_valid) begin
                opcode <= instruction_reg[127:120];
                dataflow_mode <= instruction_reg[119:116];
            end
            
            // æµæ°´çº¿çº§åˆ«2: è§£ç åœ°å€å’Œç»´åº¦
            tile_m <= instruction_reg[115:108];
            tile_n <= instruction_reg[107:100];
            tile_k <= instruction_reg[99:92];
            base_addr_a <= instruction_reg[91:76];
            base_addr_b <= instruction_reg[75:60];
            base_addr_c <= instruction_reg[59:44];
        end
    end
    
    // PEé˜µåˆ—ä¿¡å·
    reg [PE_ARRAY_DIM-1:0][7:0] pe_data_in_h_reg;  // æ°´å¹³è¾“å…¥å¯„å­˜å™¨
    reg [PE_ARRAY_DIM-1:0][7:0] pe_data_in_v_reg;  // å‚ç›´è¾“å…¥å¯„å­˜å™¨
    wire [PE_ARRAY_DIM-1:0][PE_ARRAY_DIM-1:0][31:0] pe_results;
    reg pe_array_enable;
    wire pe_array_done;
    
    // æµæ°´çº¿åŒ–çš„PEé˜µåˆ—
    ProcessingElementArray_Pipelined #(
        .ARRAY_DIM(PE_ARRAY_DIM),
        .DATA_WIDTH(8),
        .ACCUM_WIDTH(32),
        .PIPELINE_DEPTH(PIPELINE_STAGES)
    ) pe_array (
        .clk(clk),
        .rst_n(rst_n),
        .enable(pe_array_enable),
        .dataflow_mode(dataflow_mode),
        .data_in_h(pe_data_in_h_reg),
        .data_in_v(pe_data_in_v_reg),
        .results_out(pe_results),
        .done(pe_array_done)
    );
    
    // æœ¬åœ°SRAMä¸æµæ°´çº¿ç¼“å†²
    reg [16:0] sram_addr_pipe [PIPELINE_STAGES-1:0];
    reg [255:0] sram_data_pipe [PIPELINE_STAGES-1:0];
    reg sram_pipe_valid [PIPELINE_STAGES-1:0];
    
    integer p;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (p = 0; p < PIPELINE_STAGES; p = p + 1) begin
                sram_addr_pipe[p] <= 17'd0;
                sram_data_pipe[p] <= 256'd0;
                sram_pipe_valid[p] <= 1'b0;
            end
        end else begin
            // åœ°å€æµæ°´çº¿
            sram_addr_pipe[0] <= local_sram_addr;
            sram_pipe_valid[0] <= local_sram_write_en;
            for (p = 1; p < PIPELINE_STAGES; p = p + 1) begin
                sram_addr_pipe[p] <= sram_addr_pipe[p-1];
                sram_pipe_valid[p] <= sram_pipe_valid[p-1];
            end
            
            // æ•°æ®æµæ°´çº¿
            if (local_sram_read_valid) begin
                sram_data_pipe[0] <= local_sram_read_data;
                for (p = 1; p < PIPELINE_STAGES; p = p + 1) begin
                    sram_data_pipe[p] <= sram_data_pipe[p-1];
                end
            end
        end
    end
    
    // æ•°æ®ç¼–æ’å™¨ - æµæ°´çº¿åŒ–
    reg [7:0] data_buffer_h [PE_ARRAY_DIM-1:0][PIPELINE_STAGES-1:0];
    reg [7:0] data_buffer_v [PE_ARRAY_DIM-1:0][PIPELINE_STAGES-1:0];
    reg data_orch_valid;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_orch_valid <= 1'b0;
            for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                for (int j = 0; j < PIPELINE_STAGES; j++) begin
                    data_buffer_h[i][j] <= 8'd0;
                    data_buffer_v[i][j] <= 8'd0;
                end
            end
        end else if (sram_pipe_valid[PIPELINE_STAGES-1]) begin
            // æ ¹æ®æ•°æ®æµæ¨¡å¼ç¼–æ’æ•°æ®
            case (dataflow_mode)
                4'b0001: begin // Weight Stationary
                    for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                        data_buffer_h[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][i*8+:8];
                        data_buffer_v[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][(i+16)*8+:8];
                    end
                end
                4'b0010: begin // Output Stationary
                    for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                        data_buffer_h[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][(i*2)*8+:8];
                        data_buffer_v[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][(i*2+1)*8+:8];
                    end
                end
                default: begin // Input Stationary
                    for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                        data_buffer_h[i][0] <= sram_data_pipe[PIPELINE_STAGES-1][i*8+:8];
                        data_buffer_v[i][0] <= 8'd0;
                    end
                end
            endcase
            data_orch_valid <= 1'b1;
        end else begin
            data_orch_valid <= 1'b0;
        end
        
        // æ•°æ®ç¼“å†²å™¨ç§»ä½
        if (data_orch_valid) begin
            for (int i = 0; i < PE_ARRAY_DIM; i++) begin
                pe_data_in_h_reg[i] <= data_buffer_h[i][0];
                pe_data_in_v_reg[i] <= data_buffer_v[i][0];
                for (int j = 1; j < PIPELINE_STAGES; j++) begin
                    data_buffer_h[i][j-1] <= data_buffer_h[i][j];
                    data_buffer_v[i][j-1] <= data_buffer_v[i][j];
                end
            end
        end
    end
    
    // ç°‡æ§åˆ¶çŠ¶æ€æœº - æµæ°´çº¿åŒ–
    reg [3:0] cluster_state, next_state;
    localparam IDLE = 4'b0000;
    localparam DECODE = 4'b0001;
    localparam FETCH_PREP = 4'b0010;
    localparam FETCH = 4'b0011;
    localparam COMPUTE_PREP = 4'b0100;
    localparam COMPUTE = 4'b0101;
    localparam WRITEBACK_PREP = 4'b0110;
    localparam WRITEBACK = 4'b0111;
    localparam DONE = 4'b1000;
    
    // è®¡æ•°å™¨å’Œæ§åˆ¶ä¿¡å·
    reg [15:0] fetch_counter;
    reg [15:0] compute_counter;
    reg [15:0] writeback_counter;
    reg fetch_complete, compute_complete, writeback_complete;
    
    // çŠ¶æ€æœºé€»è¾‘
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            cluster_state <= IDLE;
        end else begin
            cluster_state <= next_state;
        end
    end
    
    // ä¸‹ä¸€çŠ¶æ€é€»è¾‘
    always @(*) begin
        next_state = cluster_state;
        
        case (cluster_state)
            IDLE: begin
                if (enable && inst_valid) begin
                    next_state = DECODE;
                end
            end
            
            DECODE: begin
                if (decode_valid) begin
                    next_state = FETCH_PREP;
                end
            end
            
            FETCH_PREP: begin
                next_state = FETCH;
            end
            
            FETCH: begin
                if (fetch_complete) begin
                    next_state = COMPUTE_PREP;
                end
            end
            
            COMPUTE_PREP: begin
                next_state = COMPUTE;
            end
            
            COMPUTE: begin
                if (compute_complete) begin
                    next_state = WRITEBACK_PREP;
                end
            end
            
            WRITEBACK_PREP: begin
                next_state = WRITEBACK;
            end
            
            WRITEBACK: begin
                if (writeback_complete) begin
                    next_state = DONE;
                end
            end
            
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end
    
    // è¾“å‡ºé€»è¾‘å’Œæ§åˆ¶ä¿¡å·
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            busy <= 1'b0;
            done <= 1'b0;
            result_valid <= 1'b0;
            pe_array_enable <= 1'b0;
            fetch_counter <= 16'd0;
            compute_counter <= 16'd0;
            writeback_counter <= 16'd0;
            fetch_complete <= 1'b0;
            compute_complete <= 1'b0;
            writeback_complete <= 1'b0;
        end else begin
            done <= (cluster_state == DONE);
            busy <= (cluster_state != IDLE);
            
            case (cluster_state)
                FETCH_PREP: begin
                    fetch_counter <= 16'd0;
                    fetch_complete <= 1'b0;
                    gl_buffer_read_addr <= {CLUSTER_ID[3:0], base_addr_a};
                    gl_buffer_read_req <= 1'b1;
                end
                
                FETCH: begin
                    if (gl_buffer_read_valid) begin
                        local_sram_addr <= fetch_counter;
                        local_sram_write_data <= gl_buffer_read_data;
                        local_sram_write_en <= 1'b1;
                        local_sram_bank_sel <= fetch_counter[2:0];
                        fetch_counter <= fetch_counter + 1;
                        
                        if (fetch_counter >= (tile_m * tile_n + tile_n * tile_k)) begin
                            fetch_complete <= 1'b1;
                            gl_buffer_read_req <= 1'b0;
                        end
                    end else begin
                        local_sram_write_en <= 1'b0;
                    end
                end
                
                COMPUTE_PREP: begin
                    compute_counter <= 16'd0;
                    compute_complete <= 1'b0;
                    pe_array_enable <= 1'b1;
                end
                
                COMPUTE: begin
                    compute_counter <= compute_counter + 1;
                    if (pe_array_done || compute_counter >= (tile_k * PIPELINE_STAGES)) begin
                        compute_complete <= 1'b1;
                        pe_array_enable <= 1'b0;
                    end
                end
                
                WRITEBACK_PREP: begin
                    writeback_counter <= 16'd0;
                    writeback_complete <= 1'b0;
                    result_out <= 32'd0;
                end
                
                WRITEBACK: begin
                    if (writeback_counter < PE_ARRAY_DIM * PE_ARRAY_DIM) begin
                        gl_buffer_write_addr <= {CLUSTER_ID[3:0], base_addr_c} + writeback_counter;
                        gl_buffer_write_data <= {224'd0, pe_results[writeback_counter/PE_ARRAY_DIM][writeback_counter%PE_ARRAY_DIM]};
                        gl_buffer_write_en <= 1'b1;
                        
                        if (gl_buffer_write_ack) begin
                            writeback_counter <= writeback_counter + 1;
                            result_out <= result_out + pe_results[writeback_counter/PE_ARRAY_DIM][writeback_counter%PE_ARRAY_DIM];
                        end
                    end else begin
                        gl_buffer_write_en <= 1'b0;
                        writeback_complete <= 1'b1;
                        result_valid <= 1'b1;
                    end
                end
                
                default: begin
                    gl_buffer_read_req <= 1'b0;
                    gl_buffer_write_en <= 1'b0;
                    local_sram_write_en <= 1'b0;
                    result_valid <= 1'b0;
                end
            endcase
        end
    end
    
endmodule

            </div>
            
            <div class="code-block">
// Chiselç‰ˆæœ¬å¯¹æ¯”ï¼š
import chisel3._
import chisel3.util._

class ComputeCluster(clusterId: Int = 0,
                     numMacs: Int = 512,
                     localSramKB: Int = 1024,
                     peArrayDim: Int = 16) extends Module {
  val io = IO(new Bundle {
    // æ§åˆ¶æ¥å£
    val enable = Input(Bool())
    val instruction = Input(UInt(128.W))
    val instValid = Input(Bool())
    val busy = Output(Bool())
    val done = Output(Bool())
    val resultOut = Output(UInt(32.W))
    val resultValid = Output(Bool())
    
    // å…¨å±€ç¼“å†²å™¨æ¥å£
    val glBuffer = new Bundle {
      val readAddr = Output(UInt(20.W))
      val readReq = Output(Bool())
      val readData = Input(UInt(256.W))
      val readValid = Input(Bool())
      val writeAddr = Output(UInt(20.W))
      val writeData = Output(UInt(256.W))
      val writeEn = Output(Bool())
      val writeAck = Input(Bool())
    }
  })
  
  // çŠ¶æ€æœºå®šä¹‰
  val idle :: decode :: fetchPrep :: fetch :: computePrep :: compute :: writebackPrep :: writeback :: done :: Nil = Enum(9)
  val state = RegInit(idle)
  
  // æŒ‡ä»¤è§£ç å¯„å­˜å™¨
  val instructionReg = RegEnable(io.instruction, io.instValid && io.enable)
  val opcode = RegNext(instructionReg(127, 120))
  val dataflowMode = RegNext(instructionReg(119, 116))
  val tileM = RegNext(instructionReg(115, 108))
  val tileN = RegNext(instructionReg(107, 100))
  val tileK = RegNext(instructionReg(99, 92))
  val baseAddrA = RegNext(instructionReg(91, 76))
  val baseAddrB = RegNext(instructionReg(75, 60))
  val baseAddrC = RegNext(instructionReg(59, 44))
  
  // PEé˜µåˆ—å®ä¾‹åŒ–
  val peArray = Module(new ProcessingElementArrayPipelined(
    peArrayDim, 8, 32))
  
  // è®¡æ•°å™¨
  val fetchCounter = RegInit(0.U(16.W))
  val computeCounter = RegInit(0.U(16.W))
  val writebackCounter = RegInit(0.U(16.W))
  
  // å®Œæˆæ ‡å¿—
  val fetchComplete = RegInit(false.B)
  val computeComplete = RegInit(false.B)
  val writebackComplete = RegInit(false.B)
  
  // çŠ¶æ€æœºè½¬æ¢
  switch(state) {
    is(idle) {
      when(io.enable && io.instValid) {
        state := decode
      }
    }
    is(decode) {
      state := fetchPrep
    }
    is(fetchPrep) {
      fetchCounter := 0.U
      fetchComplete := false.B
      state := fetch
    }
    is(fetch) {
      when(fetchComplete) {
        state := computePrep
      }
    }
    is(computePrep) {
      computeCounter := 0.U
      computeComplete := false.B
      state := compute
    }
    is(compute) {
      when(computeComplete) {
        state := writebackPrep
      }
    }
    is(writebackPrep) {
      writebackCounter := 0.U
      writebackComplete := false.B
      state := writeback
    }
    is(writeback) {
      when(writebackComplete) {
        state := done
      }
    }
    is(done) {
      state := idle
    }
  }
  
  // Fetché€»è¾‘
  when(state === fetch) {
    io.glBuffer.readReq := true.B
    io.glBuffer.readAddr := Cat(clusterId.U(4.W), baseAddrA) + fetchCounter
    
    when(io.glBuffer.readValid) {
      fetchCounter := fetchCounter + 1.U
      when(fetchCounter >= (tileM * tileN + tileN * tileK)) {
        fetchComplete := true.B
      }
    }
  }.otherwise {
    io.glBuffer.readReq := false.B
  }
  
  // Computeé€»è¾‘
  peArray.io.enable := state === compute
  peArray.io.dataflowMode := dataflowMode
  
  when(state === compute) {
    computeCounter := computeCounter + 1.U
    when(peArray.io.done || computeCounter >= (tileK * 4.U)) {
      computeComplete := true.B
    }
  }
  
  // Writebacké€»è¾‘
  when(state === writeback) {
    io.glBuffer.writeEn := true.B
    io.glBuffer.writeAddr := Cat(clusterId.U(4.W), baseAddrC) + writebackCounter
    io.glBuffer.writeData := peArray.io.results(writebackCounter)
    
    when(io.glBuffer.writeAck) {
      writebackCounter := writebackCounter + 1.U
      when(writebackCounter >= (peArrayDim * peArrayDim).U) {
        writebackComplete := true.B
      }
    }
  }.otherwise {
    io.glBuffer.writeEn := false.B
  }
  
  // è¾“å‡º
  io.busy := state =/= idle
  io.done := state === done
  io.resultValid := state === done
  io.resultOut := RegEnable(
    peArray.io.results.reduce(_ + _),
    state === writebackPrep
  )
}
            </div>
            
            <div class="code-block">
// å¯é‡æ„PEé˜µåˆ—
module ProcessingElementArray #(
    parameter ARRAY_DIM = 16,
    parameter DATA_WIDTH = 8,
    parameter ACCUM_WIDTH = 32
)(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire [3:0] dataflow_mode,
    
    // æ•°æ®è¾“å…¥
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] data_in_h,
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] data_in_v,
    
    // ç»“æœè¾“å‡º
    output wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][ACCUM_WIDTH-1:0] results_out
);
    
    // æ•°æ®æµæ¨¡å¼
    localparam WS_MODE = 4'b0000;  // Weight Stationary
    localparam OS_MODE = 4'b0001;  // Output Stationary
    localparam IS_MODE = 4'b0010;  // Input Stationary
    localparam RS_MODE = 4'b0011;  // Row Stationary
    
    // PEé—´è¿æ¥
    wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][DATA_WIDTH-1:0] h_links;
    wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][DATA_WIDTH-1:0] v_links;
    wire [ARRAY_DIM-1:0][ARRAY_DIM-1:0][ACCUM_WIDTH-1:0] partial_sums;
    
    // ç”ŸæˆPEé˜µåˆ—
    genvar row, col;
    generate
        for (row = 0; row < ARRAY_DIM; row = row + 1) begin : pe_row
            for (col = 0; col < ARRAY_DIM; col = col + 1) begin : pe_col
                ProcessingElement #(
                    .DATA_WIDTH(DATA_WIDTH),
                    .ACCUM_WIDTH(ACCUM_WIDTH)
                ) pe (
                    .clk(clk),
                    .rst_n(rst_n),
                    .enable(enable),
                    .mode(dataflow_mode),
                    
                    // æ•°æ®è¾“å…¥
                    .data_in_h(col == 0 ? data_in_h[row] : h_links[row][col-1]),
                    .data_in_v(row == 0 ? data_in_v[col] : v_links[row-1][col]),
                    
                    // æ•°æ®è¾“å‡º
                    .data_out_h(h_links[row][col]),
                    .data_out_v(v_links[row][col]),
                    
                    // éƒ¨åˆ†å’Œ
                    .partial_sum_in(partial_sums[row][col]),
                    .result_out(results_out[row][col])
                );
            end
        end
    endgenerate
endmodule
            </div>

            <h4>12.2.3 å­˜å‚¨å±‚æ¬¡è®¾è®¡</h4>
            <div class="code-block">
// åˆ†å±‚å­˜å‚¨ç³»ç»Ÿ
module HierarchicalMemorySystem #(
    parameter L0_SIZE_KB = 2,      // PEæœ¬åœ°å¯„å­˜å™¨
    parameter L1_SIZE_KB = 64,     // ç°‡å†…å…±äº«L1
    parameter L2_SIZE_KB = 1024,   // ç°‡ç§æœ‰L2
    parameter L3_SIZE_MB = 4       // å…¨å±€å…±äº«L3
)(
    input wire clk,
    input wire rst_n,
    
    // PEè®¿é—®æ¥å£
    input wire [511:0] pe_read_req,      // 512ä¸ªPEçš„è¯»è¯·æ±‚
    input wire [511:0][15:0] pe_read_addr,
    output wire [511:0][7:0] pe_read_data,
    output wire [511:0] pe_read_valid,
    
    // DMAæ¥å£
    input wire dma_req,
    input wire [31:0] dma_src_addr,
    input wire [31:0] dma_dst_addr,
    input wire [15:0] dma_length,
    output wire dma_done,
    
    // DDRæ¥å£
    output wire [31:0] ddr_addr,
    output wire ddr_read_en,
    input wire [255:0] ddr_read_data,
    input wire ddr_read_valid
);
    
    // L0å¯„å­˜å™¨æ–‡ä»¶ï¼ˆæ¯ä¸ªPEï¼‰
    genvar pe_id;
    generate
        for (pe_id = 0; pe_id < 512; pe_id = pe_id + 1) begin : l0_gen
            RegFile #(
                .SIZE_BYTES(L0_SIZE_KB * 1024),
                .DATA_WIDTH(8)
            ) l0_rf (
                .clk(clk),
                .read_addr(pe_read_addr[pe_id][7:0]),
                .read_data(l0_data[pe_id]),
                .write_addr(l0_write_addr[pe_id]),
                .write_data(l0_write_data[pe_id]),
                .write_en(l0_write_en[pe_id])
            );
        end
    endgenerate
    
    // L1ç¼“å­˜ï¼ˆç°‡å†…å…±äº«ï¼‰
    wire [15:0] l1_req_addr [15:0];  // 16ä¸ªL1 bank
    wire [15:0] l1_req_valid;
    wire [15:0][63:0] l1_resp_data;
    wire [15:0] l1_resp_valid;
    
    genvar bank;
    generate
        for (bank = 0; bank < 16; bank = bank + 1) begin : l1_gen
            L1Cache #(
                .SIZE_KB(L1_SIZE_KB / 16),
                .LINE_SIZE(64),
                .ASSOCIATIVITY(4)
            ) l1_bank (
                .clk(clk),
                .rst_n(rst_n),
                .req_addr(l1_req_addr[bank]),
                .req_valid(l1_req_valid[bank]),
                .resp_data(l1_resp_data[bank]),
                .resp_valid(l1_resp_valid[bank]),
                .miss_addr(l1_miss_addr[bank]),
                .miss_valid(l1_miss_valid[bank])
            );
        end
    endgenerate
    
    // L1ä»²è£å™¨å’Œè·¯ç”±
    L1Arbiter #(
        .NUM_PE(512),
        .NUM_BANKS(16)
    ) l1_arbiter (
        .clk(clk),
        .rst_n(rst_n),
        .pe_requests(pe_read_req),
        .pe_addresses(pe_read_addr),
        .bank_grant(l1_req_valid),
        .bank_addresses(l1_req_addr)
    );
    
    // L2ç¼“å­˜ï¼ˆç°‡ç§æœ‰ï¼‰
    L2Cache #(
        .SIZE_KB(L2_SIZE_KB),
        .LINE_SIZE(256),
        .ASSOCIATIVITY(8),
        .NUM_BANKS(8)
    ) l2_cache (
        .clk(clk),
        .rst_n(rst_n),
        // L1 misså¤„ç†
        .l1_miss_addr(l1_miss_addr_merged),
        .l1_miss_valid(|l1_miss_valid),
        .l1_fill_data(l2_to_l1_data),
        .l1_fill_valid(l2_to_l1_valid),
        // L3æ¥å£
        .l3_req_addr(l2_to_l3_addr),
        .l3_req_valid(l2_to_l3_valid),
        .l3_resp_data(l3_to_l2_data),
        .l3_resp_valid(l3_to_l2_valid)
    );
    
    // L3å…¨å±€ç¼“å­˜
    L3GlobalBuffer #(
        .SIZE_MB(L3_SIZE_MB),
        .LINE_SIZE(512),
        .NUM_PORTS(4),  // 4ä¸ªç°‡
        .NUM_BANKS(16)
    ) l3_buffer (
        .clk(clk),
        .rst_n(rst_n),
        // ç°‡æ¥å£
        .cluster_req_addr(l2_to_l3_addr_all),
        .cluster_req_valid(l2_to_l3_valid_all),
        .cluster_resp_data(l3_to_l2_data_all),
        .cluster_resp_valid(l3_to_l2_valid_all),
        // DDRæ¥å£
        .ddr_req_addr(ddr_addr),
        .ddr_req_valid(ddr_read_en),
        .ddr_resp_data(ddr_read_data),
        .ddr_resp_valid(ddr_read_valid),
        // DMAæ¥å£
        .dma_req(dma_req),
        .dma_src_addr(dma_src_addr),
        .dma_dst_addr(dma_dst_addr),
        .dma_length(dma_length),
        .dma_done(dma_done)
    );
    
    // é¢„å–å¼•æ“
    PrefetchEngine #(
        .PREFETCH_DEGREE(4),
        .PATTERN_TABLE_SIZE(256)
    ) prefetcher (
        .clk(clk),
        .rst_n(rst_n),
        .access_addr(pe_read_addr),
        .access_valid(pe_read_req),
        .prefetch_addr(prefetch_addr),
        .prefetch_valid(prefetch_valid)
    );
endmodule

// æ™ºèƒ½ç¼“å­˜æ›¿æ¢ç­–ç•¥
module AdaptiveCacheReplacement #(
    parameter CACHE_WAYS = 8,
    parameter HISTORY_BITS = 4
)(
    input wire clk,
    input wire rst_n,
    
    // è®¿é—®ä¿¡æ¯
    input wire access_valid,
    input wire [2:0] access_way,
    input wire [1:0] access_type,  // 0:æƒé‡ 1:æ¿€æ´» 2:éƒ¨åˆ†å’Œ
    
    // æ›¿æ¢å†³ç­–
    input wire replace_req,
    output reg [2:0] victim_way,
    output reg victim_valid
);
    
    // æ¯è·¯çš„å…ƒæ•°æ®
    reg [CACHE_WAYS-1:0][HISTORY_BITS-1:0] access_history;
    reg [CACHE_WAYS-1:0][1:0] data_type;
    reg [CACHE_WAYS-1:0][15:0] reuse_counter;
    reg [CACHE_WAYS-1:0] dead_prediction;
    
    // æ›´æ–°è®¿é—®å†å²
    always @(posedge clk) begin
        if (!rst_n) begin
            access_history <= 0;
            reuse_counter <= 0;
        end else if (access_valid) begin
            // æ›´æ–°LRUä½
            access_history[access_way] <= {HISTORY_BITS{1'b1}};
            for (int i = 0; i < CACHE_WAYS; i++) begin
                if (i != access_way && access_history[i] > 0) begin
                    access_history[i] <= access_history[i] - 1;
                end
            end
            
            // æ›´æ–°é‡ç”¨è®¡æ•°
            reuse_counter[access_way] <= reuse_counter[access_way] + 1;
            data_type[access_way] <= access_type;
        end
    end
    
    // æ­»äº¡é¢„æµ‹é€»è¾‘
    always @(posedge clk) begin
        for (int i = 0; i < CACHE_WAYS; i++) begin
            // æƒé‡æ•°æ®é€šå¸¸é‡ç”¨åº¦é«˜
            if (data_type[i] == 2'b00) begin
                dead_prediction[i] <= 0;
            end
            // æ¿€æ´»å€¼é‡ç”¨åº¦å–å†³äºå±‚ç±»å‹
            else if (data_type[i] == 2'b01) begin
                dead_prediction[i] <= (reuse_counter[i] < 2);
            end
            // éƒ¨åˆ†å’Œé€šå¸¸åªä½¿ç”¨ä¸€æ¬¡
            else if (data_type[i] == 2'b10) begin
                dead_prediction[i] <= 1;
            end
        end
    end
    
    // é€‰æ‹©æ›¿æ¢ç‰ºç‰²è€…
    always @(*) begin
        victim_valid = 0;
        victim_way = 0;
        
        if (replace_req) begin
            // ä¼˜å…ˆæ›¿æ¢é¢„æµ‹ä¸ºæ­»äº¡çš„è¡Œ
            for (int i = 0; i < CACHE_WAYS; i++) begin
                if (dead_prediction[i]) begin
                    victim_way = i;
                    victim_valid = 1;
                    break;
                end
            end
            
            // å¦‚æœæ²¡æœ‰æ­»äº¡é¢„æµ‹ï¼Œä½¿ç”¨LRU
            if (!victim_valid) begin
                reg [HISTORY_BITS-1:0] min_history = {HISTORY_BITS{1'b1}};
                for (int i = 0; i < CACHE_WAYS; i++) begin
                    if (access_history[i] < min_history) begin
                        min_history = access_history[i];
                        victim_way = i;
                    end
                end
                victim_valid = 1;
            end
        end
    end
endmodule
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  3ï¼šæ¶æ„ä¼˜åŒ–è®¾è®¡</h4>
                <p>åŸºäºä¸Šè¿°NPUæ¶æ„ï¼Œè¿›è¡Œä»¥ä¸‹ä¼˜åŒ–è®¾è®¡ï¼š</p>
                <ol>
                    <li>è®¾è®¡ä¸€ä¸ªæ”¯æŒç¨€ç–è®¡ç®—çš„PEé˜µåˆ—ï¼Œèƒ½å¤Ÿè·³è¿‡é›¶å€¼è®¡ç®—</li>
                    <li>å®ç°ä¸€ä¸ªè‡ªé€‚åº”çš„NoCè·¯ç”±ç®—æ³•ï¼Œæ ¹æ®ç½‘ç»œæ‹¥å¡åŠ¨æ€è°ƒæ•´è·¯å¾„</li>
                    <li>è®¾è®¡ä¸€ä¸ªæ··åˆç²¾åº¦è®¡ç®—å•å…ƒï¼Œæ”¯æŒINT4/INT8/FP16åŠ¨æ€åˆ‡æ¢</li>
                </ol>
                
                <details class="hint">
                    <summary>ğŸ’¡ æç¤º</summary>
                    <p>æ€è€ƒæ–¹å‘ï¼š1) ç¨€ç–è®¡ç®—éœ€è¦é›¶æ£€æµ‹å’Œç´¢å¼•ç®¡ç†ï¼Œè€ƒè™‘å‹ç¼©æ ¼å¼ï¼ˆCSR/CSCï¼‰ã€‚2) è‡ªé€‚åº”è·¯ç”±éœ€è¦ç›‘æ§å„é“¾è·¯è´Ÿè½½ï¼Œä½¿ç”¨å¤‡é€‰è·¯å¾„ã€‚3) æ··åˆç²¾åº¦éœ€è¦å¯é…ç½®çš„æ•°æ®é€šè·¯å’Œä½å®½è½¬æ¢é€»è¾‘ã€‚</p>
                </details>
                <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                <div class="answer">
                    <div class="code-block">
// ç¨€ç–æ„ŸçŸ¥PEé˜µåˆ—
module SparsePEArray #(
    parameter ARRAY_DIM = 16,
    parameter DATA_WIDTH = 8,
    parameter SPARSE_THRESHOLD = 10  // ç¨€ç–åº¦é˜ˆå€¼
)(
    input wire clk,
    input wire rst_n,
    
    // ç¨€ç–æ•°æ®è¾“å…¥
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] weight_values,
    input wire [ARRAY_DIM-1:0] weight_valid,  // éé›¶æ ‡å¿—
    input wire [ARRAY_DIM-1:0][DATA_WIDTH-1:0] activation_values,
    input wire [ARRAY_DIM-1:0] activation_valid,
    
    // å‹ç¼©ç´¢å¼•
    input wire [ARRAY_DIM-1:0][3:0] weight_indices,
    input wire [ARRAY_DIM-1:0][3:0] activation_indices,
    
    // è¾“å‡º
    output reg [ARRAY_DIM-1:0][31:0] sparse_results,
    output reg [ARRAY_DIM-1:0] result_valid
);
    
    // ç¨€ç–åº¦æ£€æµ‹
    reg [7:0] weight_sparsity, activation_sparsity;
    always @(*) begin
        weight_sparsity = 0;
        activation_sparsity = 0;
        for (int i = 0; i < ARRAY_DIM; i++) begin
            if (!weight_valid[i]) weight_sparsity = weight_sparsity + 1;
            if (!activation_valid[i]) activation_sparsity = activation_sparsity + 1;
        end
    end
    
    // åŠ¨æ€é€‰æ‹©è®¡ç®—æ¨¡å¼
    wire sparse_mode = (weight_sparsity > SPARSE_THRESHOLD) || 
                       (activation_sparsity > SPARSE_THRESHOLD);
    
    // ç¨€ç–è®¡ç®—å¼•æ“
    genvar pe_idx;
    generate
        for (pe_idx = 0; pe_idx < ARRAY_DIM; pe_idx = pe_idx + 1) begin : sparse_pe
            SparsePE #(
                .DATA_WIDTH(DATA_WIDTH)
            ) spe (
                .clk(clk),
                .rst_n(rst_n),
                .sparse_mode(sparse_mode),
                // ç¨ å¯†è¾“å…¥
                .dense_weight(weight_values[pe_idx]),
                .dense_activation(activation_values[pe_idx]),
                // ç¨€ç–è¾“å…¥
                .sparse_weight_val(weight_values[pe_idx]),
                .sparse_weight_idx(weight_indices[pe_idx]),
                .sparse_weight_valid(weight_valid[pe_idx]),
                .sparse_act_val(activation_values[pe_idx]),
                .sparse_act_idx(activation_indices[pe_idx]),
                .sparse_act_valid(activation_valid[pe_idx]),
                // è¾“å‡º
                .result(sparse_results[pe_idx]),
                .result_valid(result_valid[pe_idx])
            );
        end
    endgenerate
    
    // é›¶å€¼è·³è¿‡æ§åˆ¶å™¨
    ZeroSkipController #(
        .ARRAY_DIM(ARRAY_DIM)
    ) skip_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .data_valid(weight_valid & activation_valid),
        .skip_enable(sparse_mode),
        .compute_enable(pe_compute_en)
    );
endmodule

// è‡ªé€‚åº”NoCè·¯ç”±
module AdaptiveRouter #(
    parameter NODE_ID = 0,
    parameter NETWORK_WIDTH = 4,
    parameter NETWORK_HEIGHT = 4,
    parameter FLIT_WIDTH = 128,
    parameter VC_NUM = 4
)(
    input wire clk,
    input wire rst_n,
    
    // è¾“å…¥ç«¯å£ï¼ˆ5ä¸ªæ–¹å‘ï¼šN,S,E,W,Localï¼‰
    input wire [4:0][FLIT_WIDTH-1:0] in_flits,
    input wire [4:0] in_valid,
    output wire [4:0] in_ready,
    
    // è¾“å‡ºç«¯å£
    output reg [4:0][FLIT_WIDTH-1:0] out_flits,
    output reg [4:0] out_valid,
    input wire [4:0] out_ready,
    
    // æ‹¥å¡ä¿¡æ¯
    input wire [4:0][7:0] congestion_level,
    output wire [7:0] local_congestion
);
    
    // æå–ç›®æ ‡åœ°å€
    wire [7:0] dest_x[4:0], dest_y[4:0];
    genvar port;
    generate
        for (port = 0; port < 5; port = port + 1) begin : dest_extract
            assign dest_x[port] = in_flits[port][7:0];
            assign dest_y[port] = in_flits[port][15:8];
        end
    endgenerate
    
    // è®¡ç®—æœ€çŸ­è·¯å¾„
    reg [2:0] preferred_port[4:0];
    reg [2:0] alternate_port[4:0];
    
    always @(*) begin
        for (int i = 0; i < 5; i++) begin
            // XYè·¯ç”±ä½œä¸ºåŸºç¡€
            if (dest_x[i] > NODE_ID % NETWORK_WIDTH) begin
                preferred_port[i] = 3'd2; // East
            end else if (dest_x[i] < NODE_ID % NETWORK_WIDTH) begin
                preferred_port[i] = 3'd3; // West
            end else if (dest_y[i] > NODE_ID / NETWORK_WIDTH) begin
                preferred_port[i] = 3'd0; // North
            end else if (dest_y[i] < NODE_ID / NETWORK_WIDTH) begin
                preferred_port[i] = 3'd1; // South
            end else begin
                preferred_port[i] = 3'd4; // Local
            end
            
            // è®¡ç®—å¤‡é€‰è·¯å¾„ï¼ˆYXè·¯ç”±ï¼‰
            if (dest_y[i] > NODE_ID / NETWORK_WIDTH) begin
                alternate_port[i] = 3'd0; // North
            end else if (dest_y[i] < NODE_ID / NETWORK_WIDTH) begin
                alternate_port[i] = 3'd1; // South
            end else if (dest_x[i] > NODE_ID % NETWORK_WIDTH) begin
                alternate_port[i] = 3'd2; // East
            end else if (dest_x[i] < NODE_ID % NETWORK_WIDTH) begin
                alternate_port[i] = 3'd3; // West
            end else begin
                alternate_port[i] = 3'd4; // Local
            end
        end
    end
    
    // è‡ªé€‚åº”è·¯ç”±å†³ç­–
    reg [2:0] selected_port[4:0];
    always @(*) begin
        for (int i = 0; i < 5; i++) begin
            // æ¯”è¾ƒæ‹¥å¡ç¨‹åº¦
            if (congestion_level[preferred_port[i]] < 
                congestion_level[alternate_port[i]] + 8'd32) begin
                // ä¼˜é€‰è·¯å¾„æ‹¥å¡ä¸ä¸¥é‡ï¼Œä½¿ç”¨ä¼˜é€‰
                selected_port[i] = preferred_port[i];
            end else begin
                // ä¼˜é€‰è·¯å¾„æ‹¥å¡ï¼Œä½¿ç”¨å¤‡é€‰
                selected_port[i] = alternate_port[i];
            end
        end
    end
    
    // ä»²è£å’Œäº¤å‰å¼€å…³
    wire [4:0][4:0] request_matrix;  // request_matrix[i][j]: è¾“å…¥iè¯·æ±‚è¾“å‡ºj
    wire [4:0][4:0] grant_matrix;
    
    genvar in_p, out_p;
    generate
        for (in_p = 0; in_p < 5; in_p = in_p + 1) begin : req_gen
            for (out_p = 0; out_p < 5; out_p = out_p + 1) begin : req_out
                assign request_matrix[in_p][out_p] = 
                    in_valid[in_p] && (selected_port[in_p] == out_p);
            end
        end
    endgenerate
    
    // Round-Robinä»²è£å™¨
    RoundRobinArbiter #(
        .NUM_PORTS(5)
    ) arbiter[4:0] (
        .clk(clk),
        .rst_n(rst_n),
        .requests(request_matrix),
        .grants(grant_matrix)
    );
    
    // è¾“å‡ºå¤šè·¯å¤ç”¨
    always @(posedge clk) begin
        if (!rst_n) begin
            out_valid <= 0;
        end else begin
            for (int out_p = 0; out_p < 5; out_p++) begin
                out_valid[out_p] <= 0;
                for (int in_p = 0; in_p < 5; in_p++) begin
                    if (grant_matrix[in_p][out_p]) begin
                        out_flits[out_p] <= in_flits[in_p];
                        out_valid[out_p] <= 1;
                    end
                end
            end
        end
    end
    
    // æœ¬åœ°æ‹¥å¡åº¦è®¡ç®—
    reg [7:0] buffer_occupancy[4:0];
    assign local_congestion = (buffer_occupancy[0] + buffer_occupancy[1] + 
                              buffer_occupancy[2] + buffer_occupancy[3] + 
                              buffer_occupancy[4]) / 5;
endmodule

// æ··åˆç²¾åº¦è®¡ç®—å•å…ƒ
module MixedPrecisionUnit #(
    parameter MAX_WIDTH = 16  // æœ€å¤§æ”¯æŒFP16
)(
    input wire clk,
    input wire rst_n,
    
    // æ“ä½œæ•°è¾“å…¥
    input wire [MAX_WIDTH-1:0] operand_a,
    input wire [MAX_WIDTH-1:0] operand_b,
    input wire [31:0] accumulator,
    
    // ç²¾åº¦æ§åˆ¶
    input wire [1:0] precision_mode,  // 00:INT4 01:INT8 10:FP16
    input wire [2:0] operation,       // 000:MAC 001:ADD 010:MUL
    
    // è¾“å‡º
    output reg [31:0] result,
    output reg overflow,
    output reg underflow
);
    
    // ç²¾åº¦æ¨¡å¼å®šä¹‰
    localparam INT4_MODE = 2'b00;
    localparam INT8_MODE = 2'b01;
    localparam FP16_MODE = 2'b10;
    
    // INT4è®¡ç®—å•å…ƒï¼ˆå¯ä»¥å¹¶è¡Œè®¡ç®—4ä¸ªï¼‰
    wire [3:0] int4_a[3:0], int4_b[3:0];
    wire [7:0] int4_results[3:0];
    
    genvar i;
    generate
        for (i = 0; i < 4; i = i + 1) begin : int4_extract
            assign int4_a[i] = operand_a[i*4 +: 4];
            assign int4_b[i] = operand_b[i*4 +: 4];
            
            // INT4 MAC
            wire [7:0] int4_prod = $signed(int4_a[i]) * $signed(int4_b[i]);
            assign int4_results[i] = int4_prod;
        end
    endgenerate
    
    // INT8è®¡ç®—å•å…ƒï¼ˆå¯ä»¥å¹¶è¡Œè®¡ç®—2ä¸ªï¼‰
    wire [7:0] int8_a[1:0], int8_b[1:0];
    wire [15:0] int8_results[1:0];
    
    generate
        for (i = 0; i < 2; i = i + 1) begin : int8_calc
            assign int8_a[i] = operand_a[i*8 +: 8];
            assign int8_b[i] = operand_b[i*8 +: 8];
            
            // INT8 MAC
            wire [15:0] int8_prod = $signed(int8_a[i]) * $signed(int8_b[i]);
            assign int8_results[i] = int8_prod;
        end
    endgenerate
    
    // FP16è®¡ç®—å•å…ƒ
    wire [15:0] fp16_a = operand_a[15:0];
    wire [15:0] fp16_b = operand_b[15:0];
    wire [31:0] fp16_result;
    
    FP16MAC fp16_mac (
        .a(fp16_a),
        .b(fp16_b),
        .c(accumulator),
        .result(fp16_result),
        .overflow(fp16_overflow),
        .underflow(fp16_underflow)
    );
    
    // ç»“æœé€‰æ‹©å’Œç´¯åŠ 
    always @(posedge clk) begin
        if (!rst_n) begin
            result <= 0;
            overflow <= 0;
            underflow <= 0;
        end else begin
            case (precision_mode)
                INT4_MODE: begin
                    // INT4æ¨¡å¼ï¼š4è·¯å¹¶è¡Œ
                    result <= accumulator + 
                             $signed(int4_results[0]) + 
                             $signed(int4_results[1]) + 
                             $signed(int4_results[2]) + 
                             $signed(int4_results[3]);
                    overflow <= 0;
                    underflow <= 0;
                end
                
                INT8_MODE: begin
                    // INT8æ¨¡å¼ï¼š2è·¯å¹¶è¡Œ
                    result <= accumulator + 
                             $signed(int8_results[0]) + 
                             $signed(int8_results[1]);
                    overflow <= 0;
                    underflow <= 0;
                end
                
                FP16_MODE: begin
                    // FP16æ¨¡å¼ï¼šå•è·¯
                    result <= fp16_result;
                    overflow <= fp16_overflow;
                    underflow <= fp16_underflow;
                end
                
                default: begin
                    result <= accumulator;
                end
            endcase
        end
    end
    
    // åŠ¨æ€ç²¾åº¦é€‰æ‹©é€»è¾‘
    reg [1:0] auto_precision;
    reg [31:0] value_range;
    
    always @(*) begin
        // æ ¹æ®æ•°å€¼èŒƒå›´è‡ªåŠ¨é€‰æ‹©ç²¾åº¦
        value_range = (operand_a > operand_b) ? operand_a : operand_b;
        
        if (value_range < 16) begin
            auto_precision = INT4_MODE;  // å°æ•°å€¼ç”¨INT4
        end else if (value_range < 256) begin
            auto_precision = INT8_MODE;  // ä¸­ç­‰æ•°å€¼ç”¨INT8
        end else begin
            auto_precision = FP16_MODE;  // å¤§æ•°å€¼ç”¨FP16
        end
    end
endmodule
                    </div>
                    <p><strong>è§£æï¼š</strong></p>
                    <ul>
                        <li>ç¨€ç–PEé˜µåˆ—é€šè¿‡æ£€æµ‹é›¶å€¼åˆ†å¸ƒï¼ŒåŠ¨æ€åˆ‡æ¢è®¡ç®—æ¨¡å¼ï¼Œè·³è¿‡é›¶å€¼MACæ“ä½œ</li>
                        <li>è‡ªé€‚åº”è·¯ç”±å™¨åŸºäºå®æ—¶æ‹¥å¡ä¿¡æ¯é€‰æ‹©XYæˆ–YXè·¯ç”±ï¼Œé¿å…çƒ­ç‚¹</li>
                        <li>æ··åˆç²¾åº¦å•å…ƒæ”¯æŒINT4/INT8/FP16ï¼ŒINT4æ¨¡å¼ä¸‹å¯4è·¯å¹¶è¡Œæé«˜ååé‡</li>
                        <li>åŒ…å«è‡ªåŠ¨ç²¾åº¦é€‰æ‹©é€»è¾‘ï¼Œæ ¹æ®æ•°å€¼èŒƒå›´åŠ¨æ€è°ƒæ•´ç²¾åº¦</li>
                        <li>è¿™äº›ä¼˜åŒ–å¯ä»¥æ˜¾è‘—æå‡NPUçš„èƒ½æ•ˆå’Œçµæ´»æ€§</li>
                    </ul>
                </div>
            </div>

            <h3>12.3 RTLå®ç°ä¸éªŒè¯</h3>
            
            <p>æœ¬èŠ‚å°†å±•ç¤ºå…³é”®æ¨¡å—çš„RTLå®ç°ç»†èŠ‚ï¼Œå¹¶å»ºç«‹å®Œæ•´çš„éªŒè¯ç¯å¢ƒã€‚</p>

            <h4>12.3.1 MACå•å…ƒRTLå®ç°</h4>
            <div class="code-block">
// é«˜æ€§èƒ½MACå•å…ƒå®ç° - æ”¹è¿›ç‰ˆï¼ˆä¸¥æ ¼éµå¾ªå¯ç»¼åˆè§„èŒƒï¼‰
module HighPerformanceMAC #(
    parameter DATA_WIDTH = 8,
    parameter ACCUM_WIDTH = 32,
    parameter PIPELINE_STAGES = 3
)(
    input wire clk,
    input wire rst_n,
    
    // è¾“å…¥æ¥å£
    input wire signed [DATA_WIDTH-1:0] a,
    input wire signed [DATA_WIDTH-1:0] b,
    input wire signed [ACCUM_WIDTH-1:0] c,
    input wire valid_in,
    input wire [1:0] mode,  // 00:MAC 01:MUL 10:ADD 11:BYPASS
    
    // è¾“å‡ºæ¥å£
    output reg signed [ACCUM_WIDTH-1:0] result,
    output reg valid_out,
    output reg overflow
);
    
    // ç¡®ä¿æ‰€æœ‰å†…éƒ¨ä¿¡å·å£°æ˜
    wire signed [2*DATA_WIDTH-1:0] mult_result_comb;
    reg signed [ACCUM_WIDTH-1:0] add_result_next;
    reg overflow_next;
    
    // æµæ°´çº¿å¯„å­˜å™¨
    reg signed [DATA_WIDTH-1:0] a_r1, b_r1;
    reg signed [ACCUM_WIDTH-1:0] c_r1, c_r2;
    reg [1:0] mode_r1, mode_r2;
    reg valid_r1, valid_r2;
    
    // ä¹˜æ³•ç»“æœ
    reg signed [2*DATA_WIDTH-1:0] mult_result;
    reg signed [ACCUM_WIDTH-1:0] mult_extended;
    
    // ç¬¬ä¸€çº§ï¼šè¾“å…¥å¯„å­˜
    always @(posedge clk) begin
        if (!rst_n) begin
            a_r1 <= 0;
            b_r1 <= 0;
            c_r1 <= 0;
            mode_r1 <= 0;
            valid_r1 <= 0;
        end else begin
            a_r1 <= a;
            b_r1 <= b;
            c_r1 <= c;
            mode_r1 <= mode;
            valid_r1 <= valid_in;
        end
    end
    
    // ç»„åˆé€»è¾‘è®¡ç®—ä¹˜æ³•ç»“æœ
    assign mult_result_comb = a_r1 * b_r1;
    
    // ç¬¬äºŒçº§ï¼šä¹˜æ³•ç»“æœå¯„å­˜ï¼ˆä½¿ç”¨éé˜»å¡èµ‹å€¼ï¼‰
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mult_result <= '0;
            c_r2 <= '0;
            mode_r2 <= 2'b00;
            valid_r2 <= 1'b0;
        end else begin
            mult_result <= mult_result_comb;
            c_r2 <= c_r1;
            mode_r2 <= mode_r1;
            valid_r2 <= valid_r1;
        end
    end
    
    // ç¬¦å·æ‰©å±•
    always @(*) begin
        mult_extended = {{(ACCUM_WIDTH-2*DATA_WIDTH){mult_result[2*DATA_WIDTH-1]}}, 
                        mult_result};
    end
    
    // ç»„åˆé€»è¾‘è®¡ç®—ä¸‹ä¸€ä¸ªç»“æœ
    always @(*) begin
        // å…ˆç»™æ‰€æœ‰è¾“å‡ºèµ‹é»˜è®¤å€¼ï¼Œé¿å…é”å­˜å™¨
        add_result_next = result;
        overflow_next = 1'b0;
        
        case (mode_r2)
            2'b00: begin  // MAC
                {overflow_next, add_result_next} = {mult_extended[ACCUM_WIDTH-1], mult_extended} + 
                                                   {c_r2[ACCUM_WIDTH-1], c_r2};
            end
            2'b01: begin  // MUL only
                add_result_next = mult_extended;
                overflow_next = 1'b0;
            end
            2'b10: begin  // ADD only
                add_result_next = c_r2 + {{(ACCUM_WIDTH-DATA_WIDTH){a_r1[DATA_WIDTH-1]}}, a_r1};
                overflow_next = 1'b0;
            end
            2'b11: begin  // BYPASS
                add_result_next = c_r2;
                overflow_next = 1'b0;
            end
            default: begin  // ç¡®ä¿å®Œå¤‡æ€§
                add_result_next = c_r2;
                overflow_next = 1'b0;
            end
        endcase
    end
    
    // ç¬¬ä¸‰çº§ï¼šç»“æœå¯„å­˜
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            result <= '0;
            valid_out <= 1'b0;
            overflow <= 1'b0;
        end else begin
            result <= add_result_next;
            valid_out <= valid_r2;
            overflow <= overflow_next;
        end
    end
    
    // æ–­è¨€æ£€æŸ¥
    // synthesis translate_off
    always @(posedge clk) begin
        if (valid_in && valid_r1 && valid_r2) begin
            assert(valid_out) else $error("Pipeline stall detected");
        end
    end
    // synthesis translate_on
endmodule

// è„‰åŠ¨é˜µåˆ—å®ç°
module SystolicArray #(
    parameter ARRAY_SIZE = 16,
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    
    // æƒé‡åŠ è½½æ¥å£
    input wire weight_load,
    input wire [ARRAY_SIZE-1:0][ARRAY_SIZE-1:0][DATA_WIDTH-1:0] weights,
    
    // æ•°æ®æµæ¥å£
    input wire [ARRAY_SIZE-1:0][DATA_WIDTH-1:0] input_data,
    input wire input_valid,
    
    // è¾“å‡ºæ¥å£
    output wire [ARRAY_SIZE-1:0][31:0] output_data,
    output wire [ARRAY_SIZE-1:0] output_valid
);
    
    // PEé—´è¿æ¥
    wire [ARRAY_SIZE:0][ARRAY_SIZE:0][DATA_WIDTH-1:0] h_data;
    wire [ARRAY_SIZE:0][ARRAY_SIZE:0][31:0] v_data;
    wire [ARRAY_SIZE:0][ARRAY_SIZE:0] h_valid, v_valid;
    
    // è¾¹ç•Œè¿æ¥
    genvar i;
    generate
        for (i = 0; i < ARRAY_SIZE; i = i + 1) begin : boundary
            // å·¦è¾¹ç•Œè¾“å…¥
            assign h_data[i][0] = input_data[i];
            assign h_valid[i][0] = input_valid;
            
            // ä¸Šè¾¹ç•Œè¾“å…¥ï¼ˆéƒ¨åˆ†å’Œåˆå§‹åŒ–ä¸º0ï¼‰
            assign v_data[0][i] = 32'h0;
            assign v_valid[0][i] = 1'b1;
            
            // ä¸‹è¾¹ç•Œè¾“å‡º
            assign output_data[i] = v_data[ARRAY_SIZE][i];
            assign output_valid[i] = v_valid[ARRAY_SIZE][i];
        end
    endgenerate
    
    // PEé˜µåˆ—å®ä¾‹åŒ–
    genvar row, col;
    generate
        for (row = 0; row < ARRAY_SIZE; row = row + 1) begin : pe_row
            for (col = 0; col < ARRAY_SIZE; col = col + 1) begin : pe_col
                SystolicPE #(
                    .DATA_WIDTH(DATA_WIDTH)
                ) pe (
                    .clk(clk),
                    .rst_n(rst_n),
                    
                    // æƒé‡æ¥å£
                    .weight_load(weight_load),
                    .weight_in(weights[row][col]),
                    
                    // æ°´å¹³æ•°æ®æµï¼ˆæ¿€æ´»å€¼ï¼‰
                    .h_data_in(h_data[row][col]),
                    .h_valid_in(h_valid[row][col]),
                    .h_data_out(h_data[row][col+1]),
                    .h_valid_out(h_valid[row][col+1]),
                    
                    // å‚ç›´æ•°æ®æµï¼ˆéƒ¨åˆ†å’Œï¼‰
                    .v_data_in(v_data[row][col]),
                    .v_valid_in(v_valid[row][col]),
                    .v_data_out(v_data[row+1][col]),
                    .v_valid_out(v_valid[row+1][col])
                );
            end
        end
    endgenerate
endmodule

// è„‰åŠ¨PEå•å…ƒ
module SystolicPE #(
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    
    // æƒé‡æ¥å£
    input wire weight_load,
    input wire [DATA_WIDTH-1:0] weight_in,
    
    // æ°´å¹³æ•°æ®æµ
    input wire [DATA_WIDTH-1:0] h_data_in,
    input wire h_valid_in,
    output reg [DATA_WIDTH-1:0] h_data_out,
    output reg h_valid_out,
    
    // å‚ç›´æ•°æ®æµ
    input wire [31:0] v_data_in,
    input wire v_valid_in,
    output reg [31:0] v_data_out,
    output reg v_valid_out
);
    
    // æƒé‡å¯„å­˜å™¨
    reg [DATA_WIDTH-1:0] weight_reg;
    
    // æƒé‡åŠ è½½
    always @(posedge clk) begin
        if (!rst_n) begin
            weight_reg <= 0;
        end else if (weight_load) begin
            weight_reg <= weight_in;
        end
    end
    
    // MACè®¡ç®—
    wire [31:0] mac_result;
    wire mac_valid;
    
    HighPerformanceMAC #(
        .DATA_WIDTH(DATA_WIDTH),
        .ACCUM_WIDTH(32),
        .PIPELINE_STAGES(1)
    ) mac_unit (
        .clk(clk),
        .rst_n(rst_n),
        .a(h_data_in),
        .b(weight_reg),
        .c(v_data_in),
        .valid_in(h_valid_in & v_valid_in),
        .mode(2'b00),  // MAC mode
        .result(mac_result),
        .valid_out(mac_valid),
        .overflow()
    );
    
    // æ•°æ®ä¼ é€’
    always @(posedge clk) begin
        if (!rst_n) begin
            h_data_out <= 0;
            h_valid_out <= 0;
            v_data_out <= 0;
            v_valid_out <= 0;
        end else begin
            // æ°´å¹³ä¼ é€’ï¼ˆæ¿€æ´»å€¼ï¼‰
            h_data_out <= h_data_in;
            h_valid_out <= h_valid_in;
            
            // å‚ç›´ä¼ é€’ï¼ˆéƒ¨åˆ†å’Œï¼‰
            v_data_out <= mac_result;
            v_valid_out <= mac_valid;
        end
    end
endmodule
            </div>

            <h4>12.3.2 UVMéªŒè¯ç¯å¢ƒ</h4>
            <div class="code-block">
// æ”¹è¿›çš„UVMæµ‹è¯•ç¯å¢ƒ - å®Œæ•´çš„è‡ªæ ¡éªŒå’Œè¦†ç›–ç‡é©±åŠ¨
class npu_env extends uvm_env;
    `uvm_component_utils(npu_env)
    
    // ç¯å¢ƒç»„ä»¶
    npu_agent           input_agent;
    npu_agent           output_agent;
    npu_scoreboard      scoreboard;
    npu_coverage        coverage;
    npu_ref_model       ref_model;
    npu_assertion_monitor assertion_mon;  // æ–°å¢ï¼šæ–­è¨€ç›‘æµ‹å™¨
    npu_performance_monitor perf_mon;     // æ–°å¢ï¼šæ€§èƒ½ç›‘æµ‹å™¨
    
    // é…ç½®å¯¹è±¡
    npu_env_config      env_cfg;
    
    function new(string name = "npu_env", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // è·å–é…ç½®
        if (!uvm_config_db#(npu_env_config)::get(this, "", "env_cfg", env_cfg))
            `uvm_fatal("ENV", "Failed to get env_cfg")
        
        // åˆ›å»ºä»£ç†
        input_agent = npu_agent::type_id::create("input_agent", this);
        output_agent = npu_agent::type_id::create("output_agent", this);
        
        // åˆ›å»ºè®°åˆ†æ¿å’Œè¦†ç›–ç‡
        scoreboard = npu_scoreboard::type_id::create("scoreboard", this);
        coverage = npu_coverage::type_id::create("coverage", this);
        ref_model = npu_ref_model::type_id::create("ref_model", this);
        
        // é…ç½®ä»£ç†
        input_agent.is_active = UVM_ACTIVE;
        output_agent.is_active = UVM_PASSIVE;
    endfunction
    
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        // è¿æ¥TLMç«¯å£
        input_agent.monitor.ap.connect(ref_model.input_fifo.analysis_export);
        input_agent.monitor.ap.connect(coverage.analysis_export);
        
        ref_model.output_ap.connect(scoreboard.expected_fifo.analysis_export);
        output_agent.monitor.ap.connect(scoreboard.actual_fifo.analysis_export);
    endfunction
endclass

// NPUä»£ç†
class npu_agent extends uvm_agent;
    `uvm_component_utils(npu_agent)
    
    npu_driver      driver;
    npu_monitor     monitor;
    npu_sequencer   sequencer;
    
    function new(string name = "npu_agent", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        monitor = npu_monitor::type_id::create("monitor", this);
        
        if (is_active == UVM_ACTIVE) begin
            driver = npu_driver::type_id::create("driver", this);
            sequencer = npu_sequencer::type_id::create("sequencer", this);
        end
    endfunction
    
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        if (is_active == UVM_ACTIVE) begin
            driver.seq_item_port.connect(sequencer.seq_item_export);
        end
    endfunction
endclass

// å¢å¼ºçš„NPUäº‹åŠ¡ - æ”¯æŒæ›´å¤šçº¦æŸå’Œçµæ´»æ€§
class npu_transaction extends uvm_sequence_item;
    `uvm_object_utils(npu_transaction)
    
    // äº‹åŠ¡ç±»å‹
    typedef enum {CONV, FC, POOL, ACTIVATION, SPARSE_CONV, DEPTHWISE} op_type_e;
    rand op_type_e op_type;
    
    // æ•°æ®å­—æ®µ
    rand bit [7:0] input_data[];
    rand bit [7:0] weight_data[];
    rand bit [31:0] output_data[];
    
    // é…ç½®å‚æ•°
    rand int input_height, input_width, input_channels;
    rand int output_height, output_width, output_channels;
    rand int kernel_size, stride, padding;
    rand int sparsity_ratio;  // æ–°å¢ï¼šç¨€ç–åº¦
    rand bit use_bias;        // æ–°å¢ï¼šæ˜¯å¦ä½¿ç”¨åç½®
    rand bit [2:0] precision_mode; // æ–°å¢ï¼šINT4/INT8/FP16
    
    // å¢å¼ºçš„çº¦æŸ - æ›´æ¥è¿‘å®é™…åº”ç”¨
    constraint data_size_c {
        input_data.size() == input_height * input_width * input_channels;
        if (op_type == DEPTHWISE) {
            weight_data.size() == kernel_size * kernel_size * input_channels;
        } else {
            weight_data.size() == kernel_size * kernel_size * input_channels * output_channels;
        }
        output_data.size() == output_height * output_width * output_channels;
    }
    
    constraint dimension_c {
        input_height inside {[8:256]};
        input_width inside {[8:256]};
        input_channels inside {[16:512]};
        output_channels inside {[16:512]};
        kernel_size inside {1, 3, 5, 7};
        stride inside {1, 2};
        padding inside {[0:3]};
        
        // è¾“å‡ºå°ºå¯¸è®¡ç®—çº¦æŸ
        output_height == (input_height + 2*padding - kernel_size) / stride + 1;
        output_width == (input_width + 2*padding - kernel_size) / stride + 1;
        
        // ç¨€ç–åº¦çº¦æŸ
        sparsity_ratio inside {[0:90]}; // 0-90%ç¨€ç–åº¦
        
        // ç²¾åº¦æ¨¡å¼çº¦æŸ
        precision_mode inside {[0:2]}; // 0:INT4, 1:INT8, 2:FP16
    }
    
    // ç¨€ç–æ•°æ®ç”Ÿæˆçº¦æŸ
    constraint sparsity_c {
        if (op_type == SPARSE_CONV) {
            // æ ¹æ®ç¨€ç–åº¦æ¯”ä¾‹è®¾ç½®é›¶å€¼
            foreach (weight_data[i]) {
                (sparsity_ratio > 50) -> (weight_data[i] dist {0 := sparsity_ratio, [1:255] := 100-sparsity_ratio});
            }
        }
    }
    
    function new(string name = "npu_transaction");
        super.new(name);
    endfunction
    
    function void do_copy(uvm_object rhs);
        npu_transaction tr;
        super.do_copy(rhs);
        $cast(tr, rhs);
        op_type = tr.op_type;
        input_data = tr.input_data;
        weight_data = tr.weight_data;
        output_data = tr.output_data;
    endfunction
endclass

// å¢å¼ºçš„çº¦æŸéšæœºæµ‹è¯•åºåˆ—
class constrained_random_sequence extends uvm_sequence#(npu_transaction);
    `uvm_object_utils(constrained_random_sequence)
    
    // å¯é…ç½®å‚æ•°
    rand int num_transactions = 1000;
    rand bit enable_sparse = 1;
    rand bit enable_mixed_precision = 1;
    
    function new(string name = "constrained_random_sequence");
        super.new(name);
    endfunction
    
    task body();
        npu_transaction tr;
        
        // éšæœºç”Ÿæˆå¤šç§ç±»å‹çš„äº‹åŠ¡
        repeat(num_transactions) begin
            tr = npu_transaction::type_id::create("tr");
            start_item(tr);
            
            // å¤æ‚çš„çº¦æŸéšæœºåŒ–
            assert(tr.randomize() with {
                // æ“ä½œç±»å‹åˆ†å¸ƒ
                op_type dist {CONV := 40, FC := 20, POOL := 10, 
                             ACTIVATION := 10, SPARSE_CONV := 15, DEPTHWISE := 5};
                
                // æ ¹æ®æ“ä½œç±»å‹è°ƒæ•´å‚æ•°
                if (op_type == CONV || op_type == SPARSE_CONV) {
                    kernel_size dist {1 := 10, 3 := 60, 5 := 20, 7 := 10};
                    stride dist {1 := 70, 2 := 30};
                }
                
                if (op_type == POOL) {
                    kernel_size inside {2, 3};
                    stride == kernel_size; // æ— é‡å æ± åŒ–
                }
                
                // ç²¾åº¦æ¨¡å¼éšæœºåŒ–
                if (enable_mixed_precision) {
                    precision_mode dist {0 := 30, 1 := 50, 2 := 20}; // INT4:30%, INT8:50%, FP16:20%
                } else {
                    precision_mode == 1; // ä»…INT8
                }
                
                // ç¨€ç–åº¦æ§åˆ¶
                if (enable_sparse && op_type == SPARSE_CONV) {
                    sparsity_ratio dist {[0:30] := 20, [31:70] := 60, [71:90] := 20};
                } else {
                    sparsity_ratio == 0;
                }
            }) else `uvm_error("RAND", "Randomization failed");
            
            finish_item(tr);
        end
    endtask
endclass

// å¢å¼ºçš„å‚è€ƒæ¨¡å‹ - ä½ç²¾ç¡®æ€§èƒ½æ¨¡å‹
class npu_ref_model extends uvm_component;
    `uvm_component_utils(npu_ref_model)
    
    uvm_tlm_analysis_fifo#(npu_transaction) input_fifo;
    uvm_analysis_port#(npu_transaction) output_ap;
    
    // æ€§èƒ½ç»Ÿè®¡
    int total_operations = 0;
    int sparse_operations_skipped = 0;
    real average_sparsity = 0.0;
    
    // é…ç½®
    bit enable_performance_modeling = 1;
    bit enable_precision_modeling = 1;
    
    function new(string name = "npu_ref_model", uvm_component parent = null);
        super.new(name, parent);
        input_fifo = new("input_fifo", this);
        output_ap = new("output_ap", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        npu_transaction input_tr, output_tr;
        
        forever begin
            input_fifo.get(input_tr);
            
            // å…‹éš†äº‹åŠ¡
            $cast(output_tr, input_tr.clone());
            
            // æ ¹æ®æ“ä½œç±»å‹è®¡ç®—æœŸæœ›è¾“å‡º
            case (input_tr.op_type)
                npu_transaction::CONV: compute_conv(input_tr, output_tr);
                npu_transaction::FC: compute_fc(input_tr, output_tr);
                npu_transaction::POOL: compute_pool(input_tr, output_tr);
                npu_transaction::ACTIVATION: compute_activation(input_tr, output_tr);
            endcase
            
            // å‘é€æœŸæœ›è¾“å‡º
            output_ap.write(output_tr);
        end
    endtask
    
    // å·ç§¯è®¡ç®—
    function void compute_conv(npu_transaction input_tr, output npu_transaction output_tr);
        int in_idx, w_idx, out_idx;
        int h, w, c, k_h, k_w, oc;
        int in_h, in_w;
        int accumulator;
        
        // æ¸…ç©ºè¾“å‡º
        foreach (output_tr.output_data[i])
            output_tr.output_data[i] = 0;
        
        // æ‰§è¡Œå·ç§¯
        for (h = 0; h < output_tr.output_height; h++) begin
            for (w = 0; w < output_tr.output_width; w++) begin
                for (oc = 0; oc < output_tr.output_channels; oc++) begin
                    accumulator = 0;
                    
                    for (k_h = 0; k_h < input_tr.kernel_size; k_h++) begin
                        for (k_w = 0; k_w < input_tr.kernel_size; k_w++) begin
                            for (c = 0; c < input_tr.input_channels; c++) begin
                                in_h = h * input_tr.stride - input_tr.padding + k_h;
                                in_w = w * input_tr.stride - input_tr.padding + k_w;
                                
                                if (in_h >= 0 && in_h < input_tr.input_height &&
                                    in_w >= 0 && in_w < input_tr.input_width) begin
                                    
                                    in_idx = (in_h * input_tr.input_width + in_w) * 
                                            input_tr.input_channels + c;
                                    w_idx = ((k_h * input_tr.kernel_size + k_w) * 
                                            input_tr.input_channels + c) * 
                                            output_tr.output_channels + oc;
                                    
                                    accumulator += input_tr.input_data[in_idx] * 
                                                  input_tr.weight_data[w_idx];
                                end
                            end
                        end
                    end
                    
                    out_idx = (h * output_tr.output_width + w) * 
                             output_tr.output_channels + oc;
                    output_tr.output_data[out_idx] = accumulator;
                end
            end
        end
    endfunction
endclass
            </div>

            <h4>12.3.3 æ€§èƒ½éªŒè¯ä¸åˆ†æ</h4>
            <div class="code-block">
// æ€§èƒ½ç›‘æ§æ¨¡å—
module PerformanceMonitor #(
    parameter NUM_COUNTERS = 16,
    parameter COUNTER_WIDTH = 48
)(
    input wire clk,
    input wire rst_n,
    
    // äº‹ä»¶è¾“å…¥
    input wire mac_valid,
    input wire cache_hit,
    input wire cache_miss,
    input wire ddr_read_valid,
    input wire ddr_write_valid,
    input wire [3:0] active_clusters,
    
    // æ§åˆ¶æ¥å£
    input wire [3:0] counter_select,
    output reg [COUNTER_WIDTH-1:0] counter_value,
    
    // æ€§èƒ½æŒ‡æ ‡è¾“å‡º
    output reg [31:0] ops_per_second,
    output reg [31:0] bandwidth_utilization,
    output reg [31:0] cache_hit_rate,
    output reg [31:0] power_efficiency
);
    
    // æ€§èƒ½è®¡æ•°å™¨
    reg [COUNTER_WIDTH-1:0] perf_counters [NUM_COUNTERS-1:0];
    
    // è®¡æ•°å™¨å®šä¹‰
    localparam CNT_CYCLES = 0;
    localparam CNT_MAC_OPS = 1;
    localparam CNT_CACHE_HITS = 2;
    localparam CNT_CACHE_MISSES = 3;
    localparam CNT_DDR_READS = 4;
    localparam CNT_DDR_WRITES = 5;
    localparam CNT_ACTIVE_CYCLES = 6;
    
    // æ›´æ–°è®¡æ•°å™¨
    always @(posedge clk) begin
        if (!rst_n) begin
            for (int i = 0; i < NUM_COUNTERS; i++)
                perf_counters[i] <= 0;
        end else begin
            // å‘¨æœŸè®¡æ•°
            perf_counters[CNT_CYCLES] <= perf_counters[CNT_CYCLES] + 1;
            
            // MACæ“ä½œè®¡æ•°
            if (mac_valid)
                perf_counters[CNT_MAC_OPS] <= perf_counters[CNT_MAC_OPS] + 1;
            
            // ç¼“å­˜ç»Ÿè®¡
            if (cache_hit)
                perf_counters[CNT_CACHE_HITS] <= perf_counters[CNT_CACHE_HITS] + 1;
            if (cache_miss)
                perf_counters[CNT_CACHE_MISSES] <= perf_counters[CNT_CACHE_MISSES] + 1;
            
            // DDRè®¿é—®ç»Ÿè®¡
            if (ddr_read_valid)
                perf_counters[CNT_DDR_READS] <= perf_counters[CNT_DDR_READS] + 1;
            if (ddr_write_valid)
                perf_counters[CNT_DDR_WRITES] <= perf_counters[CNT_DDR_WRITES] + 1;
            
            // æ´»è·ƒå‘¨æœŸç»Ÿè®¡
            if (|active_clusters)
                perf_counters[CNT_ACTIVE_CYCLES] <= perf_counters[CNT_ACTIVE_CYCLES] + 1;
        end
    end
    
    // æ€§èƒ½æŒ‡æ ‡è®¡ç®—
    reg [31:0] sample_counter;
    localparam SAMPLE_PERIOD = 1000000; // 1M cycles
    
    always @(posedge clk) begin
        if (!rst_n) begin
            sample_counter <= 0;
            ops_per_second <= 0;
            bandwidth_utilization <= 0;
            cache_hit_rate <= 0;
            power_efficiency <= 0;
        end else begin
            sample_counter <= sample_counter + 1;
            
            if (sample_counter == SAMPLE_PERIOD) begin
                sample_counter <= 0;
                
                // è®¡ç®—OPS (å‡è®¾1GHzæ—¶é’Ÿ)
                ops_per_second <= (perf_counters[CNT_MAC_OPS] * 1000);
                
                // å¸¦å®½åˆ©ç”¨ç‡ (å‡è®¾å³°å€¼16GB/sï¼Œæ¯æ¬¡ä¼ è¾“32B)
                bandwidth_utilization <= ((perf_counters[CNT_DDR_READS] + 
                                         perf_counters[CNT_DDR_WRITES]) * 32 * 100) / 
                                        (16 * SAMPLE_PERIOD / 1000);
                
                // ç¼“å­˜å‘½ä¸­ç‡
                if (perf_counters[CNT_CACHE_HITS] + perf_counters[CNT_CACHE_MISSES] > 0)
                    cache_hit_rate <= (perf_counters[CNT_CACHE_HITS] * 100) / 
                                     (perf_counters[CNT_CACHE_HITS] + 
                                      perf_counters[CNT_CACHE_MISSES]);
                
                // åŠŸè€—æ•ˆç‡ (GOPS/Wï¼Œå‡è®¾)
                power_efficiency <= ops_per_second / 5000; // å‡è®¾5WåŠŸè€—
                
                // é‡ç½®ç»Ÿè®¡è®¡æ•°å™¨
                for (int i = 1; i < NUM_COUNTERS; i++)
                    perf_counters[i] <= 0;
            end
        end
    end
    
    // è¯»å–è®¡æ•°å™¨
    always @(*) begin
        counter_value = perf_counters[counter_select];
    end
endmodule

// åŠŸèƒ½è¦†ç›–ç‡æ”¶é›†
class npu_coverage extends uvm_subscriber#(npu_transaction);
    `uvm_component_utils(npu_coverage)
    
    // è¦†ç›–ç‡ç»„
    covergroup operation_cg;
        // æ“ä½œç±»å‹è¦†ç›–
        op_type_cp: coverpoint trans.op_type {
            bins conv = {npu_transaction::CONV};
            bins fc = {npu_transaction::FC};
            bins pool = {npu_transaction::POOL};
            bins act = {npu_transaction::ACTIVATION};
        }
        
        // å·ç§¯æ ¸å¤§å°è¦†ç›–
        kernel_size_cp: coverpoint trans.kernel_size {
            bins small = {1};
            bins medium = {3};
            bins large = {5, 7};
        }
        
        // é€šé“æ•°è¦†ç›–
        channels_cp: coverpoint trans.input_channels {
            bins low = {[16:63]};
            bins medium = {[64:255]};
            bins high = {[256:512]};
        }
        
        // äº¤å‰è¦†ç›–
        op_kernel_cross: cross op_type_cp, kernel_size_cp {
            ignore_bins invalid = binsof(op_type_cp.fc) || 
                                 binsof(op_type_cp.pool);
        }
    endgroup
    
    // æ€§èƒ½è¦†ç›–
    covergroup performance_cg;
        // MACåˆ©ç”¨ç‡
        mac_utilization_cp: coverpoint get_mac_utilization() {
            bins low = {[0:25]};
            bins medium = {[26:75]};
            bins high = {[76:100]};
        }
        
        // å†…å­˜å¸¦å®½åˆ©ç”¨ç‡
        memory_bandwidth_cp: coverpoint get_memory_bandwidth() {
            bins low = {[0:30]};
            bins medium = {[31:70]};
            bins high = {[71:100]};
        }
    endgroup
    
    npu_transaction trans;
    
    function new(string name = "npu_coverage", uvm_component parent = null);
        super.new(name, parent);
        operation_cg = new();
        performance_cg = new();
    endfunction
    
    function void write(npu_transaction t);
        trans = t;
        operation_cg.sample();
        performance_cg.sample();
    endfunction
    
    function int get_mac_utilization();
        // ä»DUTè·å–MACåˆ©ç”¨ç‡
        return 80; // ç¤ºä¾‹å€¼
    endfunction
    
    function int get_memory_bandwidth();
        // ä»DUTè·å–å†…å­˜å¸¦å®½åˆ©ç”¨ç‡
        return 65; // ç¤ºä¾‹å€¼
    endfunction
endclass
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  4ï¼šéªŒè¯æ–¹æ¡ˆè®¾è®¡</h4>
                <p>è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„NPUéªŒè¯æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š</p>
                <ol>
                    <li>é’ˆå¯¹Transformeræ¨¡å‹çš„ä¸“ç”¨æµ‹è¯•åºåˆ—</li>
                    <li>å‹åŠ›æµ‹è¯•åœºæ™¯ï¼ŒéªŒè¯æé™æ€§èƒ½</li>
                    <li>åŠŸè€—éªŒè¯ç¯å¢ƒï¼Œç¡®ä¿æ»¡è¶³TDPè¦æ±‚</li>
                </ol>
                
                <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                <div class="answer">
                    <div class="code-block">
// Transformeræµ‹è¯•åºåˆ—
class transformer_test_sequence extends uvm_sequence#(npu_transaction);
    `uvm_object_utils(transformer_test_sequence)
    
    // Transformerå‚æ•°
    int seq_length = 512;
    int hidden_dim = 768;
    int num_heads = 12;
    int batch_size = 1;
    
    function new(string name = "transformer_test_sequence");
        super.new(name);
    endfunction
    
    task body();
        // ç”Ÿæˆè‡ªæ³¨æ„åŠ›æµ‹è¯•
        generate_self_attention_test();
        
        // ç”Ÿæˆå‰é¦ˆç½‘ç»œæµ‹è¯•
        generate_ffn_test();
        
        // ç”Ÿæˆå®Œæ•´Transformerå±‚æµ‹è¯•
        generate_full_transformer_test();
    endtask
    
    task generate_self_attention_test();
        npu_transaction tr;
        
        // Q, K, VçŸ©é˜µä¹˜æ³•
        repeat(3) begin
            tr = npu_transaction::type_id::create("tr");
            start_item(tr);
            
            assert(tr.randomize() with {
                op_type == npu_transaction::FC;
                input_height == seq_length;
                input_width == hidden_dim;
                input_channels == 1;
                output_height == seq_length;
                output_width == hidden_dim;
                output_channels == 1;
            });
            
            finish_item(tr);
        end
        
        // QK^TçŸ©é˜µä¹˜æ³•
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::FC;
            input_height == seq_length;
            input_width == hidden_dim / num_heads;
            output_height == seq_length;
            output_width == seq_length;
        });
        
        finish_item(tr);
        
        // Softmax (ä½¿ç”¨activationæ“ä½œ)
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::ACTIVATION;
            input_height == seq_length;
            input_width == seq_length;
        });
        
        finish_item(tr);
    endtask
    
    task generate_ffn_test();
        npu_transaction tr;
        
        // ç¬¬ä¸€ä¸ªçº¿æ€§å±‚ (æ‰©å±•ç»´åº¦)
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::FC;
            input_width == hidden_dim;
            output_width == hidden_dim * 4;
        });
        
        finish_item(tr);
        
        // GELUæ¿€æ´»
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::ACTIVATION;
            input_width == hidden_dim * 4;
        });
        
        finish_item(tr);
        
        // ç¬¬äºŒä¸ªçº¿æ€§å±‚ (å‹ç¼©ç»´åº¦)
        tr = npu_transaction::type_id::create("tr");
        start_item(tr);
        
        assert(tr.randomize() with {
            op_type == npu_transaction::FC;
            input_width == hidden_dim * 4;
            output_width == hidden_dim;
        });
        
        finish_item(tr);
    endtask
endclass

// å‹åŠ›æµ‹è¯•ç¯å¢ƒ
class stress_test extends uvm_test;
    `uvm_component_utils(stress_test)
    
    npu_env env;
    
    function new(string name = "stress_test", uvm_component parent = null);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        env = npu_env::type_id::create("env", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        stress_sequence seq;
        
        phase.raise_objection(this);
        
        // è¿è¡Œå‹åŠ›æµ‹è¯•åºåˆ—
        seq = stress_sequence::type_id::create("seq");
        seq.start(env.input_agent.sequencer);
        
        // ç­‰å¾…æ‰€æœ‰äº‹åŠ¡å®Œæˆ
        #100000ns;
        
        phase.drop_objection(this);
    endtask
endclass

// å‹åŠ›æµ‹è¯•åºåˆ—
class stress_sequence extends uvm_sequence#(npu_transaction);
    `uvm_object_utils(stress_sequence)
    
    function new(string name = "stress_sequence");
        super.new(name);
    endfunction
    
    task body();
        npu_transaction tr;
        
        // å¹¶å‘ç”Ÿæˆå¤šä¸ªå¤§è§„æ¨¡è®¡ç®—ä»»åŠ¡
        fork
            // çº¿ç¨‹1: å¤§å°ºå¯¸å·ç§¯
            begin
                repeat(50) begin
                    tr = npu_transaction::type_id::create("tr1");
                    start_item(tr);
                    assert(tr.randomize() with {
                        op_type == npu_transaction::CONV;
                        input_height == 224;
                        input_width == 224;
                        input_channels == 256;
                        output_channels == 512;
                        kernel_size == 3;
                    });
                    finish_item(tr);
                end
            end
            
            // çº¿ç¨‹2: å¤§è§„æ¨¡å…¨è¿æ¥
            begin
                repeat(30) begin
                    tr = npu_transaction::type_id::create("tr2");
                    start_item(tr);
                    assert(tr.randomize() with {
                        op_type == npu_transaction::FC;
                        input_width == 4096;
                        output_width == 4096;
                    });
                    finish_item(tr);
                end
            end
            
            // çº¿ç¨‹3: æ··åˆæ“ä½œ
            begin
                repeat(100) begin
                    tr = npu_transaction::type_id::create("tr3");
                    start_item(tr);
                    assert(tr.randomize());
                    finish_item(tr);
                end
            end
        join
    endtask
endclass

// åŠŸè€—éªŒè¯æ¨¡å—
module PowerVerification #(
    parameter VOLTAGE_LEVELS = 8,
    parameter FREQ_LEVELS = 8
)(
    input wire clk,
    input wire rst_n,
    
    // DUTåŠŸè€—ç›¸å…³ä¿¡å·
    input wire [2:0] voltage_level,
    input wire [2:0] frequency_level,
    input wire [3:0] active_clusters,
    input wire [15:0] mac_activity,
    input wire [15:0] memory_activity,
    
    // åŠŸè€—æµ‹é‡
    output reg [31:0] instant_power_mw,
    output reg [31:0] average_power_mw,
    output reg [31:0] peak_power_mw,
    output reg tdp_violation
);
    
    // åŠŸè€—æŸ¥æ‰¾è¡¨ (mW)
    reg [15:0] voltage_power_table [VOLTAGE_LEVELS-1:0];
    reg [15:0] frequency_power_table [FREQ_LEVELS-1:0];
    
    // åˆå§‹åŒ–åŠŸè€—è¡¨
    initial begin
        // ç”µå‹åŠŸè€—è¡¨ (äºŒæ¬¡å…³ç³»)
        voltage_power_table[0] = 500;   // 0.6V
        voltage_power_table[1] = 800;   // 0.65V
        voltage_power_table[2] = 1200;  // 0.7V
        voltage_power_table[3] = 1700;  // 0.75V
        voltage_power_table[4] = 2300;  // 0.8V
        voltage_power_table[5] = 3000;  // 0.85V
        voltage_power_table[6] = 3800;  // 0.9V
        voltage_power_table[7] = 4700;  // 0.95V
        
        // é¢‘ç‡åŠŸè€—è¡¨ (çº¿æ€§å…³ç³»)
        frequency_power_table[0] = 100;   // 250MHz
        frequency_power_table[1] = 200;   // 500MHz
        frequency_power_table[2] = 300;   // 625MHz
        frequency_power_table[3] = 400;   // 750MHz
        frequency_power_table[4] = 500;   // 875MHz
        frequency_power_table[5] = 600;   // 1000MHz
        frequency_power_table[6] = 700;   // 1125MHz
        frequency_power_table[7] = 800;   // 1250MHz
    end
    
    // è®¡ç®—ç¬æ—¶åŠŸè€—
    reg [31:0] static_power, dynamic_power;
    reg [31:0] compute_power, memory_power;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            instant_power_mw <= 0;
            static_power <= 0;
            dynamic_power <= 0;
        end else begin
            // é™æ€åŠŸè€—
            static_power = voltage_power_table[voltage_level] * active_clusters / 4;
            
            // åŠ¨æ€åŠŸè€—
            compute_power = (mac_activity * frequency_power_table[frequency_level]) >> 8;
            memory_power = (memory_activity * voltage_power_table[voltage_level]) >> 10;
            dynamic_power = compute_power + memory_power;
            
            // æ€»åŠŸè€—
            instant_power_mw <= static_power + dynamic_power;
        end
    end
    
    // è®¡ç®—å¹³å‡åŠŸè€—
    reg [39:0] power_accumulator;
    reg [31:0] sample_count;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            power_accumulator <= 0;
            sample_count <= 0;
            average_power_mw <= 0;
            peak_power_mw <= 0;
        end else begin
            power_accumulator <= power_accumulator + instant_power_mw;
            sample_count <= sample_count + 1;
            
            // æ¯1000ä¸ªå‘¨æœŸæ›´æ–°å¹³å‡å€¼
            if (sample_count[9:0] == 0) begin
                average_power_mw <= power_accumulator / 1000;
                power_accumulator <= 0;
            end
            
            // æ›´æ–°å³°å€¼
            if (instant_power_mw > peak_power_mw) begin
                peak_power_mw <= instant_power_mw;
            end
        end
    end
    
    // TDPè¿è§„æ£€æµ‹
    localparam TDP_LIMIT_MW = 5000; // 5W TDP
    
    always @(posedge clk) begin
        if (!rst_n) begin
            tdp_violation <= 0;
        end else begin
            tdp_violation <= (average_power_mw > TDP_LIMIT_MW);
        end
    end
    
    // æ–­è¨€æ£€æŸ¥
    // synthesis translate_off
    property tdp_check;
        @(posedge clk) disable iff (!rst_n)
        average_power_mw <= TDP_LIMIT_MW;
    endproperty
    
    assert property(tdp_check) else
        $error("TDP violation: average power %0d mW exceeds limit %0d mW", 
               average_power_mw, TDP_LIMIT_MW);
    
    property power_state_transition;
        @(posedge clk) disable iff (!rst_n)
        ($changed(voltage_level) || $changed(frequency_level)) |-> 
        ##[1:100] $stable(instant_power_mw);
    endproperty
    
    assert property(power_state_transition) else
        $error("Power state transition not stable");
    // synthesis translate_on
endmodule
                    </div>
                    <p><strong>è§£æï¼š</strong></p>
                    <ul>
                        <li>Transformeræµ‹è¯•åºåˆ—è¦†ç›–äº†è‡ªæ³¨æ„åŠ›ã€å‰é¦ˆç½‘ç»œç­‰å…³é”®æ“ä½œ</li>
                        <li>å‹åŠ›æµ‹è¯•é€šè¿‡å¹¶å‘æ‰§è¡Œå¤šç§å¤§è§„æ¨¡è®¡ç®—ä»»åŠ¡ï¼ŒéªŒè¯NPUæé™æ€§èƒ½</li>
                        <li>åŠŸè€—éªŒè¯æ¨¡å—å®æ—¶ç›‘æµ‹ç¬æ—¶åŠŸè€—ã€å¹³å‡åŠŸè€—å’Œå³°å€¼åŠŸè€—</li>
                        <li>åŒ…å«TDPè¿è§„æ£€æµ‹å’ŒåŠŸè€—çŠ¶æ€è½¬æ¢çš„æ–­è¨€æ£€æŸ¥</li>
                        <li>é€šè¿‡æŸ¥æ‰¾è¡¨æ¨¡æ‹Ÿä¸åŒç”µå‹é¢‘ç‡ä¸‹çš„åŠŸè€—ç‰¹æ€§</li>
                    </ul>
                </div>
            </div>

            <h3>12.4 ç»¼åˆä¸åç«¯å®ç°</h3>
            
            <p>æœ¬èŠ‚å°†ä»‹ç»NPUçš„é€»è¾‘ç»¼åˆã€ç‰©ç†è®¾è®¡å’Œåç«¯å®ç°æµç¨‹ã€‚</p>

            <h4>12.4.1 é€»è¾‘ç»¼åˆ</h4>
            <div class="code-block">
# æ”¹è¿›çš„Design Compilerç»¼åˆè„šæœ¬ - æ›´æ¥è¿‘å·¥ä¸šå®è·µ
# npu_synthesis_enhanced.tcl

# è®¾ç½®åº“è·¯å¾„å’Œå·¥è‰ºåº“
set TECH_NODE "16nm"
set search_path ". /tools/libraries/$TECH_NODE ./rtl ./include"
set target_library "${TECH_NODE}_hvt.db ${TECH_NODE}_svt.db ${TECH_NODE}_lvt.db"
set link_library "* $target_library"
set symbol_library "${TECH_NODE}.sdb"

# è®¾ç½®TLU+æ–‡ä»¶ç”¨äºç²¾ç¡®çš„RCæå–
set_tlu_plus_files -max_tluplus /tools/libraries/$TECH_NODE/tluplus/maxTLU+ \
                   -min_tluplus /tools/libraries/$TECH_NODE/tluplus/minTLU+ \
                   -tech2itf_map /tools/libraries/$TECH_NODE/tech2itf.map

# è¯»å–è®¾è®¡æ–‡ä»¶
set RTL_LIST {
    ./rtl/npu_top.v
    ./rtl/compute_cluster.v
    ./rtl/pe_array.v
    ./rtl/memory_system.v
    ./rtl/noc_router.v
    ./rtl/sparse_accelerator.v
    ./rtl/power_management.v
}

analyze -format verilog $RTL_LIST
elaborate EdgeNPU_Top -parameters "NUM_CLUSTERS=4,MACS_PER_CLUSTER=512"
current_design EdgeNPU_Top
link

# æ£€æŸ¥è®¾è®¡ä¸€è‡´æ€§
check_design -summary
report_design > reports/design_check.rpt

# ===========================================
# æ—¶åºçº¦æŸ - å¤šæ¨¡å¼å¤šè§’(MMMC)
# ===========================================

# ä¸»æ—¶é’Ÿå®šä¹‰
create_clock -period 1.0 -name sys_clk [get_ports clk]
create_clock -period 0.8 -name noc_clk [get_ports noc_clk]

# æ—¶é’Ÿä¸ç¡®å®šæ€§ - è€ƒè™‘æŠ–åŠ¨å’Œåç§»
set_clock_uncertainty -setup 0.05 [get_clocks sys_clk]
set_clock_uncertainty -hold 0.03 [get_clocks sys_clk]
set_clock_transition 0.08 [get_clocks sys_clk]

# è™šæ‹Ÿæ—¶é’Ÿç”¨äºDFT
create_clock -period 10.0 -name test_clk [get_ports test_clk]

# è¾“å…¥è¾“å‡ºå»¶è¿Ÿ - åŸºäºç³»ç»Ÿçº§æ—¶åºé¢„ç®—
# è¾“å…¥å»¶è¿Ÿ = Tco(ä¸Šæ¸¸èŠ¯ç‰‡) + Tpcb(æ¿çº§èµ°çº¿) + Tmargin
set INPUT_DELAY_MAX 0.3
set INPUT_DELAY_MIN 0.1
set_input_delay -clock sys_clk -max $INPUT_DELAY_MAX [remove_from_collection [all_inputs] [get_ports {clk rst_n}]]
set_input_delay -clock sys_clk -min $INPUT_DELAY_MIN [remove_from_collection [all_inputs] [get_ports {clk rst_n}]]

# è¾“å‡ºå»¶è¿Ÿ = Tsu(ä¸‹æ¸¸èŠ¯ç‰‡) + Tpcb + Tmargin  
set OUTPUT_DELAY_MAX 0.25
set OUTPUT_DELAY_MIN 0.05
set_output_delay -clock sys_clk -max $OUTPUT_DELAY_MAX [all_outputs]
set_output_delay -clock sys_clk -min $OUTPUT_DELAY_MIN [all_outputs]

# å¼‚æ­¥è·¯å¾„å’Œå¤šå‘¨æœŸè·¯å¾„
set_false_path -from [get_clocks sys_clk] -to [get_clocks noc_clk]
set_false_path -from [get_clocks noc_clk] -to [get_clocks sys_clk]
set_false_path -from [get_ports rst_n] -to [all_registers]

# MACé˜µåˆ—çš„å¤šå‘¨æœŸè·¯å¾„
set_multicycle_path -setup 2 -from [get_pins mac_array/*/mult_reg*] -to [get_pins mac_array/*/acc_reg*]
set_multicycle_path -hold 1 -from [get_pins mac_array/*/mult_reg*] -to [get_pins mac_array/*/acc_reg*]

# è®¾ç½®é¢ç§¯å’ŒåŠŸè€—çº¦æŸ
set_max_area 25000000  # 25mmÂ²
set_max_dynamic_power 3.0  # 3WåŠ¨æ€åŠŸè€—
set_max_leakage_power 0.5  # 0.5Wæ³„æ¼åŠŸè€—

# å¤šé˜ˆå€¼ç”µå‹ä¼˜åŒ–
set_multi_vth_constraint -lvth_percentage 10 \
                        -hvth_percentage 60

# æ—¶é’Ÿé—¨æ§æ’å…¥
set_clock_gating_style -sequential_cell latch \
                      -positive_edge_logic {and} \
                      -negative_edge_logic {or} \
                      -control_point before \
                      -control_signal scan_enable

insert_clock_gating

# è®¾ç½®ä¼˜åŒ–ç­–ç•¥
set_optimize_registers true
set_boundary_optimization true
set compile_ultra_ungroup_dw false

# ===========================================
# ç»¼åˆç­–ç•¥å’Œä¼˜åŒ–
# ===========================================

# å¯ç”¨é«˜çº§ä¼˜åŒ–é€‰é¡¹
set_app_var compile_enable_register_merging true
set_app_var compile_seqmap_enable_output_inversion true
set_app_var placer_channel_detect_mode true

# æ—¶åºé©±åŠ¨ç»¼åˆé…ç½®
set_app_var compile_timing_high_effort true
set_app_var psynopt_area_recovery_high_effort true

# å¼€å§‹ç»¼åˆ - åˆ†é˜¶æ®µè¿›è¡Œ
echo "========== Starting Synthesis =========="
date

# ç¬¬ä¸€é˜¶æ®µï¼šé«˜çº§ç»¼åˆ
compile_ultra -no_autoungroup -no_boundary_optimization

# ç¬¬äºŒé˜¶æ®µï¼šå¯„å­˜å™¨ä¼˜åŒ–
optimize_registers -print_critical_loop

# ç¬¬ä¸‰é˜¶æ®µï¼šå¢é‡ä¼˜åŒ–
compile_ultra -incremental -scan

# ===========================================
# DFTæ’å…¥
# ===========================================

# è®¾ç½®DFTé…ç½®
set_dft_configuration -scan_style muxed_scan \
                     -test_mode_port test_mode \
                     -scan_enable_port scan_enable

# å®šä¹‰æ‰«æé“¾
set_scan_configuration -chain_count 16 \
                      -clock_mixing mix_clocks \
                      -add_lockup true \
                      -test_mode test_mode

# æ’å…¥DFTç»“æ„
insert_dft

# ===========================================
# æœ€ç»ˆä¼˜åŒ–å’ŒæŠ¥å‘Š
# ===========================================

# æœ€ç»ˆæ—¶åºä¼˜åŒ–
optimize_netlist -area

# ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
echo "========== Generating Reports =========="

# æ—¶åºæŠ¥å‘Š
report_timing -delay_type max -nworst 1 -max_paths 100 -sort_by group > reports/setup_timing.rpt
report_timing -delay_type min -nworst 1 -max_paths 100 -sort_by group > reports/hold_timing.rpt
report_clock -skew -attribute > reports/clock_report.rpt

# é¢ç§¯å’ŒåŠŸè€—æŠ¥å‘Š  
report_area -hierarchy -physical > reports/area_physical.rpt
report_power -analysis_effort high -verbose > reports/power_analysis.rpt
report_saif > reports/switching_activity.rpt

# çº¦æŸè¿ä¾‹æŠ¥å‘Š
report_constraint -all_violators -verbose > reports/all_violations.rpt
report_timing -loops > reports/timing_loops.rpt

# QoRæŠ¥å‘Š
report_qor > reports/qor_summary.rpt

# DFTæŠ¥å‘Š
report_dft > reports/dft_summary.rpt
report_scan_chain > reports/scan_chains.rpt

# ===========================================
# è¾“å‡ºæ–‡ä»¶
# ===========================================

# ä¿å­˜è®¾è®¡
write_file -format ddc -hierarchy -output results/npu_top.ddc

# è¾“å‡ºç½‘è¡¨
change_names -rules verilog -hierarchy
write_file -format verilog -hierarchy -output netlists/npu_top_synth.v

# è¾“å‡ºçº¦æŸ
write_sdc -nosplit constraints/npu_top_final.sdc

# è¾“å‡ºå»¶è¿Ÿæ–‡ä»¶
write_sdf delays/npu_top_max.sdf -context verilog
write_sdf delays/npu_top_min.sdf -context verilog -min_view

# è¾“å‡ºå½¢å¼éªŒè¯æ–‡ä»¶
set_svf -off

date
echo "========== Synthesis Complete =========="
            </div>

            <h4>12.4.2 ç‰©ç†è®¾è®¡</h4>
            <div class="code-block">
# æ”¹è¿›çš„Innovusç‰©ç†è®¾è®¡è„šæœ¬ - å¤šæ¨¡å¼å¤šè§’(MMMC)å’Œè¿­ä»£ä¼˜åŒ–
# npu_physical_design_enhanced.tcl

# ===========================================
# MMMCè®¾ç½®
# ===========================================

# å®šä¹‰å·¥è‰ºè§’
create_library_set -name SS_125C -timing {/tools/libs/16nm/ss_125c.lib} \
                   -si {/tools/libs/16nm/ss_125c.cdb}
create_library_set -name TT_25C -timing {/tools/libs/16nm/tt_25c.lib} \
                   -si {/tools/libs/16nm/tt_25c.cdb}  
create_library_set -name FF_M40C -timing {/tools/libs/16nm/ff_m40c.lib} \
                   -si {/tools/libs/16nm/ff_m40c.cdb}

# å®šä¹‰RCè§’
create_rc_corner -name RC_worst -cap_table /tools/tech/16nm/capTbl_worst \
                 -T 125 -preRoute_res 1.2 -preRoute_cap 1.2 \
                 -postRoute_res 1.2 -postRoute_cap 1.2
create_rc_corner -name RC_typ -cap_table /tools/tech/16nm/capTbl_typ \
                 -T 25 -preRoute_res 1 -preRoute_cap 1 \
                 -postRoute_res 1 -postRoute_cap 1
create_rc_corner -name RC_best -cap_table /tools/tech/16nm/capTbl_best \
                 -T -40 -preRoute_res 0.8 -preRoute_cap 0.8 \
                 -postRoute_res 0.8 -postRoute_cap 0.8

# å®šä¹‰å»¶è¿Ÿè§’
create_delay_corner -name DC_max -library_set SS_125C -rc_corner RC_worst
create_delay_corner -name DC_typ -library_set TT_25C -rc_corner RC_typ  
create_delay_corner -name DC_min -library_set FF_M40C -rc_corner RC_best

# å®šä¹‰çº¦æŸæ¨¡å¼
create_constraint_mode -name FUNC -sdc_files {./constraints/npu_func.sdc}
create_constraint_mode -name TEST -sdc_files {./constraints/npu_test.sdc}

# å®šä¹‰åˆ†æè§†å›¾
create_analysis_view -name av_func_max -constraint_mode FUNC -delay_corner DC_max
create_analysis_view -name av_func_typ -constraint_mode FUNC -delay_corner DC_typ
create_analysis_view -name av_func_min -constraint_mode FUNC -delay_corner DC_min
create_analysis_view -name av_test_max -constraint_mode TEST -delay_corner DC_max

set_analysis_view -setup {av_func_max av_test_max} -hold {av_func_min}

# ===========================================
# è®¾è®¡åˆå§‹åŒ–
# ===========================================

# è¯»å–è®¾è®¡
init_design -netlist ./netlists/npu_top_synth.v \
           -top EdgeNPU_Top \
           -lef {/tools/tech/16nm/tech.lef /tools/libs/16nm/cells.lef} \
           -mmmc_file ./scripts/mmmc.tcl \
           -powerNet {VDD} \
           -groundNet {VSS}

# å…¨å±€å˜é‡è®¾ç½®
setDesignMode -process 16
setUsefulSkew true
setOptMode -usefulSkew true -preserveAllSequential false
setNanoRouteMode -routeInsertAntennaDiode true -routeAntennaCellName ANTENNA

# ===========================================
# Floorplanè§„åˆ’
# ===========================================

# è®¡ç®—èŠ¯ç‰‡å°ºå¯¸ - åŸºäºåˆ©ç”¨ç‡å’Œé¢ç§¯ä¼°ç®—
set CORE_UTILIZATION 0.7
set CORE_ASPECT_RATIO 1.0
set CORE_MARGIN 10

floorPlan -site core_site -r $CORE_ASPECT_RATIO $CORE_UTILIZATION \
          $CORE_MARGIN $CORE_MARGIN $CORE_MARGIN $CORE_MARGIN

# åˆ›å»ºç”µå‹åŸŸ
createVoltageArea -name CORE_PD -coordinate {500 500 4500 4500} \
                  -powerDomain PD_CORE -netNames {VDD VSS}
createVoltageArea -name AON_PD -coordinate {100 100 500 4900} \
                  -powerDomain PD_AON -netNames {VDDAON VSSAON}

# SRAMå®å•å…ƒçš„è‡ªåŠ¨åŒ–å¸ƒå±€
# å®šä¹‰å®å•å…ƒåˆ—è¡¨
set sram_macros [get_cells -hierarchical -filter "ref_name=~SRAM*"]

# åˆ›å»ºMacroæ”¾ç½®ç»„ - ç¡®ä¿å¯¹é½å’Œé—´è·
createMacroArray -macros $sram_macros \
                 -rows 2 -cols 2 \
                 -xSpace 100 -ySpace 100 \
                 -site core_site

# ä¸ºSRAMåˆ›å»ºæ¡†åŒºå’ŒHalo
foreach macro $sram_macros {
    createHaloFromPin -allBlock -topleft 20 20 -bottomright 20 20
    createRouteBlk -layer {M1 M2 M3} -box [getObjBBox $macro] -exceptPGNet
}

# è®¡ç®—ç°‡çš„åˆ†åŒºè§„åˆ’
set cluster_width 800
set cluster_height 800
set cluster_spacing 50

for {set i 0} {$i < 4} {incr i} {
    set x [expr 1000 + $i * ($cluster_width + $cluster_spacing)]
    set y 1000
    
    createRegion cluster_${i}_region $x $y \
                 [expr $x + $cluster_width] [expr $y + $cluster_height]
    
    assignInstToRegion [get_cells compute_cluster_${i}/*] cluster_${i}_region
    
    # ä¸ºæ¯ä¸ªç°‡è®¾ç½®å¯†åº¦çº¦æŸ
    setPlaceMode -region cluster_${i}_region -density 0.85
}

# IOè§„åˆ’
loadIoFile ./scripts/io_assignment.io

# ===========================================
# ç”µæºè§„åˆ’ - è€ƒè™‘åŠŸè€—å¯†åº¦å’ŒIR Drop
# ===========================================

# è®¡ç®—ç”µæºéœ€æ±‚
set POWER_BUDGET 5.0 ;# 5W TDP
set VDD_VOLTAGE 0.8  ;# 0.8V
set CURRENT_TOTAL [expr $POWER_BUDGET / $VDD_VOLTAGE]
set IR_DROP_TARGET 0.05 ;# 5% IR drop

# å…¨å±€ç”µæºç½‘æ ¼åˆ›å»º
# ç”µæºç¯ - é¡¶å±‚é‡‘å±
addRing -nets {VDD VSS} -type core_rings \
        -layer {top M9 bottom M9 left M10 right M10} \
        -width {top 30 bottom 30 left 30 right 30} \
        -spacing {top 10 bottom 10 left 10 right 10} \
        -offset {top 5 bottom 5 left 5 right 5} \
        -center 1

# åˆ†å±‚ç”µæºæ¡å¸¦è§„åˆ’
# M10 - ä¸»è¦æ°´å¹³ç”µæºæ¡å¸¦
addStripe -nets {VDD VSS} -layer M10 -direction horizontal \
          -width 20 -spacing 10 -set_to_set_distance 200 \
          -start_offset 100 -stop_offset 100 \
          -extend_to design_boundary

# M9 - ä¸»è¦å‚ç›´ç”µæºæ¡å¸¦  
addStripe -nets {VDD VSS} -layer M9 -direction vertical \
          -width 20 -spacing 10 -set_to_set_distance 200 \
          -start_offset 100 -stop_offset 100 \
          -extend_to design_boundary

# M8 - æ¬¡çº§æ°´å¹³ç”µæºæ¡å¸¦
addStripe -nets {VDD VSS} -layer M8 -direction horizontal \
          -width 10 -spacing 5 -set_to_set_distance 100 \
          -start_offset 50 -stop_offset 50 \
          -extend_to design_boundary

# é’ˆå¯¹é«˜åŠŸè€—åŒºåŸŸçš„åŠ å¯†ç”µæºç½‘æ ¼
# MACé˜µåˆ—åŒºåŸŸ - éœ€è¦æ›´å¯†é›†çš„ç”µæºç½‘æ ¼
foreach region [get_db regions cluster_*_region] {
    selectInst [get_db $region .insts]
    
    addStripe -nets {VDD VSS} -layer M7 -direction vertical \
              -width 5 -spacing 2.5 -set_to_set_distance 25 \
              -area [get_db $region .bbox]
    
    addStripe -nets {VDD VSS} -layer M6 -direction horizontal \
              -width 5 -spacing 2.5 -set_to_set_distance 25 \
              -area [get_db $region .bbox]
}

# Viaé˜µåˆ—ä¼˜åŒ– - å‡å°‘å±‚é—´ç”µé˜»
setViaGenMode -optimize_cross_via true \
              -optimize_via_on_routing_track true \
              -viarule_preference generated

# æ ‡å‡†å•å…ƒç”µæºè½¨è¿æ¥
sroute -connect {blockPin padPin corePin floatingStripe} \
       -layerChangeRange {M1 M10} \
       -blockPinTarget {nearestTarget} \
       -deleteExistingRoutes \
       -allowJogging 1 \
       -crossoverViaLayerRange {M1 M10} \
       -allowLayerChange 1 \
       -nets {VDD VSS}

# ç”µæºåˆ†æ
analyzeRail -type ir
report_rail -type ir > reports/ir_drop_initial.rpt

# æ ‡å‡†å•å…ƒç”µæºè½¨
sroute -connect {blockPin padPin padRing corePin floatingStripe} \
       -layerChangeRange {M1 M10} -blockPinTarget {nearestTarget} \
       -padPinPortConnect {allPort oneGeom} -padPinTarget {nearestTarget} \
       -corePinTarget {firstAfterRowEnd} -floatingStripeTarget {blockring padring ring stripe ringpin blockpin followpin} \
       -allowJogging 1 -crossoverViaLayerRange {M1 M10} \
       -nets {VDD VSS}

# ===========================================
# å¸ƒå±€ä¼˜åŒ– - è¿­ä»£å¼
# ===========================================

# å¸ƒå±€å‰è®¾ç½®
setPlaceMode -reset
setPlaceMode -congEffort high \
             -timingDriven true \
             -modulePlan true \
             -clkGateAware true \
             -powerDriven true \
             -ignoreScan false \
             -reorderScan true \
             -ignoreSpare false \
             -placeIOPins false \
             -moduleAwareSpare true \
             -preserveRouting false \
             -rmAffectedRouting false \
             -checkRoute false \
             -swapEEQ false

# è®¾ç½®å¸ƒå±€å¯†åº¦ç›®æ ‡
setPlaceMode -uniformDensity true -maxDensity 0.85

# é˜¶æ®µ1ï¼šå…¨å±€å¸ƒå±€
place_global_opt

# æ‹¥å¡åˆ†æ
reportCongestion -hotSpot -overflow -includeBlockage > reports/congestion_global.rpt

# é˜¶æ®µ2ï¼šè¯¦ç»†å¸ƒå±€
setOptMode -fixCap true -fixTran true -fixFanoutLoad true
placeDesign -incremental -timingDriven

# é˜¶æ®µ3ï¼šå¸ƒå±€åä¼˜åŒ–
optDesign -prePlaceOpt

# æ‰«æé“¾é‡æ’
scanReorder

# ===========================================
# æ—¶é’Ÿæ ‘ç»¼åˆ(CTS) - ä½¿ç”¨CCOpt
# ===========================================

# è®¾ç½®CCOpté€‰é¡¹
set_ccopt_property buffer_cells {CKBUF_X16M CKBUF_X20M CKBUF_X24M}
set_ccopt_property inverter_cells {CKINV_X16M CKINV_X20M CKINV_X24M}
set_ccopt_property clock_gating_cells {CKLHQD_X2M CKLHQD_X4M}
set_ccopt_property target_skew 0.02
set_ccopt_property target_insertion_delay 0.3

# åˆ›å»ºæ—¶é’Ÿæ ‘è§„èŒƒ
create_ccopt_clock_tree_spec -file ccopt.spec \
                             -immediate

# è®¾ç½®æ—¶é’Ÿæ ‘çº¦æŸ
set_ccopt_property -clock_tree sys_clk routing_rule clk_rule
set_ccopt_property -clock_tree sys_clk max_fanout 32
set_ccopt_property -clock_tree sys_clk max_transition 0.08

# æ‰§è¡ŒCTS
ccopt_design -cts

# CTSåæŠ¥å‘Š
report_ccopt_clock_trees -summary > reports/cts_summary.rpt
report_ccopt_skew_groups > reports/cts_skew.rpt

# ===========================================
# åCTSä¼˜åŒ–
# ===========================================

# ä¿®å¤ä¿æŒæ—¶é—´è¿ä¾‹
optDesign -postCTS -hold

# æœ‰ç”¨åç§»ä¼˜åŒ–
setOptMode -usefulSkew true
optDesign -postCTS -setup

# å¸ƒçº¿
setNanoRouteMode -quiet -timingEngine {}
setNanoRouteMode -quiet -routeWithTimingDriven 1
setNanoRouteMode -quiet -routeWithSiDriven 1
setNanoRouteMode -quiet -routeTopRoutingLayer 10
setNanoRouteMode -quiet -routeBottomRoutingLayer 1
setNanoRouteMode -quiet -drouteEndIteration 10
setNanoRouteMode -quiet -routeWithTimingDriven true
setNanoRouteMode -quiet -routeWithSiDriven true

routeDesign -globalDetail

# åå¸ƒçº¿ä¼˜åŒ–
optDesign -postRoute -hold

# å¡«å……å•å…ƒæ’å…¥
addFiller -cell {FILL1 FILL2 FILL4 FILL8} -prefix FILLER

# DRC/LVSä¿®å¤
fixVia -minCut
fixMetalFill

# SIåˆ†æå’Œä¿®å¤
setDelayCalMode -engine default -siAware true
setAnalysisMode -analysisType onChipVariation
timeDesign -postRoute -pathReports -drvReports -slackReports -numPaths 50 -prefix postRoute -outDir timingReports

# åŠŸè€—åˆ†æ
report_power -outfile reports/final_power.rpt

# è¾“å‡ºè®¾è®¡
saveDesign final_design.enc
defOut -floorplan -netlist -routing npu_final.def
            </div>

            <h4>12.4.3 æ—¶åºæ”¶æ•›ä¸ç­¾æ ¸</h4>
            <div class="code-block">
# PrimeTimeæ—¶åºç­¾æ ¸è„šæœ¬
# timing_signoff.tcl

# è¯»å–è®¾è®¡
read_verilog ./netlists/npu_final.v
current_design EdgeNPU_Top
link_design

# è¯»å–å¯„ç”Ÿå‚æ•°
read_parasitics -format SPEF ./spef/npu_final.spef

# è®¾ç½®æ“ä½œæ¡ä»¶
set_operating_conditions -analysis_type on_chip_variation

# å®šä¹‰æ—¶é’Ÿ
create_clock -period 1.0 [get_ports clk]
set_clock_uncertainty -setup 0.05 [get_clocks clk]
set_clock_uncertainty -hold 0.03 [get_clocks clk]
set_clock_transition 0.08 [get_clocks clk]

# AOCVè®¾ç½®
set_aocvm_mode manual
read_aocvm 16nm_aocvm.table

# CPPRåˆ†æ
set timing_remove_clock_reconvergence_pessimism true

# å¤šæ¨¡å¼å¤šè§’åˆ†æ
# å®šä¹‰è§’
create_scenario -name func_ss_125c
set_operating_conditions SS_125C
set_voltage 0.72 -object_list VDD

create_scenario -name func_ff_m40c
set_operating_conditions FF_M40C
set_voltage 0.88 -object_list VDD

# æ‰§è¡Œæ—¶åºåˆ†æ
update_timing -full
report_timing -delay_type max -nworst 1 -max_paths 1000 > timing_setup.rpt
report_timing -delay_type min -nworst 1 -max_paths 1000 > timing_hold.rpt

# æ—¶åºè¿è§„åˆ†æ
report_constraint -all_violators > violations.rpt

# åŠŸè€—åˆ†æ
set power_enable_analysis true
set power_analysis_mode averaged

read_saif ./saif/npu_vectors.saif -strip_path testbench/dut
update_power
report_power -hierarchy > power_signoff.rpt

# ECOä¿®å¤è„šæœ¬ç”Ÿæˆ
write_changes -format icctcl -output eco_fixes.tcl

# æ—¶åºæ¨¡å‹ç”Ÿæˆ
extract_model -output ./models/npu_timing.lib -format liberty \
              -timing -power -test

# ç”Ÿæˆæœ€ç»ˆæŠ¥å‘Š
report_design > design_summary.rpt
report_clock_timing -type summary > clock_summary.rpt
report_analysis_coverage > coverage.rpt
            </div>

            <h4>12.4.4 DFTä¸å¯æµ‹è¯•æ€§è®¾è®¡</h4>
            <div class="code-block">
// DFTæ§åˆ¶å™¨
module DFTController (
    input wire clk,
    input wire rst_n,
    
    // æµ‹è¯•æ¨¡å¼æ§åˆ¶
    input wire test_mode,
    input wire scan_enable,
    input wire mbist_mode,
    
    // æ‰«æé“¾æ¥å£
    input wire scan_in,
    output wire scan_out,
    
    // MBISTæ¥å£
    output wire mbist_start,
    output wire mbist_done,
    output wire mbist_fail,
    
    // JTAGæ¥å£
    input wire tck,
    input wire tms,
    input wire tdi,
    output wire tdo,
    input wire trst_n
);
    
    // æ‰«æé“¾é…ç½®
    localparam NUM_SCAN_CHAINS = 16;
    localparam SCAN_LENGTH = 10000;
    
    // æ‰«æé“¾å¤šè·¯å¤ç”¨
    wire [NUM_SCAN_CHAINS-1:0] chain_scan_in;
    wire [NUM_SCAN_CHAINS-1:0] chain_scan_out;
    
    // æ‰«æé“¾åˆ†é…
    genvar i;
    generate
        for (i = 0; i < NUM_SCAN_CHAINS; i = i + 1) begin : scan_chain
            assign chain_scan_in[i] = (i == 0) ? scan_in : chain_scan_out[i-1];
        end
    endgenerate
    assign scan_out = chain_scan_out[NUM_SCAN_CHAINS-1];
    
    // MBISTæ§åˆ¶å™¨
    MBISTController #(
        .NUM_MEMORIES(32),
        .ADDR_WIDTH(18),
        .DATA_WIDTH(256)
    ) mbist_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .mbist_mode(mbist_mode),
        .start(mbist_start),
        .done(mbist_done),
        .fail(mbist_fail),
        // å†…å­˜æ¥å£è¿æ¥
        .mem_en(),
        .mem_we(),
        .mem_addr(),
        .mem_wdata(),
        .mem_rdata()
    );
    
    // JTAG TAPæ§åˆ¶å™¨
    JTAGController jtag_ctrl (
        .tck(tck),
        .tms(tms),
        .tdi(tdi),
        .tdo(tdo),
        .trst_n(trst_n),
        // å†…éƒ¨å¯„å­˜å™¨è®¿é—®
        .reg_addr(),
        .reg_data(),
        .reg_we()
    );
    
    // ATPGæµ‹è¯•ç‚¹æ’å…¥
    // æé«˜å¯æµ‹è¯•æ€§çš„è§‚å¯Ÿç‚¹å’Œæ§åˆ¶ç‚¹
    reg [31:0] test_point_observe;
    reg [31:0] test_point_control;
    
    always @(posedge clk) begin
        if (test_mode) begin
            // åœ¨æµ‹è¯•æ¨¡å¼ä¸‹æ¿€æ´»æµ‹è¯•ç‚¹
            test_point_observe <= internal_hard_to_observe_signals;
            internal_hard_to_control_signals <= test_point_control;
        end
    end
endmodule

// MBISTç®—æ³•å®ç°
module MBISTController #(
    parameter NUM_MEMORIES = 32,
    parameter ADDR_WIDTH = 18,
    parameter DATA_WIDTH = 256
)(
    input wire clk,
    input wire rst_n,
    input wire mbist_mode,
    input wire start,
    output reg done,
    output reg fail,
    
    // å†…å­˜æ¥å£
    output reg [NUM_MEMORIES-1:0] mem_en,
    output reg [NUM_MEMORIES-1:0] mem_we,
    output reg [ADDR_WIDTH-1:0] mem_addr,
    output reg [DATA_WIDTH-1:0] mem_wdata,
    input wire [DATA_WIDTH-1:0] mem_rdata [NUM_MEMORIES-1:0]
);
    
    // MBISTçŠ¶æ€æœº
    typedef enum logic [3:0] {
        IDLE,
        MARCH_C_W0,    // March C- Write 0
        MARCH_C_R0W1,  // March C- Read 0, Write 1
        MARCH_C_R1W0,  // March C- Read 1, Write 0
        MARCH_C_R0,    // March C- Read 0
        CHECKERBOARD,  // Checkerboardæµ‹è¯•
        ADDRESS_DECODE, // åœ°å€è§£ç æµ‹è¯•
        RETENTION,     // æ•°æ®ä¿æŒæµ‹è¯•
        REPORT
    } mbist_state_t;
    
    mbist_state_t state;
    reg [7:0] current_memory;
    reg [ADDR_WIDTH-1:0] current_addr;
    reg [DATA_WIDTH-1:0] expected_data;
    reg [31:0] error_count;
    reg [7:0] failing_memory;
    reg [ADDR_WIDTH-1:0] failing_addr;
    
    // March C-ç®—æ³•å®ç°
    always @(posedge clk) begin
        if (!rst_n) begin
            state <= IDLE;
            done <= 0;
            fail <= 0;
            error_count <= 0;
        end else if (mbist_mode) begin
            case (state)
                IDLE: begin
                    if (start) begin
                        state <= MARCH_C_W0;
                        current_memory <= 0;
                        current_addr <= 0;
                        error_count <= 0;
                        done <= 0;
                        fail <= 0;
                    end
                end
                
                MARCH_C_W0: begin
                    // å‘æ‰€æœ‰åœ°å€å†™0
                    mem_en[current_memory] <= 1;
                    mem_we[current_memory] <= 1;
                    mem_addr <= current_addr;
                    mem_wdata <= {DATA_WIDTH{1'b0}};
                    
                    if (current_addr == {ADDR_WIDTH{1'b1}}) begin
                        if (current_memory == NUM_MEMORIES - 1) begin
                            state <= MARCH_C_R0W1;
                            current_memory <= 0;
                            current_addr <= 0;
                        end else begin
                            current_memory <= current_memory + 1;
                            current_addr <= 0;
                        end
                    end else begin
                        current_addr <= current_addr + 1;
                    end
                end
                
                MARCH_C_R0W1: begin
                    // è¯»0å†™1ï¼Œåœ°å€é€’å¢
                    if (mem_we[current_memory]) begin
                        // å†™å‘¨æœŸ
                        mem_wdata <= {DATA_WIDTH{1'b1}};
                    end else begin
                        // è¯»å‘¨æœŸ
                        mem_we[current_memory] <= 0;
                        expected_data <= {DATA_WIDTH{1'b0}};
                        
                        if (mem_rdata[current_memory] !== expected_data) begin
                            error_count <= error_count + 1;
                            failing_memory <= current_memory;
                            failing_addr <= current_addr;
                        end
                        
                        // å‡†å¤‡å†™1
                        mem_we[current_memory] <= 1;
                    end
                    
                    // åœ°å€å’Œå†…å­˜æ¨è¿›é€»è¾‘...
                end
                
                // å…¶ä»–æµ‹è¯•æ¨¡å¼å®ç°...
                
                REPORT: begin
                    done <= 1;
                    fail <= (error_count > 0);
                    state <= IDLE;
                end
            endcase
        end
    end
endmodule

# DFTæ’å…¥è„šæœ¬
# dft_insertion.tcl

# è®¾ç½®DFTé…ç½®
set_dft_configuration -scan_style muxed_scan
set_scan_configuration -chain_count 16
set_scan_configuration -clock_mixing mix_edges

# å®šä¹‰æµ‹è¯•æ¨¡å¼
define_test_mode functional -usage scan
define_test_mode mbist -usage mbist_mode

# æ‰«æé“¾æ’å…¥
set_scan_path chain1 -view spec -scan_data_in scan_in_1 -scan_data_out scan_out_1
set_scan_path chain2 -view spec -scan_data_in scan_in_2 -scan_data_out scan_out_2
# ... æ›´å¤šæ‰«æé“¾

# æ’å…¥æµ‹è¯•ç»“æ„
insert_dft

# MBISTæ’å…¥
insert_mbist -memory_instances {sram_*} -algorithm march_c

# æµ‹è¯•ç‚¹æ’å…¥
set_test_point_configuration -control_points 100 -observe_points 200
insert_test_points -random

# ç”Ÿæˆæµ‹è¯•åè®®
write_test_protocol -output test_protocol.spf

# ATPGå‘é‡ç”Ÿæˆ
set_atpg_options -capture_cycles 4 -patterns 10000
run_atpg -auto

# æ•…éšœè¦†ç›–ç‡æŠ¥å‘Š
report_dft -scan > reports/dft_scan.rpt
report_dft -test_coverage > reports/test_coverage.rpt
write_test -format stil -output patterns/npu_test.stil
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  5ï¼šåç«¯ä¼˜åŒ–æŒ‘æˆ˜</h4>
                <p>é’ˆå¯¹ä»¥ä¸‹åç«¯å®ç°æŒ‘æˆ˜ï¼Œæå‡ºè§£å†³æ–¹æ¡ˆï¼š</p>
                <ol>
                    <li>åœ¨16nmå·¥è‰ºä¸‹ï¼Œå¦‚ä½•ä¼˜åŒ–NPUçš„åŠŸè€—å¯†åº¦ï¼Œé¿å…çƒ­ç‚¹ï¼Ÿ</li>
                    <li>è®¾è®¡ä¸€ä¸ªæ—¶é’ŸåŸŸäº¤å‰(CDC)éªŒè¯æ–¹æ¡ˆ</li>
                    <li>å®ç°ä¸€ä¸ªé’ˆå¯¹NPUç‰¹ç‚¹çš„è‡ªå®šä¹‰å•å…ƒåº“</li>
                </ol>
                
                <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                <div class="answer">
                    <div class="code-block">
// çƒ­ç‚¹ç¼“è§£è®¾è®¡
module ThermalManagement (
    input wire clk,
    input wire rst_n,
    
    // æ¸©åº¦ä¼ æ„Ÿå™¨è¾“å…¥
    input wire [7:0] temp_sensors [15:0],
    
    // åŠŸè€—æ§åˆ¶è¾“å‡º
    output reg [3:0] cluster_throttle,
    output reg [2:0] voltage_adjust,
    output reg [2:0] frequency_adjust,
    
    // ä»»åŠ¡è¿ç§»æ§åˆ¶
    output reg task_migration_req,
    output reg [3:0] migration_src_cluster,
    output reg [3:0] migration_dst_cluster
);
    
    // æ¸©åº¦é˜ˆå€¼å®šä¹‰
    localparam TEMP_NORMAL = 70;    // 70Â°C
    localparam TEMP_WARNING = 85;   // 85Â°C
    localparam TEMP_CRITICAL = 95;  // 95Â°C
    localparam TEMP_SHUTDOWN = 105; // 105Â°C
    
    // çƒ­ç‚¹æ£€æµ‹
    reg [3:0] hotspot_cluster;
    reg [7:0] max_temp;
    reg [7:0] avg_temp;
    
    always @(*) begin
        // æ‰¾å‡ºæœ€çƒ­çš„ç°‡
        max_temp = 0;
        hotspot_cluster = 0;
        avg_temp = 0;
        
        for (int i = 0; i < 16; i++) begin
            avg_temp = avg_temp + temp_sensors[i];
            if (temp_sensors[i] > max_temp) begin
                max_temp = temp_sensors[i];
                hotspot_cluster = i[3:0];
            end
        end
        avg_temp = avg_temp >> 4; // é™¤ä»¥16
    end
    
    // çƒ­ç®¡ç†çŠ¶æ€æœº
    typedef enum logic [2:0] {
        THERMAL_IDLE,
        THERMAL_MONITOR,
        THERMAL_THROTTLE,
        THERMAL_MIGRATE,
        THERMAL_EMERGENCY
    } thermal_state_t;
    
    thermal_state_t thermal_state;
    
    // åŠŸè€—å¯†åº¦å‡è¡¡ç®—æ³•
    reg [7:0] power_density_map [15:0];
    reg [3:0] coolest_cluster;
    
    always @(posedge clk) begin
        if (!rst_n) begin
            thermal_state <= THERMAL_IDLE;
            cluster_throttle <= 4'b0000;
            voltage_adjust <= 3'b100;  // æ ‡ç§°ç”µå‹
            frequency_adjust <= 3'b100; // æ ‡ç§°é¢‘ç‡
            task_migration_req <= 0;
        end else begin
            case (thermal_state)
                THERMAL_IDLE: begin
                    thermal_state <= THERMAL_MONITOR;
                end
                
                THERMAL_MONITOR: begin
                    if (max_temp > TEMP_SHUTDOWN) begin
                        thermal_state <= THERMAL_EMERGENCY;
                    end else if (max_temp > TEMP_CRITICAL) begin
                        thermal_state <= THERMAL_THROTTLE;
                    end else if (max_temp > TEMP_WARNING) begin
                        // æ£€æŸ¥æ˜¯å¦éœ€è¦ä»»åŠ¡è¿ç§»
                        if (find_coolest_cluster() < TEMP_NORMAL) begin
                            thermal_state <= THERMAL_MIGRATE;
                        end else begin
                            thermal_state <= THERMAL_THROTTLE;
                        end
                    end
                end
                
                THERMAL_THROTTLE: begin
                    // é™ä½çƒ­ç‚¹ç°‡çš„æ€§èƒ½
                    cluster_throttle[hotspot_cluster[1:0]] <= 1;
                    
                    // å…¨å±€é™é¢‘é™å‹
                    if (voltage_adjust > 3'b001) begin
                        voltage_adjust <= voltage_adjust - 1;
                        frequency_adjust <= frequency_adjust - 1;
                    end
                    
                    thermal_state <= THERMAL_MONITOR;
                end
                
                THERMAL_MIGRATE: begin
                    // è¯·æ±‚ä»»åŠ¡è¿ç§»
                    task_migration_req <= 1;
                    migration_src_cluster <= hotspot_cluster;
                    migration_dst_cluster <= coolest_cluster;
                    
                    if (task_migration_ack) begin
                        task_migration_req <= 0;
                        thermal_state <= THERMAL_MONITOR;
                    end
                end
                
                THERMAL_EMERGENCY: begin
                    // ç´§æ€¥å…³é—­çƒ­ç‚¹ç°‡
                    cluster_throttle <= 4'b1111;
                    voltage_adjust <= 3'b001;  // æœ€ä½ç”µå‹
                    frequency_adjust <= 3'b001; // æœ€ä½é¢‘ç‡
                    
                    if (max_temp < TEMP_CRITICAL) begin
                        thermal_state <= THERMAL_MONITOR;
                    end
                end
            endcase
        end
    end
    
    // åŠŸè€—å¯†åº¦è®¡ç®—
    function [3:0] find_coolest_cluster;
        reg [7:0] min_temp;
        reg [3:0] coolest_idx;
        begin
            min_temp = 8'hFF;
            coolest_idx = 0;
            
            for (int i = 0; i < 16; i++) begin
                if (temp_sensors[i] < min_temp && !cluster_throttle[i[1:0]]) begin
                    min_temp = temp_sensors[i];
                    coolest_idx = i[3:0];
                end
            end
            
            find_coolest_cluster = coolest_idx;
        end
    endfunction
endmodule

// CDCéªŒè¯ç¯å¢ƒ
module CDCVerification (
    // æºæ—¶é’ŸåŸŸ
    input wire clk_src,
    input wire rst_src_n,
    input wire [31:0] data_src,
    input wire valid_src,
    output wire ready_src,
    
    // ç›®æ ‡æ—¶é’ŸåŸŸ
    input wire clk_dst,
    input wire rst_dst_n,
    output wire [31:0] data_dst,
    output wire valid_dst,
    input wire ready_dst
);
    
    // æ ¼é›·ç åŒæ­¥å™¨
    GrayCodeSync #(
        .WIDTH(32)
    ) gray_sync (
        .clk_src(clk_src),
        .rst_src_n(rst_src_n),
        .data_src(data_src),
        .clk_dst(clk_dst),
        .rst_dst_n(rst_dst_n),
        .data_dst(data_gray_sync)
    );
    
    // åŒè§¦å‘å™¨åŒæ­¥å™¨
    reg valid_sync_1, valid_sync_2;
    always @(posedge clk_dst) begin
        if (!rst_dst_n) begin
            valid_sync_1 <= 0;
            valid_sync_2 <= 0;
        end else begin
            valid_sync_1 <= valid_src;
            valid_sync_2 <= valid_sync_1;
        end
    end
    
    // å¼‚æ­¥FIFO
    AsyncFIFO #(
        .DATA_WIDTH(32),
        .ADDR_WIDTH(4)
    ) async_fifo (
        .wr_clk(clk_src),
        .wr_rst_n(rst_src_n),
        .wr_data(data_src),
        .wr_en(valid_src),
        .wr_full(fifo_full),
        
        .rd_clk(clk_dst),
        .rd_rst_n(rst_dst_n),
        .rd_data(data_dst),
        .rd_en(ready_dst),
        .rd_empty(fifo_empty)
    );
    
    assign ready_src = !fifo_full;
    assign valid_dst = !fifo_empty;
    
    // CDCåè®®æ£€æŸ¥å™¨
    // synthesis translate_off
    property cdc_handshake_check;
        @(posedge clk_src) disable iff (!rst_src_n)
        valid_src && !ready_src |=> valid_src;
    endproperty
    
    assert property(cdc_handshake_check) else
        $error("CDC: Source dropped valid during backpressure");
    
    property cdc_data_stability;
        @(posedge clk_src) disable iff (!rst_src_n)
        valid_src && !ready_src |=> $stable(data_src);
    endproperty
    
    assert property(cdc_data_stability) else
        $error("CDC: Data changed while valid was high");
    // synthesis translate_on
endmodule

// NPUä¸“ç”¨æ ‡å‡†å•å…ƒåº“
module NPUCustomCells;
    
    // é«˜æ€§èƒ½8ä½ä¹˜æ³•å™¨å•å…ƒ
    module MAC8x8_HP (
        input wire [7:0] a,
        input wire [7:0] b,
        input wire [15:0] c,
        output wire [15:0] result
    );
        // ä¼˜åŒ–çš„Wallaceæ ‘ä¹˜æ³•å™¨
        wire [15:0] partial_products [7:0];
        wire [15:0] mult_result;
        
        // Boothç¼–ç å‡å°‘éƒ¨åˆ†ç§¯
        BoothEncoder booth_enc (
            .multiplicand(a),
            .multiplier(b),
            .partial_products(partial_products)
        );
        
        // Wallaceæ ‘å½’çº¦
        WallaceTree wallace (
            .partial_products(partial_products),
            .product(mult_result)
        );
        
        // æœ€ç»ˆåŠ æ³•å™¨ï¼ˆKogge-Stoneï¼‰
        KoggeStoneAdder #(16) final_adder (
            .a(mult_result),
            .b(c),
            .sum(result)
        );
    endmodule
    
    // ä½åŠŸè€—SRAMä½å•å…ƒ
    module SRAM_BitCell_LP (
        input wire wl,      // å­—çº¿
        input wire bl,      // ä½çº¿
        input wire blb,     // ä½çº¿å
        inout wire q,       // å­˜å‚¨èŠ‚ç‚¹
        inout wire qb       // å­˜å‚¨èŠ‚ç‚¹å
    );
        // 6T SRAMå•å…ƒï¼Œä¼˜åŒ–æ¼ç”µ
        tranif1 pass1 (q, bl, wl);
        tranif1 pass2 (qb, blb, wl);
        
        // äº¤å‰è€¦åˆåç›¸å™¨ï¼Œä½¿ç”¨é«˜é˜ˆå€¼æ™¶ä½“ç®¡
        pmos #(1) p1 (q, vdd, qb);
        nmos #(1) n1 (q, gnd, qb);
        pmos #(1) p2 (qb, vdd, q);
        nmos #(1) n2 (qb, gnd, q);
    endmodule
    
    // æ—¶é’Ÿé—¨æ§å•å…ƒ
    module ClockGate_NPU (
        input wire clk,
        input wire enable,
        input wire scan_enable,
        output wire gated_clk
    );
        reg latch_out;
        
        // ä½ç”µå¹³é”å­˜å™¨
        always @(*) begin
            if (!clk)
                latch_out <= enable || scan_enable;
        end
        
        // ANDé—¨è¾“å‡º
        assign gated_clk = clk && latch_out;
        
        // ä¿æŒæ—¶é—´æ£€æŸ¥
        // synthesis translate_off
        always @(posedge clk) begin
            assert($stable(enable)) else
                $error("Clock gate enable changed during high phase");
        end
        // synthesis translate_on
    endmodule
    
    // ä¼˜åŒ–çš„ä½å»¶è¿Ÿäº’è¿å•å…ƒ - Verilogç‰ˆæœ¬
    module NPU_Interconnect_Cell #(
        parameter DATA_WIDTH = 8,
        parameter SEL_WIDTH = 4,
        parameter PIPELINE_STAGES = 2
    )(
        input wire clk,
        input wire rst_n,
        input wire [DATA_WIDTH-1:0] data_in,
        input wire [SEL_WIDTH-1:0] sel,
        input wire valid_in,
        output reg [DATA_WIDTH-1:0] data_out,
        output reg valid_out
    );
        // æµæ°´çº¿å¯„å­˜å™¨
        reg [DATA_WIDTH-1:0] data_reg [PIPELINE_STAGES-1:0];
        reg [SEL_WIDTH-1:0] sel_reg [PIPELINE_STAGES-1:0];
        reg valid_reg [PIPELINE_STAGES-1:0];
        
        // ä¸­é—´ç»“æœå¯„å­˜å™¨
        reg [DATA_WIDTH-1:0] rotated_data;
        reg [DATA_WIDTH-1:0] mux_result;
        
        // ç¬¬ä¸€çº§æµæ°´çº¿ï¼šè¾“å…¥å¯„å­˜
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                data_reg[0] <= {DATA_WIDTH{1'b0}};
                sel_reg[0] <= {SEL_WIDTH{1'b0}};
                valid_reg[0] <= 1'b0;
            end else begin
                data_reg[0] <= data_in;
                sel_reg[0] <= sel;
                valid_reg[0] <= valid_in;
            end
        end
        
        // ç¬¬äºŒçº§æµæ°´çº¿ï¼šéƒ¨åˆ†é€‰æ‹©é€»è¾‘
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                data_reg[1] <= {DATA_WIDTH{1'b0}};
                sel_reg[1] <= {SEL_WIDTH{1'b0}};
                valid_reg[1] <= 1'b0;
                rotated_data <= {DATA_WIDTH{1'b0}};
            end else if (valid_reg[0]) begin
                data_reg[1] <= data_reg[0];
                sel_reg[1] <= sel_reg[0];
                valid_reg[1] <= valid_reg[0];
                
                // ä½¿ç”¨äºŒçº§MUXæ ‘ä¼˜åŒ–æ—¶åº
                case (sel_reg[0][1:0])
                    2'b00: rotated_data <= data_reg[0];
                    2'b01: rotated_data <= {data_reg[0][DATA_WIDTH-2:0], data_reg[0][DATA_WIDTH-1]};
                    2'b10: rotated_data <= {data_reg[0][DATA_WIDTH-3:0], data_reg[0][DATA_WIDTH-1:DATA_WIDTH-2]};
                    2'b11: rotated_data <= {data_reg[0][DATA_WIDTH-4:0], data_reg[0][DATA_WIDTH-1:DATA_WIDTH-3]};
                endcase
            end else begin
                valid_reg[1] <= 1'b0;
            end
        end
        
        // ç¬¬ä¸‰çº§æµæ°´çº¿ï¼šå®Œæˆé€‰æ‹©
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                mux_result <= {DATA_WIDTH{1'b0}};
                valid_out <= 1'b0;
            end else if (valid_reg[1]) begin
                // ç¬¬äºŒçº§MUX
                case (sel_reg[1][3:2])
                    2'b00: mux_result <= rotated_data;
                    2'b01: mux_result <= {rotated_data[DATA_WIDTH-5:0], rotated_data[DATA_WIDTH-1:DATA_WIDTH-4]};
                    2'b10: mux_result <= {rotated_data[DATA_WIDTH-6:0], rotated_data[DATA_WIDTH-1:DATA_WIDTH-5]};
                    2'b11: mux_result <= {rotated_data[DATA_WIDTH-7:0], rotated_data[DATA_WIDTH-1:DATA_WIDTH-6]};
                endcase
                valid_out <= valid_reg[1];
            end else begin
                valid_out <= 1'b0;
            end
        end
        
        // è¾“å‡ºå¯„å­˜å™¨
        always @(posedge clk or negedge rst_n) begin
            if (!rst_n) begin
                data_out <= {DATA_WIDTH{1'b0}};
            end else begin
                data_out <= mux_result;
            end
        end
        
    endmodule
endmodule
                    </div>
                    
                    <div class="code-block">
// Chiselç‰ˆæœ¬å¯¹æ¯”ï¼š
import chisel3._
import chisel3.util._

class NPUInterconnectCell(dataWidth: Int = 8,
                         selWidth: Int = 4,
                         pipelineStages: Int = 2) extends Module {
  val io = IO(new Bundle {
    val dataIn = Input(UInt(dataWidth.W))
    val sel = Input(UInt(selWidth.W))
    val validIn = Input(Bool())
    val dataOut = Output(UInt(dataWidth.W))
    val validOut = Output(Bool())
  })
  
  // æµæ°´çº¿å¯„å­˜å™¨
  val dataReg = Reg(Vec(pipelineStages, UInt(dataWidth.W)))
  val selReg = Reg(Vec(pipelineStages, UInt(selWidth.W)))
  val validReg = RegInit(VecInit(Seq.fill(pipelineStages)(false.B)))
  
  // ç¬¬ä¸€çº§ï¼šè¾“å…¥å¯„å­˜
  dataReg(0) := io.dataIn
  selReg(0) := io.sel
  validReg(0) := io.validIn
  
  // ç¬¬äºŒçº§ï¼šéƒ¨åˆ†æ—‹è½¬
  val rotatedData = RegInit(0.U(dataWidth.W))
  
  when(validReg(0)) {
    dataReg(1) := dataReg(0)
    selReg(1) := selReg(0)
    validReg(1) := validReg(0)
    
    // ä¸€çº§MUX
    rotatedData := MuxCase(dataReg(0), Seq(
      (selReg(0)(1, 0) === 0.U) -> dataReg(0),
      (selReg(0)(1, 0) === 1.U) -> Cat(dataReg(0)(dataWidth-2, 0), dataReg(0)(dataWidth-1)),
      (selReg(0)(1, 0) === 2.U) -> Cat(dataReg(0)(dataWidth-3, 0), dataReg(0)(dataWidth-1, dataWidth-2)),
      (selReg(0)(1, 0) === 3.U) -> Cat(dataReg(0)(dataWidth-4, 0), dataReg(0)(dataWidth-1, dataWidth-3))
    ))
  }.otherwise {
    validReg(1) := false.B
  }
  
  // ç¬¬ä¸‰çº§ï¼šå®Œæˆé€‰æ‹©
  val muxResult = RegInit(0.U(dataWidth.W))
  
  when(validReg(1)) {
    // äºŒçº§MUX
    muxResult := MuxCase(rotatedData, Seq(
      (selReg(1)(3, 2) === 0.U) -> rotatedData,
      (selReg(1)(3, 2) === 1.U) -> Cat(rotatedData(dataWidth-5, 0), rotatedData(dataWidth-1, dataWidth-4)),
      (selReg(1)(3, 2) === 2.U) -> Cat(rotatedData(dataWidth-6, 0), rotatedData(dataWidth-1, dataWidth-5)),
      (selReg(1)(3, 2) === 3.U) -> Cat(rotatedData(dataWidth-7, 0), rotatedData(dataWidth-1, dataWidth-6))
    ))
  }
  
  io.dataOut := RegNext(muxResult)
  io.validOut := RegNext(validReg(1))
}
                    </div>
                    <p><strong>è§£æï¼š</strong></p>
                    <ul>
                        <li>çƒ­ç®¡ç†æ¨¡å—é€šè¿‡æ¸©åº¦ä¼ æ„Ÿå™¨ç›‘æ§å„ç°‡æ¸©åº¦ï¼Œæ”¯æŒé™é¢‘ã€ä»»åŠ¡è¿ç§»ç­‰ç­–ç•¥</li>
                        <li>CDCéªŒè¯åŒ…å«æ ¼é›·ç åŒæ­¥ã€å¼‚æ­¥FIFOå’Œåè®®æ£€æŸ¥æ–­è¨€</li>
                        <li>è‡ªå®šä¹‰å•å…ƒåº“åŒ…å«ä¼˜åŒ–çš„MACå•å…ƒã€ä½åŠŸè€—SRAMã€æ—¶é’Ÿé—¨æ§ç­‰</li>
                        <li>é‡‡ç”¨Wallaceæ ‘å’ŒKogge-StoneåŠ æ³•å™¨ä¼˜åŒ–å…³é”®è·¯å¾„</li>
                        <li>é€šè¿‡é«˜é˜ˆå€¼æ™¶ä½“ç®¡å’Œæ—¶é’Ÿé—¨æ§é™ä½é™æ€åŠŸè€—</li>
                    </ul>
                </div>
            </div>

            <h3>ç»¼åˆé¡¹ç›®ç»ƒä¹ </h3>
            
            <div class="exercise">
                <h4>é¡¹ç›®ï¼šå®Œæ•´NPUè®¾è®¡å®ç°</h4>
                <p>åŸºäºæœ¬ç« æ‰€å­¦å†…å®¹ï¼Œå®Œæˆä¸€ä¸ªé¢å‘è¾¹ç¼˜AIçš„NPUå®Œæ•´è®¾è®¡ï¼Œè¦æ±‚ï¼š</p>
                <ol>
                    <li>æ”¯æŒResNet-50å’ŒBERT-Baseæ¨¡å‹çš„é«˜æ•ˆæ¨ç†</li>
                    <li>å³°å€¼ç®—åŠ›8 TOPSï¼ŒåŠŸè€—ä¸è¶…è¿‡5W</li>
                    <li>æ”¯æŒINT8/INT4é‡åŒ–å’Œç¨€ç–è®¡ç®—</li>
                    <li>åŒ…å«å®Œæ•´çš„éªŒè¯ç¯å¢ƒå’Œåç«¯å®ç°</li>
                    <li>è¾¾åˆ°90%ä»¥ä¸Šçš„æµ‹è¯•è¦†ç›–ç‡</li>
                </ol>
                
                <p>é¡¹ç›®äº¤ä»˜ç‰©ï¼š</p>
                <ul>
                    <li>æ¶æ„è®¾è®¡æ–‡æ¡£</li>
                    <li>RTLä»£ç ï¼ˆVerilog/SystemVerilogï¼‰</li>
                    <li>UVMéªŒè¯ç¯å¢ƒ</li>
                    <li>ç»¼åˆè„šæœ¬å’Œæ—¶åºæŠ¥å‘Š</li>
                    <li>ç‰©ç†è®¾è®¡æ•°æ®ï¼ˆDEF/GDSï¼‰</li>
                    <li>åŠŸè€—å’Œæ€§èƒ½åˆ†ææŠ¥å‘Š</li>
                </ul>
                
                <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                <div class="answer">
                    <p><strong>é¡¹ç›®å®æ–½æŒ‡å—ï¼š</strong></p>
                    
                    <h5>1. æ¶æ„è®¾è®¡é˜¶æ®µï¼ˆç¬¬1-2å‘¨ï¼‰</h5>
                    <div class="code-block">
// é¡¶å±‚æ¶æ„å‚æ•°å®šä¹‰
module EdgeAI_NPU_Config;
    // ç³»ç»Ÿé…ç½®
    parameter NUM_CLUSTERS = 4;
    parameter MACS_PER_CLUSTER = 512;  // æ€»è®¡2048 MACs
    parameter SYSTOLIC_ARRAY_SIZE = 16;  // 16x16 systolic array per cluster
    
    // å­˜å‚¨å±‚æ¬¡
    parameter L1_BUFFER_KB = 64;      // æ¯ä¸ªclusterçš„L1ç¼“å­˜
    parameter L2_BUFFER_MB = 4;       // å…±äº«L2ç¼“å­˜
    parameter DRAM_BANDWIDTH_GB = 32; // å¤–éƒ¨å†…å­˜å¸¦å®½
    
    // æ•°æ®ç²¾åº¦æ”¯æŒ
    parameter SUPPORT_INT8 = 1;
    parameter SUPPORT_INT4 = 1;
    parameter SUPPORT_MIXED_PRECISION = 1;
    
    // ç¨€ç–è®¡ç®—
    parameter SPARSITY_SUPPORT = 1;
    parameter MIN_SPARSITY_GRANULARITY = 4; // 4x4å—ç¨€ç–
    
    // åŠŸè€—ç›®æ ‡
    parameter TARGET_FREQ_MHZ = 1000;
    parameter TARGET_POWER_W = 5.0;
endmodule

// æ€§èƒ½å»ºæ¨¡æ¡†æ¶
class PerformanceModel {
    // ResNet-50æ€§èƒ½ä¼°ç®—
    float estimate_resnet50_fps() {
        float total_ops = 3.8e9;  // ResNet-50 FLOPs
        float mac_efficiency = 0.85;  // è€ƒè™‘æ•°æ®ä¼ è¾“å¼€é”€
        float sparsity_speedup = 1.3; // 30%ç¨€ç–åº¦å¸¦æ¥çš„åŠ é€Ÿ
        
        float peak_ops = NUM_CLUSTERS * MACS_PER_CLUSTER * 2 * TARGET_FREQ_MHZ * 1e6;
        float effective_ops = peak_ops * mac_efficiency * sparsity_speedup;
        
        return effective_ops / total_ops;
    }
    
    // BERT-Baseæ€§èƒ½ä¼°ç®—
    float estimate_bert_latency(int seq_length) {
        float attention_ops = 12 * seq_length * seq_length * 768 * 4;
        float ffn_ops = 12 * seq_length * 768 * 3072 * 2;
        float total_ops = attention_ops + ffn_ops;
        
        // è€ƒè™‘å†…å­˜å¸¦å®½é™åˆ¶
        float compute_time = total_ops / (8e12 * 0.7); // 70%åˆ©ç”¨ç‡
        float memory_time = estimate_memory_bound_time();
        
        return max(compute_time, memory_time);
    }
}
</div>
                    
                    <h5>2. RTLè®¾è®¡å®ç°ï¼ˆç¬¬3-6å‘¨ï¼‰</h5>
                    <div class="code-block">
// è®¡ç®—ç°‡é¡¶å±‚è®¾è®¡
module ComputeCluster #(
    parameter CLUSTER_ID = 0,
    parameter NUM_PES = 256,
    parameter ARRAY_SIZE = 16,
    parameter WEIGHT_BUFFER_KB = 32,
    parameter ACTIVATION_BUFFER_KB = 32
)(
    input wire clk,
    input wire rst_n,
    
    // NoCæ¥å£
    input wire [511:0] noc_data_in,
    input wire noc_valid_in,
    output wire noc_ready_out,
    
    output wire [511:0] noc_data_out,
    output wire noc_valid_out,
    input wire noc_ready_in,
    
    // æ§åˆ¶æ¥å£
    input wire [31:0] config_data,
    input wire config_valid,
    input wire start_compute,
    output wire compute_done,
    
    // æ€§èƒ½ç›‘æ§
    output wire [63:0] perf_counters [7:0]
);
    
    // å†…éƒ¨æ¨¡å—å®ä¾‹åŒ–
    // Weight Stationary Systolic Array
    SystolicArray_WS #(
        .ARRAY_SIZE(ARRAY_SIZE),
        .DATA_WIDTH(8),
        .SUPPORT_INT4(1)
    ) systolic_array (
        .clk(clk),
        .rst_n(rst_n),
        .weights(weight_data),
        .activations(activation_data),
        .partial_sums_in(ps_in),
        .partial_sums_out(ps_out),
        .config(array_config),
        .compute_enable(array_enable)
    );
    
    // ç¨€ç–è®¡ç®—åŠ é€Ÿå™¨
    SparseAccelerator #(
        .NUM_ENGINES(16),
        .BLOCK_SIZE(4)
    ) sparse_acc (
        .clk(clk),
        .rst_n(rst_n),
        .sparse_weights(sparse_weight_data),
        .sparse_indices(sparse_indices),
        .dense_activations(activation_data),
        .results(sparse_results),
        .sparse_enable(sparse_mode)
    );
    
    // æœ¬åœ°å­˜å‚¨ç®¡ç†
    LocalMemorySystem #(
        .WEIGHT_BUFFER_SIZE(WEIGHT_BUFFER_KB * 1024),
        .ACTIVATION_BUFFER_SIZE(ACTIVATION_BUFFER_KB * 1024),
        .NUM_BANKS(16)
    ) local_mem (
        .clk(clk),
        .rst_n(rst_n),
        .weight_addr(weight_addr),
        .weight_data(weight_data),
        .weight_we(weight_we),
        .activation_addr(activation_addr),
        .activation_data(activation_data),
        .activation_we(activation_we)
    );
    
    // DMAæ§åˆ¶å™¨
    DMAController dma_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .noc_interface(noc_if),
        .local_mem_interface(mem_if),
        .transfer_config(dma_config),
        .start_transfer(dma_start),
        .transfer_done(dma_done)
    );
    
    // æµæ°´çº¿æ§åˆ¶å™¨
    PipelineController pipeline_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        .layer_config(layer_config),
        .start_layer(start_compute),
        .layer_done(compute_done),
        .array_control(array_ctrl),
        .memory_control(mem_ctrl),
        .dma_control(dma_ctrl)
    );
endmodule
</div>
                    
                    <h5>3. éªŒè¯ç¯å¢ƒå¼€å‘ï¼ˆç¬¬4-7å‘¨ï¼Œä¸RTLå¹¶è¡Œï¼‰</h5>
                    <div class="code-block">
// å¢å¼ºçš„UVMéªŒè¯ç¯å¢ƒ
class npu_test_base extends uvm_test;
    `uvm_component_utils(npu_test_base)
    
    npu_env env;
    npu_config cfg;
    
    // æµ‹è¯•åœºæ™¯é…ç½®
    rand int num_layers;
    rand layer_config_t layer_configs[];
    rand bit enable_sparsity;
    rand bit enable_mixed_precision;
    
    constraint test_constraints {
        num_layers inside {[1:50]};  // ResNet-50çº§åˆ«
        layer_configs.size() == num_layers;
        foreach(layer_configs[i]) {
            layer_configs[i].layer_type inside {CONV, FC, ATTENTION};
            if (layer_configs[i].layer_type == CONV) {
                layer_configs[i].kernel_size inside {1, 3, 5, 7};
                layer_configs[i].stride inside {1, 2};
            }
        }
    }
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // åˆ›å»ºé…ç½®
        cfg = npu_config::type_id::create("cfg");
        cfg.num_clusters = 4;
        cfg.enable_coverage = 1;
        cfg.enable_scoreboard = 1;
        cfg.enable_performance_monitor = 1;
        
        // è®¾ç½®é…ç½®
        uvm_config_db#(npu_config)::set(this, "env", "cfg", cfg);
        
        // åˆ›å»ºç¯å¢ƒ
        env = npu_env::type_id::create("env", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        npu_sequence seq;
        
        phase.raise_objection(this);
        
        // è¿è¡Œæµ‹è¯•åºåˆ—
        seq = npu_sequence::type_id::create("seq");
        seq.num_transactions = 1000;
        seq.randomize();
        seq.start(env.agent.sequencer);
        
        // ç­‰å¾…DUTç©ºé—²
        wait_for_idle();
        
        // æ£€æŸ¥ç»“æœ
        check_test_results();
        
        phase.drop_objection(this);
    endtask
endclass

// ResNet-50ä¸“é¡¹æµ‹è¯•
class resnet50_test extends npu_test_base;
    `uvm_component_utils(resnet50_test)
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // é…ç½®ResNet-50å±‚
        num_layers = 50;
        layer_configs = new[num_layers];
        
        // Conv1: 7x7, stride 2
        layer_configs[0].layer_type = CONV;
        layer_configs[0].in_channels = 3;
        layer_configs[0].out_channels = 64;
        layer_configs[0].kernel_size = 7;
        layer_configs[0].stride = 2;
        
        // åç»­å±‚é…ç½®...
    endfunction
    
    task run_phase(uvm_phase phase);
        resnet50_sequence seq;
        real start_time, end_time;
        
        phase.raise_objection(this);
        
        // è®°å½•å¼€å§‹æ—¶é—´
        start_time = $realtime;
        
        // è¿è¡ŒResNet-50æ¨ç†
        seq = resnet50_sequence::type_id::create("seq");
        seq.batch_size = 1;
        seq.image_size = 224;
        seq.start(env.agent.sequencer);
        
        // è®°å½•ç»“æŸæ—¶é—´
        end_time = $realtime;
        
        // æ€§èƒ½åˆ†æ
        `uvm_info("PERF", $sformatf("ResNet-50 inference time: %0.2f ms", 
                  (end_time - start_time) / 1000000), UVM_LOW)
        
        // éªŒè¯ç²¾åº¦
        check_inference_accuracy();
        
        phase.drop_objection(this);
    endtask
endclass
</div>
                    
                    <h5>4. ç»¼åˆä¸æ—¶åºä¼˜åŒ–ï¼ˆç¬¬8-9å‘¨ï¼‰</h5>
                    <div class="code-block">
# å¢å¼ºçš„ç»¼åˆè„šæœ¬ - åŒ…å«åŠŸè€—ä¼˜åŒ–
# power_aware_synthesis.tcl

# è¯»å–UPFæ–‡ä»¶
read_power_intent -upf ./upf/npu_power_intent.upf

# è®¾ç½®åŠŸè€—ä¼˜åŒ–é€‰é¡¹
set_dynamic_optimization true
set_leakage_optimization true

# å¤šVtç­–ç•¥
set_attribute [get_lib_cells */LVT] dont_use false
set_attribute [get_lib_cells */RVT] dont_use false  
set_attribute [get_lib_cells */HVT] dont_use false

# è®¾ç½®åŠŸè€—çº¦æŸ
set_max_total_power 5.0 W
set_max_leakage_power 0.5 W

# å…³é”®è·¯å¾„çº¦æŸ
group_path -name CLK2Q -from [all_registers] -to [all_outputs]
group_path -name REG2REG -from [all_registers] -to [all_registers]
group_path -name IN2REG -from [all_inputs] -to [all_registers]

set_critical_range 0.1 [current_design]

# è¿è¡Œç»¼åˆ
compile_ultra -no_autoungroup -no_boundary_optimization

# å¢é‡ä¼˜åŒ–
optimize_registers -print_critical_loop
optimize_netlist -area

# åŠŸè€—ä¼˜åŒ–
optimize_power -effort high -include {leakage dynamic}

# ç”ŸæˆæŠ¥å‘Š
report_power -hierarchy > reports/power_report.txt
report_timing -max_paths 100 -nworst 10 > reports/timing_report.txt
report_area -hierarchy > reports/area_report.txt
report_qor > reports/qor_report.txt

# æ£€æŸ¥è®¾è®¡è§„åˆ™
check_design -summary
check_timing -include {no_clock no_input_delay}
</div>
                    
                    <h5>5. ç‰©ç†è®¾è®¡å®ç°ï¼ˆç¬¬10-12å‘¨ï¼‰</h5>
                    <div class="code-block">
# è‡ªåŠ¨åŒ–ç‰©ç†è®¾è®¡æµç¨‹
# auto_pnr_flow.tcl

# å®šä¹‰æ£€æŸ¥ç‚¹å’Œè¿­ä»£ä¼˜åŒ–
proc run_pnr_with_checkpoints {} {
    global design_name
    
    # Floorplané˜¶æ®µ
    source scripts/floorplan.tcl
    timeDesign -prePlace -prefix ${design_name}_preplace
    
    if {[get_metric timing.setup.wns] < -0.1} {
        # Floorplanä¼˜åŒ–
        optimize_floorplan_for_timing
    }
    
    # Placementé˜¶æ®µ
    placeDesign -concurrent_optimization
    timeDesign -preCTS -prefix ${design_name}_prects
    
    # æ£€æŸ¥placementè´¨é‡
    if {[check_placement_quality] == "FAIL"} {
        # é‡æ–°placementï¼Œè°ƒæ•´å‚æ•°
        deleteAllGlobalNets
        placeDesign -congestion_effort high -timing_driven
    }
    
    # CTSé˜¶æ®µ
    create_ccopt_clock_tree_spec
    ccopt_design -cts
    timeDesign -postCTS -prefix ${design_name}_postcts
    
    # Routeé˜¶æ®µ
    routeDesign -globalDetail
    
    # è¿­ä»£ä¼˜åŒ–
    set iteration 0
    while {[get_metric timing.setup.wns] < 0 && $iteration < 5} {
        optDesign -postRoute -setup -drv
        incr iteration
    }
    
    # æœ€ç»ˆä¼˜åŒ–
    optDesign -postRoute -hold
    
    # æ·»åŠ å¡«å……å•å…ƒ
    addFiller -cell {FILL1 FILL2 FILL4 FILL8} -prefix FILLER
    
    # é‡‘å±å¡«å……
    addMetalFill -layer {1 2 3 4 5 6} -minDensity 0.20 -maxDensity 0.80
}

# åŠŸè€—ç½‘æ ¼ä¼˜åŒ–
proc optimize_power_grid {} {
    # åˆ†æIR drop
    analyze_power_grid -net {VDD VSS}
    
    # è¯†åˆ«çƒ­ç‚¹
    set hotspots [identify_ir_hotspots -threshold 50mV]
    
    foreach hotspot $hotspots {
        # å±€éƒ¨åŠ å¼ºç”µæºç½‘æ ¼
        add_power_stripes -area $hotspot -layer M6 -width 2.0
    }
    
    # é‡æ–°åˆ†æ
    analyze_power_grid -net {VDD VSS} -report power_grid_final.rpt
}
</div>
                    
                    <h5>6. æµ‹è¯•ä¸éƒ¨ç½²ï¼ˆç¬¬13-14å‘¨ï¼‰</h5>
                    <div class="code-block">
// èŠ¯ç‰‡æµ‹è¯•ç¨‹åº
class NPU_TestProgram {
    // ç»“æ„æµ‹è¯•
    void run_structural_tests() {
        // æ‰«æé“¾æµ‹è¯•
        scan_test_controller.run_atpg_patterns();
        
        // MBISTæµ‹è¯•
        mbist_controller.test_all_memories();
        
        // è¾¹ç•Œæ‰«ææµ‹è¯•
        jtag_controller.run_boundary_scan();
    }
    
    // åŠŸèƒ½æµ‹è¯•
    void run_functional_tests() {
        // åŸºæœ¬åŠŸèƒ½æµ‹è¯•
        test_single_mac_operation();
        test_systolic_array_operation();
        test_memory_subsystem();
        test_noc_communication();
        
        // å¤æ‚åœºæ™¯æµ‹è¯•
        test_conv2d_layers();
        test_fully_connected_layers();
        test_attention_mechanism();
        
        // è¾¹ç•Œæ¡ä»¶æµ‹è¯•
        test_maximum_throughput();
        test_minimum_latency();
        test_power_modes();
    }
    
    // æ€§èƒ½éªŒè¯
    void validate_performance() {
        PerformanceResults results;
        
        // ResNet-50æµ‹è¯•
        results.resnet50_fps = benchmark_resnet50();
        assert(results.resnet50_fps >= 30);  // ç›®æ ‡: 30 FPS
        
        // BERTæµ‹è¯•
        results.bert_latency = benchmark_bert_base();
        assert(results.bert_latency <= 10);  // ç›®æ ‡: <10ms
        
        // åŠŸè€—æµ‹è¯•
        results.avg_power = measure_average_power();
        assert(results.avg_power <= 5.0);  // ç›®æ ‡: â‰¤5W
        
        generate_performance_report(results);
    }
}

// è½¯ä»¶SDKç¤ºä¾‹
class EdgeNPU_SDK {
    // æ¨¡å‹éƒ¨ç½²API
    NPUModel* deploy_model(const string& model_path) {
        // åŠ è½½æ¨¡å‹
        auto model = load_onnx_model(model_path);
        
        // å›¾ä¼˜åŒ–
        optimize_graph(model);
        
        // é‡åŒ–
        quantize_model(model, QuantizationMode::INT8);
        
        // ç¼–è¯‘åˆ°NPUæŒ‡ä»¤
        auto compiled = compile_for_npu(model);
        
        return compiled;
    }
    
    // æ¨ç†API
    Tensor inference(NPUModel* model, const Tensor& input) {
        // åˆ†é…è®¾å¤‡å†…å­˜
        auto d_input = allocate_device_memory(input.size());
        auto d_output = allocate_device_memory(model->output_size());
        
        // æ•°æ®ä¼ è¾“
        copy_to_device(input, d_input);
        
        // æ‰§è¡Œæ¨ç†
        npu_runtime.execute(model, d_input, d_output);
        
        // è·å–ç»“æœ
        Tensor output;
        copy_from_device(d_output, output);
        
        return output;
    }
};
</div>
                    
                    <h5>7. é¡¹ç›®äº¤ä»˜ä¸æ–‡æ¡£ï¼ˆç¬¬14å‘¨ï¼‰</h5>
                    <ul>
                        <li><strong>è®¾è®¡æ–‡æ¡£</strong>ï¼š
                            <ul>
                                <li>æ¶æ„è§„æ ¼è¯´æ˜ä¹¦ï¼ˆåŒ…å«æ€§èƒ½æ¨¡å‹å’ŒåŠŸè€—åˆ†æï¼‰</li>
                                <li>å¾®æ¶æ„è®¾è®¡æ–‡æ¡£ï¼ˆè¯¦ç»†çš„æ¨¡å—åˆ’åˆ†å’Œæ¥å£å®šä¹‰ï¼‰</li>
                                <li>éªŒè¯è®¡åˆ’å’Œè¦†ç›–ç‡æŠ¥å‘Š</li>
                                <li>PPAï¼ˆåŠŸè€—ã€æ€§èƒ½ã€é¢ç§¯ï¼‰åˆ†ææŠ¥å‘Š</li>
                            </ul>
                        </li>
                        <li><strong>ä»£ç äº¤ä»˜</strong>ï¼š
                            <ul>
                                <li>RTLæºç ï¼ˆå«è¯¦ç»†æ³¨é‡Šï¼‰</li>
                                <li>UVMéªŒè¯ç¯å¢ƒ</li>
                                <li>ç»¼åˆå’Œç‰©ç†è®¾è®¡è„šæœ¬</li>
                                <li>SDKå’Œç¼–è¯‘å™¨</li>
                            </ul>
                        </li>
                        <li><strong>æµ‹è¯•æŠ¥å‘Š</strong>ï¼š
                            <ul>
                                <li>åŠŸèƒ½æµ‹è¯•æŠ¥å‘Šï¼ˆè¦†ç›–ç‡>95%ï¼‰</li>
                                <li>æ€§èƒ½åŸºå‡†æµ‹è¯•ç»“æœ</li>
                                <li>åŠŸè€—æµ‹è¯•æ•°æ®</li>
                                <li>å¯é æ€§åˆ†æ</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <h5>å…³é”®è®¾è®¡å†³ç­–ä¸æƒè¡¡ï¼š</h5>
                    <ol>
                        <li><strong>æ•°æ®æµé€‰æ‹©</strong>ï¼šWeight Stationaryåœ¨è¾¹ç¼˜åœºæ™¯ä¸‹èƒ½æœ€å¤§åŒ–æƒé‡é‡ç”¨ï¼Œå‡å°‘å¤–éƒ¨å†…å­˜è®¿é—®</li>
                        <li><strong>ç²¾åº¦ç­–ç•¥</strong>ï¼šINT8ä¸ºä¸»ï¼ŒINT4ç”¨äºéå…³é”®å±‚ï¼Œæ··åˆç²¾åº¦æå‡çµæ´»æ€§</li>
                        <li><strong>ç¨€ç–æ”¯æŒ</strong>ï¼š4x4å—ç¨€ç–åœ¨ç¡¬ä»¶å¤æ‚åº¦å’ŒåŠ é€Ÿæ•ˆæœé—´å–å¾—å¹³è¡¡</li>
                        <li><strong>å†…å­˜å±‚æ¬¡</strong>ï¼šä¸¤çº§ç¼“å­˜è®¾è®¡ï¼ŒL1é è¿‘è®¡ç®—å•å…ƒï¼ŒL2å®ç°è·¨ç°‡å…±äº«</li>
                        <li><strong>åŠŸè€—ä¼˜åŒ–</strong>ï¼šå¤šç”µå‹åŸŸã€åŠ¨æ€æ—¶é’Ÿé—¨æ§ã€ç»†ç²’åº¦ç”µæºç®¡ç†</li>
                        <li><strong>å¯æµ‹è¯•æ€§</strong>ï¼šå®Œæ•´çš„DFTè®¾è®¡ï¼Œæ”¯æŒé‡äº§æµ‹è¯•éœ€æ±‚</li>
                    </ol>
                </div>
            </div>
        </section>
        
        <section id="conclusion">
            <h2>æ€»ç»“ä¸å±•æœ›</h2>
            
            <h3>NPUæŠ€æœ¯å‘å±•è¶‹åŠ¿</h3>
            <p>é€šè¿‡æœ¬æ•™ç¨‹çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æ·±å…¥äº†è§£äº†NPUä»æ¶æ„è®¾è®¡åˆ°èŠ¯ç‰‡å®ç°çš„å®Œæ•´æµç¨‹ã€‚å±•æœ›æœªæ¥ï¼ŒNPUæŠ€æœ¯å°†åœ¨ä»¥ä¸‹å‡ ä¸ªæ–¹å‘æŒç»­æ¼”è¿›ï¼š</p>
            
            <div class="info-box">
                <h4>1. æ¶æ„åˆ›æ–°</h4>
                <ul>
                    <li><strong>å­˜ç®—ä¸€ä½“åŒ–</strong>ï¼šå°†è®¡ç®—å•å…ƒä¸å­˜å‚¨æ·±åº¦èåˆï¼Œçªç ´å†¯Â·è¯ºä¾æ›¼ç“¶é¢ˆ</li>
                    <li><strong>å¯é‡æ„è®¡ç®—</strong>ï¼šæ”¯æŒåŠ¨æ€æ¶æ„è°ƒæ•´ï¼Œé€‚åº”ä¸åŒAIå·¥ä½œè´Ÿè½½</li>
                    <li><strong>è¿‘æ•°æ®è®¡ç®—</strong>ï¼šåœ¨æ•°æ®äº§ç”Ÿå’Œå­˜å‚¨çš„åœ°æ–¹è¿›è¡Œè®¡ç®—ï¼Œå‡å°‘æ•°æ®ç§»åŠ¨</li>
                    <li><strong>é‡å­-ç»å…¸æ··åˆ</strong>ï¼šç»“åˆé‡å­è®¡ç®—ä¼˜åŠ¿ï¼ŒåŠ é€Ÿç‰¹å®šAIç®—æ³•</li>
                </ul>
            </div>
            
            <div class="info-box">
                <h4>2. å·¥è‰ºä¸å°è£…</h4>
                <ul>
                    <li><strong>3Då †å æŠ€æœ¯</strong>ï¼šå‚ç›´é›†æˆè®¡ç®—å’Œå­˜å‚¨ï¼Œå¤§å¹…æå‡å¸¦å®½å¯†åº¦</li>
                    <li><strong>Chipletç”Ÿæ€</strong>ï¼šæ ‡å‡†åŒ–æ¥å£æ¨åŠ¨æ¨¡å—åŒ–è®¾è®¡å’Œå¿«é€Ÿåˆ›æ–°</li>
                    <li><strong>å…ˆè¿›èŠ‚ç‚¹</strong>ï¼š2nmåŠä»¥ä¸‹å·¥è‰ºå¸¦æ¥çš„æœºé‡ä¸æŒ‘æˆ˜</li>
                    <li><strong>æ–°å‹å™¨ä»¶</strong>ï¼šå¿†é˜»å™¨ã€è‡ªæ—‹ç”µå­å™¨ä»¶ç­‰æ–°å‹è®¡ç®—å…ƒä»¶</li>
                </ul>
            </div>
            
            <div class="info-box">
                <h4>3. è½¯ä»¶ä¸ç®—æ³•ååŒ</h4>
                <ul>
                    <li><strong>ç¼–è¯‘å™¨ä¼˜åŒ–</strong>ï¼šæ›´æ™ºèƒ½çš„å›¾ä¼˜åŒ–å’Œç¡¬ä»¶æ˜ å°„ç­–ç•¥</li>
                    <li><strong>è‡ªåŠ¨åŒ–è®¾è®¡</strong>ï¼šAIé©±åŠ¨çš„èŠ¯ç‰‡è®¾è®¡å’Œä¼˜åŒ–</li>
                    <li><strong>è½¯ç¡¬ä»¶ååŒè®¾è®¡</strong>ï¼šç®—æ³•ä¸æ¶æ„çš„æ·±åº¦èåˆ</li>
                    <li><strong>å¼€æºç”Ÿæ€</strong>ï¼šæ¨åŠ¨NPUæŠ€æœ¯çš„æ™®åŠå’Œåˆ›æ–°</li>
                </ul>
            </div>
            
            <h3>å­¦ä¹ èµ„æºæ¨è</h3>
            
            <h4>ğŸ“š æ¨èä¹¦ç±</h4>
            <ul>
                <li>ã€ŠEfficient Processing of Deep Neural Networksã€‹- Vivienne Szeç­‰</li>
                <li>ã€ŠComputer Architecture: A Quantitative Approachã€‹- Hennessy & Patterson</li>
                <li>ã€ŠDeep Learningã€‹- Ian Goodfellowç­‰</li>
                <li>ã€ŠCMOS VLSI Designã€‹- Weste & Harris</li>
            </ul>
            
            <h4>ğŸ“ å­¦æœ¯è®ºæ–‡</h4>
            <ul>
                <li>EIE: Efficient Inference Engine on Compressed Deep Neural Network</li>
                <li>In-Datacenter Performance Analysis of a Tensor Processing Unit</li>
                <li>Eyeriss: An Energy-Efficient Reconfigurable Accelerator</li>
                <li>DaDianNao: A Machine-Learning Supercomputer</li>
            </ul>
            
            <h4>ğŸ›  å¼€æºé¡¹ç›®</h4>
            <ul>
                <li><strong>NVDLA</strong>ï¼šNVIDIAæ·±åº¦å­¦ä¹ åŠ é€Ÿå™¨å¼€æºé¡¹ç›®</li>
                <li><strong>VTA</strong>ï¼šVersatile Tensor Accelerator (TVMé¡¹ç›®)</li>
                <li><strong>Gemmini</strong>ï¼šBerkeleyçš„å¼€æºDNNåŠ é€Ÿå™¨ç”Ÿæˆå™¨</li>
                <li><strong>SCALE-Sim</strong>ï¼šSystolicé˜µåˆ—æ€§èƒ½æ¨¡æ‹Ÿå™¨</li>
            </ul>
            
            <h4>ğŸ’» åœ¨çº¿è¯¾ç¨‹</h4>
            <ul>
                <li>MIT 6.888: Hardware Architecture for Deep Learning</li>
                <li>Stanford CS217: Hardware Accelerators for Machine Learning</li>
                <li>Cornell ECE5745: Complex Digital ASIC Design</li>
                <li>ETH Zurich: Digital Design and Computer Architecture</li>
            </ul>
            
            <h4>ğŸ”§ å¼€å‘å·¥å…·</h4>
            <div class="code-block">
# EDAå·¥å…·
- Synopsys: Design Compiler, IC Compiler II, PrimeTime
- Cadence: Genus, Innovus, Tempus
- Mentor: Calibre, Tessent

# å¼€æºå·¥å…·
- Verilator: å¼€æºVerilogä»¿çœŸå™¨
- OpenROAD: å¼€æºæ•°å­—èŠ¯ç‰‡è®¾è®¡æµç¨‹
- Yosys: å¼€æºç»¼åˆå·¥å…·
- Magic: å¼€æºç‰ˆå›¾å·¥å…·

# AIæ¡†æ¶
- TensorFlow Lite: è¾¹ç¼˜AIæ¨ç†æ¡†æ¶
- ONNX Runtime: è·¨å¹³å°æ¨ç†å¼•æ“
- Apache TVM: æ·±åº¦å­¦ä¹ ç¼–è¯‘å™¨
- MLIR: å¤šçº§ä¸­é—´è¡¨ç¤º
            </div>
            
            <h3>èŒä¸šå‘å±•å»ºè®®</h3>
            
            <p>NPUè®¾è®¡æ˜¯ä¸€ä¸ªäº¤å‰å­¦ç§‘é¢†åŸŸï¼Œéœ€è¦æŒæ¡å¤šæ–¹é¢çš„çŸ¥è¯†å’ŒæŠ€èƒ½ï¼š</p>
            
            <div class="exercise">
                <h4>æŠ€èƒ½å‘å±•è·¯çº¿å›¾</h4>
                <ol>
                    <li><strong>åŸºç¡€é˜¶æ®µï¼ˆ0-2å¹´ï¼‰</strong>
                        <ul>
                            <li>æŒæ¡æ•°å­—ç”µè·¯è®¾è®¡åŸºç¡€</li>
                            <li>ç†Ÿæ‚‰Verilog/SystemVerilog</li>
                            <li>ç†è§£è®¡ç®—æœºä½“ç³»ç»“æ„</li>
                            <li>å­¦ä¹ æ·±åº¦å­¦ä¹ åŸºç¡€çŸ¥è¯†</li>
                        </ul>
                    </li>
                    <li><strong>è¿›é˜¶é˜¶æ®µï¼ˆ2-5å¹´ï¼‰</strong>
                        <ul>
                            <li>æ·±å…¥ç†è§£NPUæ¶æ„è®¾è®¡</li>
                            <li>æŒæ¡UVMéªŒè¯æ–¹æ³•å­¦</li>
                            <li>å‚ä¸å®Œæ•´èŠ¯ç‰‡é¡¹ç›®</li>
                            <li>äº†è§£åç«¯è®¾è®¡æµç¨‹</li>
                        </ul>
                    </li>
                    <li><strong>ä¸“å®¶é˜¶æ®µï¼ˆ5å¹´+ï¼‰</strong>
                        <ul>
                            <li>é¢†å¯¼æ¶æ„å®šä¹‰å’Œåˆ›æ–°</li>
                            <li>ä¼˜åŒ–PPAï¼ˆåŠŸè€—ã€æ€§èƒ½ã€é¢ç§¯ï¼‰</li>
                            <li>æ¨åŠ¨è½¯ç¡¬ä»¶ååŒè®¾è®¡</li>
                            <li>å‚ä¸è¡Œä¸šæ ‡å‡†åˆ¶å®š</li>
                        </ul>
                    </li>
                </ol>
            </div>
            
            <h3>ç»“è¯­</h3>
            
            <p>NPUä½œä¸ºAIæ—¶ä»£çš„æ ¸å¿ƒåŸºç¡€è®¾æ–½ï¼Œæ­£åœ¨æ·±åˆ»æ”¹å˜ç€è®¡ç®—èŒƒå¼ã€‚ä»äº‘ç«¯æ•°æ®ä¸­å¿ƒåˆ°è¾¹ç¼˜è®¾å¤‡ï¼Œä»è‡ªåŠ¨é©¾é©¶åˆ°æ™ºèƒ½æ‰‹æœºï¼ŒNPUæ— å¤„ä¸åœ¨ã€‚å¸Œæœ›é€šè¿‡æœ¬æ•™ç¨‹çš„å­¦ä¹ ï¼Œä½ èƒ½å¤Ÿï¼š</p>
            
            <ul>
                <li>å»ºç«‹å¯¹NPUå®Œæ•´çš„è®¤çŸ¥ä½“ç³»</li>
                <li>æŒæ¡NPUè®¾è®¡çš„æ ¸å¿ƒæŠ€æœ¯</li>
                <li>å…·å¤‡ç‹¬ç«‹è®¾è®¡NPUçš„èƒ½åŠ›</li>
                <li>ä¸ºAIèŠ¯ç‰‡åˆ›æ–°è´¡çŒ®åŠ›é‡</li>
            </ul>
            
            <p class="highlight-box">
                è®°ä½ï¼ŒèŠ¯ç‰‡è®¾è®¡æ—¢æ˜¯ä¸€é—¨ç§‘å­¦ï¼Œä¹Ÿæ˜¯ä¸€é—¨è‰ºæœ¯ã€‚å®ƒéœ€è¦ä¸¥è°¨çš„å·¥ç¨‹æ€ç»´ï¼Œä¹Ÿéœ€è¦åˆ›æ–°çš„è®¾è®¡ç†å¿µã€‚åœ¨è¿½æ±‚æè‡´æ€§èƒ½çš„åŒæ—¶ï¼Œä¸è¦å¿˜è®°è€ƒè™‘å®é™…åº”ç”¨çš„éœ€æ±‚ã€‚ç¥ä½ åœ¨NPUè®¾è®¡çš„é“è·¯ä¸Šä¸æ–­è¿›æ­¥ï¼Œåˆ›é€ å‡ºæ”¹å˜ä¸–ç•Œçš„AIèŠ¯ç‰‡ï¼
            </p>
            
            <div class="info-box" style="text-align: center; margin-top: 40px;">
                <p><strong>æ„Ÿè°¢é˜…è¯»æœ¬æ•™ç¨‹ï¼</strong></p>
                <p>å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡GitHub Issuesåé¦ˆ</p>
                <p>è®©æˆ‘ä»¬ä¸€èµ·æ¨åŠ¨AIèŠ¯ç‰‡æŠ€æœ¯çš„å‘å±•ï¼</p>
            </div>
        </section>
        </div>
        
        <div class="section-summary">
                <h4>æœ¬ç« å°ç»“</h4>
                <ul>
                    <li><strong>NPUè®¾è®¡æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç³»ç»Ÿå·¥ç¨‹ï¼Œ</strong>ä»éœ€æ±‚åˆ†æåˆ°æµç‰‡éªŒè¯ï¼Œæ¯ä¸ªç¯èŠ‚éƒ½éœ€è¦ç²¾å¿ƒè§„åˆ’å’Œæ‰§è¡Œ</li>
                    <li><strong>éœ€æ±‚åˆ†æå†³å®šé¡¹ç›®æ–¹å‘ï¼Œ</strong>å‡†ç¡®ç†è§£åº”ç”¨åœºæ™¯ã€æ€§èƒ½æŒ‡æ ‡ã€åŠŸè€—çº¦æŸæ˜¯æˆåŠŸçš„ç¬¬ä¸€æ­¥</li>
                    <li><strong>æ¶æ„è®¾è®¡éœ€è¦å…¨å±€è§†é‡ï¼Œ</strong>è®¡ç®—æ ¸å¿ƒã€å­˜å‚¨ç³»ç»Ÿã€äº’è¿ç½‘ç»œã€æ§åˆ¶é€»è¾‘å¿…é¡»ååŒè®¾è®¡æ‰èƒ½è¾¾åˆ°æœ€ä¼˜æ•ˆæœ</li>
                    <li><strong>RTLå®ç°è€ƒéªŒå·¥ç¨‹èƒ½åŠ›ï¼Œ</strong>æ¨¡å—åŒ–è®¾è®¡ã€å‚æ•°åŒ–é…ç½®ã€ä»£ç å¤ç”¨æé«˜å¼€å‘æ•ˆç‡å’Œè®¾è®¡è´¨é‡</li>
                    <li><strong>éªŒè¯ç­–ç•¥ç¡®ä¿è®¾è®¡æ­£ç¡®æ€§ï¼Œ</strong>åˆ†å±‚éªŒè¯ã€éšæœºæµ‹è¯•ã€å½¢å¼åŒ–éªŒè¯ç­‰æ–¹æ³•ç›¸ç»“åˆæ‰èƒ½å……åˆ†è¦†ç›–</li>
                    <li><strong>ç»¼åˆä¼˜åŒ–è¿½æ±‚PPAå¹³è¡¡ï¼Œ</strong>æ—¶åºã€åŠŸè€—ã€é¢ç§¯çš„æƒè¡¡éœ€è¦åå¤è¿­ä»£æ‰èƒ½è¾¾åˆ°æœ€ä¼˜</li>
                    <li><strong>åç«¯å®ç°é¢ä¸´ç‰©ç†æŒ‘æˆ˜ï¼Œ</strong>å¸ƒå±€è§„åˆ’ã€æ—¶é’Ÿæ ‘è®¾è®¡ã€ä¿¡å·å®Œæ•´æ€§ç­‰é—®é¢˜éœ€è¦ä¸°å¯Œç»éªŒ</li>
                    <li><strong>ç³»ç»Ÿé›†æˆéœ€è¦è½¯ç¡¬ä»¶ååŒï¼Œ</strong>é©±åŠ¨å¼€å‘ã€ç¼–è¯‘å™¨é€‚é…ã€æ€§èƒ½è°ƒä¼˜ç¼ºä¸€ä¸å¯</li>
                    <li><strong>æŒç»­æ”¹è¿›æ˜¯é•¿æœŸä»»åŠ¡ï¼Œ</strong>é€šè¿‡å®é™…åº”ç”¨åé¦ˆä¸æ–­ä¼˜åŒ–è®¾è®¡ï¼Œä¸ºä¸‹ä¸€ä»£äº§å“ç§¯ç´¯ç»éªŒ</li>
                    <li><strong>å›¢é˜Ÿåä½œæ˜¯é¡¹ç›®æˆåŠŸçš„ä¿éšœï¼Œ</strong>æ¶æ„ã€RTLã€éªŒè¯ã€åç«¯ã€è½¯ä»¶å„å›¢é˜Ÿçš„ç´§å¯†é…åˆè‡³å…³é‡è¦</li>
                </ul>
            </div>
        </div>
        
        <div class="chapter-nav">
            <a href="chapter11.html" class="prev">ä¸Šä¸€ç« </a>
            
        </div>
    </div>
</body>
</html>