<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Processing Unit (NPU) 设计教程</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        nav {
            background: #34495e;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        nav li {
            margin: 5px 15px;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.3s;
        }

        nav a:hover {
            background: #2c3e50;
        }

        .chapter {
            background: white;
            margin: 20px 0;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chapter h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .chapter h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        .chapter h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .exercise {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .exercise h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .question {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .answer {
            margin-top: 10px;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 5px;
            display: none;
            border-left: 4px solid #4caf50;
        }

        .answer.show {
            display: block;
        }

        .toggle-answer {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.3s;
        }

        .toggle-answer:hover {
            background: #2980b9;
        }

        .figure {
            text-align: center;
            margin: 20px 0;
        }

        .figure img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .figure-caption {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            header h1 {
                font-size: 1.8em;
            }
            
            .chapter {
                padding: 20px;
            }
            
            nav ul {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Neural Processing Unit (NPU) 设计教程</h1>
        <p>从基础到高级的完整NPU芯片设计指南</p>
    </header>

    <nav>
        <ul>
            <li><a href="#intro">课程介绍</a></li>
            <li><a href="#chapter1">1. NPU简介</a></li>
            <li><a href="#chapter2">2. 神经网络基础</a></li>
            <li><a href="#chapter3">3. NPU架构</a></li>
            <li><a href="#chapter4">4. 计算核心</a></li>
            <li><a href="#chapter5">5. 存储系统</a></li>
            <li><a href="#chapter6">6. RTL设计</a></li>
            <li><a href="#chapter7">7. 验证方法</a></li>
            <li><a href="#chapter8">8. 物理设计</a></li>
            <li><a href="#chapter9">9. 先进工艺</a></li>
            <li><a href="#chapter10">10. 软硬件协同</a></li>
            <li><a href="#chapter11">11. 性能优化</a></li>
            <li><a href="#chapter12">12. 实战项目</a></li>
        </ul>
    </nav>

    <div class="container">
        <div id="intro" class="chapter">
            <h2>课程介绍</h2>
            <p>欢迎来到Neural Processing Unit (NPU)设计教程！本教程将带您从零开始，逐步深入了解NPU的设计原理和实现技术。</p>
            
            <h3>课程目标</h3>
            <ul>
                <li>理解NPU的基本原理和架构</li>
                <li>掌握NPU前端设计技术（RTL设计和验证）</li>
                <li>学习NPU后端设计流程（综合、布局布线）</li>
                <li>了解软硬件协同设计方法</li>
                <li>通过实战项目巩固所学知识</li>
            </ul>

            <h3>学习建议</h3>
            <div class="info-box">
                <p><strong>提示：</strong>本教程采用渐进式学习方式，建议按章节顺序学习。每章都包含理论讲解、代码示例和练习题，请确保完成每章的练习题后再进入下一章。</p>
            </div>

            <h3>先修知识</h3>
            <ul>
                <li>数字电路基础</li>
                <li>Verilog/SystemVerilog编程基础</li>
                <li>计算机体系结构基础</li>
                <li>基本的深度学习概念</li>
            </ul>
        </div>

        <div id="chapter1" class="chapter">
            <h2>第1章：NPU简介与发展历程</h2>
            
            <h3>1.1 什么是NPU</h3>
            <p>Neural Processing Unit (NPU) 是一种专门为加速人工智能和机器学习工作负载而设计的处理器。与传统的CPU和GPU不同，NPU针对神经网络计算进行了特殊优化，能够高效执行矩阵运算、卷积运算等AI相关操作。</p>
            
            <div class="info-box">
                <p><strong>关键特征：</strong></p>
                <ul>
                    <li>专用硬件加速器，优化神经网络推理和训练</li>
                    <li>高效的矩阵运算单元（MAC阵列）</li>
                    <li>专门的数据流架构，减少内存访问开销</li>
                    <li>支持低精度计算（INT8, INT4等）以提高效率</li>
                </ul>
            </div>

            <h3>1.2 NPU vs CPU vs GPU</h3>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>特性</th>
                            <th>CPU</th>
                            <th>GPU</th>
                            <th>NPU</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>设计目标</td>
                            <td>通用计算</td>
                            <td>并行图形/计算</td>
                            <td>AI/ML专用</td>
                        </tr>
                        <tr>
                            <td>架构特点</td>
                            <td>少量复杂核心</td>
                            <td>大量简单核心</td>
                            <td>专用MAC阵列</td>
                        </tr>
                        <tr>
                            <td>内存层次</td>
                            <td>多级缓存</td>
                            <td>高带宽显存</td>
                            <td>片上SRAM为主</td>
                        </tr>
                        <tr>
                            <td>功耗效率</td>
                            <td>中等</td>
                            <td>较低</td>
                            <td>高</td>
                        </tr>
                        <tr>
                            <td>编程模型</td>
                            <td>串行为主</td>
                            <td>SIMD/SIMT</td>
                            <td>数据流</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>1.3 NPU的应用场景</h3>
            <h4>边缘端应用</h4>
            <ul>
                <li><strong>智能手机：</strong>人脸识别、语音助手、拍照优化</li>
                <li><strong>智能摄像头：</strong>实时物体检测、行为分析</li>
                <li><strong>自动驾驶：</strong>感知融合、路径规划</li>
                <li><strong>IoT设备：</strong>语音唤醒、异常检测</li>
            </ul>

            <h4>数据中心应用</h4>
            <ul>
                <li><strong>推理服务器：</strong>大规模AI服务部署</li>
                <li><strong>训练加速：</strong>分布式训练加速卡</li>
                <li><strong>推荐系统：</strong>实时推荐计算</li>
            </ul>

            <h3>1.4 主流NPU架构概览</h3>
            
            <h4>1.4.1 Google TPU</h4>
            <div class="code-block">
// TPU v1 架构特点
- 脉动阵列（Systolic Array）：256x256 MACs
- 片上缓存：24MB Unified Buffer
- 主频：700MHz
- 峰值性能：92 TOPS (INT8)
- 内存带宽：34 GB/s
            </div>

            <h4>1.4.2 华为Ascend</h4>
            <div class="code-block">
// Ascend 910 架构特点
- 达芬奇架构：Cube计算单元
- 片上缓存：多级缓存体系
- 峰值性能：256 TFLOPS (FP16)
- HBM内存：32GB
- 互联：高速片间互联
            </div>

            <h4>1.4.3 寒武纪MLU</h4>
            <div class="code-block">
// MLU 290 架构特点
- MLUv02架构
- 16个MLU Core
- 片上缓存：48MB
- 内存：32GB LPDDR4x
- 峰值性能：1024 TOPS (INT4)
            </div>

            <div class="exercise">
                <h4>练习题集 1</h4>
                
                <div class="question">
                    <p><strong>题目1.1：</strong>简述NPU相比GPU在AI推理任务上的三个主要优势。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <ol>
                            <li><strong>功耗效率更高：</strong>NPU采用专用硬件设计，去除了GPU中用于图形渲染的部分，并针对神经网络运算进行优化，在相同性能下功耗可降低50%以上。</li>
                            <li><strong>推理延迟更低：</strong>NPU的数据流架构和片上存储设计减少了内存访问延迟，批处理大小为1时性能优势明显。</li>
                            <li><strong>支持低精度计算：</strong>NPU原生支持INT8、INT4等低精度格式，可在保持精度的同时大幅提升吞吐量。</li>
                        </ol>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目1.2：</strong>解释什么是脉动阵列（Systolic Array），以及它为什么适合神经网络计算？</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p>脉动阵列是一种规则的处理单元阵列，数据像心脏跳动一样有节奏地在阵列中流动。其特点包括：</p>
                        <ul>
                            <li><strong>数据复用：</strong>输入数据在多个PE间传递，减少内存访问</li>
                            <li><strong>规则结构：</strong>易于实现和扩展，面积利用率高</li>
                            <li><strong>高并行度：</strong>可同时执行大量MAC运算</li>
                        </ul>
                        <p>适合神经网络的原因：</p>
                        <ol>
                            <li>神经网络主要是矩阵乘法运算，与脉动阵列的计算模式匹配</li>
                            <li>权重可以预加载并保持静止，提高数据复用率</li>
                            <li>规则的计算模式便于流水线设计</li>
                        </ol>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目1.3：</strong>某NPU的MAC阵列为16x16，主频为1GHz，每个周期每个MAC可完成2次INT8运算。计算该NPU的理论峰值性能（TOPS）。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p>计算步骤：</p>
                        <ol>
                            <li>MAC单元总数 = 16 × 16 = 256</li>
                            <li>每秒周期数 = 1GHz = 10^9 cycles/s</li>
                            <li>每周期运算次数 = 256 × 2 = 512 ops/cycle</li>
                            <li>峰值性能 = 10^9 × 512 = 512 × 10^9 ops/s = 512 GOPS = 0.512 TOPS</li>
                        </ol>
                        <p><strong>答案：0.512 TOPS</strong></p>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目1.4：</strong>设计一个简单的4x4脉动阵列，用Verilog描述其中一个PE（Processing Element）的基本结构。PE需要支持乘累加操作。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module PE #(
    parameter DATA_WIDTH = 8,
    parameter ACC_WIDTH = 32
)(
    input wire clk,
    input wire rst_n,
    input wire en,
    
    // 数据输入
    input wire [DATA_WIDTH-1:0] data_in,    // 从左边PE传入
    input wire [DATA_WIDTH-1:0] weight_in,  // 从上边PE传入
    
    // 数据输出
    output reg [DATA_WIDTH-1:0] data_out,   // 传给右边PE
    output reg [DATA_WIDTH-1:0] weight_out, // 传给下边PE
    
    // 部分和
    input wire [ACC_WIDTH-1:0] psum_in,     // 从上边PE传入
    output reg [ACC_WIDTH-1:0] psum_out     // 传给下边PE
);

    // 内部寄存器
    reg [DATA_WIDTH-1:0] weight_reg;
    wire [2*DATA_WIDTH-1:0] mult_result;
    wire [ACC_WIDTH-1:0] acc_result;
    
    // 乘法器
    assign mult_result = data_in * weight_reg;
    
    // 加法器
    assign acc_result = psum_in + {{(ACC_WIDTH-2*DATA_WIDTH){mult_result[2*DATA_WIDTH-1]}}, mult_result};
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_out <= 0;
            weight_out <= 0;
            psum_out <= 0;
            weight_reg <= 0;
        end else if (en) begin
            // 数据向右传递
            data_out <= data_in;
            
            // 权重向下传递并保存
            weight_out <= weight_in;
            weight_reg <= weight_in;
            
            // 累加结果向下传递
            psum_out <= acc_result;
        end
    end
endmodule
                        </div>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目1.5：</strong>分析边缘端NPU和云端NPU在设计上的主要差异，至少列举4个方面。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <table>
                            <tr>
                                <th>设计方面</th>
                                <th>边缘端NPU</th>
                                <th>云端NPU</th>
                            </tr>
                            <tr>
                                <td>功耗预算</td>
                                <td>通常&lt;5W，需要极致的功耗优化</td>
                                <td>可达100W以上，更关注性能</td>
                            </tr>
                            <tr>
                                <td>内存系统</td>
                                <td>小容量片上SRAM，有限的外部带宽</td>
                                <td>大容量HBM/GDDR，高带宽</td>
                            </tr>
                            <tr>
                                <td>计算精度</td>
                                <td>主要INT8/INT4，追求高压缩比</td>
                                <td>FP16/FP32/INT8混合精度</td>
                            </tr>
                            <tr>
                                <td>芯片面积</td>
                                <td>&lt;50mm²，成本敏感</td>
                                <td>可达800mm²，性能优先</td>
                            </tr>
                            <tr>
                                <td>应用场景</td>
                                <td>推理为主，实时性要求高</td>
                                <td>训练和推理，吞吐量优先</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目1.6：</strong>计算题：某手机NPU需要实时处理1080p@30fps的视频流进行物体检测。假设每帧需要100M次MAC运算，计算所需的最小算力（GOPS）。如果NPU效率为70%，实际需要多少GOPS的峰值性能？</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p>计算步骤：</p>
                        <ol>
                            <li>每秒帧数：30 fps</li>
                            <li>每帧运算量：100M = 10^8 ops</li>
                            <li>每秒运算量：30 × 10^8 = 3 × 10^9 ops = 3 GOPS</li>
                            <li>考虑70%效率，实际需要：3 ÷ 0.7 ≈ 4.29 GOPS</li>
                        </ol>
                        <p><strong>答案：最小算力需求为3 GOPS，考虑效率后需要4.29 GOPS的峰值性能。</strong></p>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目1.7：</strong>编程题：用Python实现一个简单的脉动阵列模拟器，计算两个4x4矩阵的乘法。要求展示数据在阵列中的流动过程。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
import numpy as np

class SystolicArray:
    def __init__(self, size=4):
        self.size = size
        self.array = [[{'a': 0, 'b': 0, 'c': 0} for _ in range(size)] for _ in range(size)]
        self.cycle = 0
        
    def reset(self):
        """重置脉动阵列"""
        self.array = [[{'a': 0, 'b': 0, 'c': 0} for _ in range(size)] for _ in range(size)]
        self.cycle = 0
    
    def step(self, a_inputs, b_inputs):
        """执行一个时钟周期"""
        # 创建新的阵列状态
        new_array = [[{'a': 0, 'b': 0, 'c': 0} for _ in range(self.size)] for _ in range(self.size)]
        
        # 更新每个PE
        for i in range(self.size):
            for j in range(self.size):
                # 获取输入
                if j == 0:
                    a_in = a_inputs[i] if i < len(a_inputs) else 0
                else:
                    a_in = self.array[i][j-1]['a']
                    
                if i == 0:
                    b_in = b_inputs[j] if j < len(b_inputs) else 0
                else:
                    b_in = self.array[i-1][j]['b']
                
                # 计算MAC
                new_array[i][j]['c'] = self.array[i][j]['c'] + a_in * b_in
                
                # 传递数据
                new_array[i][j]['a'] = a_in
                new_array[i][j]['b'] = b_in
        
        self.array = new_array
        self.cycle += 1
        
    def get_result(self):
        """获取计算结果"""
        result = np.zeros((self.size, self.size))
        for i in range(self.size):
            for j in range(self.size):
                result[i][j] = self.array[i][j]['c']
        return result
    
    def print_state(self):
        """打印当前状态"""
        print(f"\n周期 {self.cycle}:")
        for i in range(self.size):
            for j in range(self.size):
                pe = self.array[i][j]
                print(f"({pe['a']},{pe['b']},{pe['c']:3})", end=" ")
            print()

# 使用示例
def matrix_multiply_systolic(A, B):
    """使用脉动阵列计算矩阵乘法"""
    size = len(A)
    sa = SystolicArray(size)
    
    # 准备输入数据（需要错开时序）
    a_streams = []
    b_streams = []
    
    for i in range(size):
        # A矩阵的行需要错开输入
        a_stream = [0] * i + list(A[i]) + [0] * (size - 1)
        a_streams.append(a_stream)
        
        # B矩阵的列需要错开输入
        b_stream = [0] * i + [B[j][i] for j in range(size)] + [0] * (size - 1)
        b_streams.append(b_stream)
    
    # 执行计算
    max_cycles = 3 * size - 2  # 完成计算需要的周期数
    
    for cycle in range(max_cycles):
        # 准备这个周期的输入
        a_inputs = []
        b_inputs = []
        
        for i in range(size):
            if cycle < len(a_streams[i]):
                a_inputs.append(a_streams[i][cycle])
            else:
                a_inputs.append(0)
                
            if cycle < len(b_streams[i]):
                b_inputs.append(b_streams[i][cycle])
            else:
                b_inputs.append(0)
        
        sa.step(a_inputs[:size], b_inputs[:size])
        sa.print_state()
    
    return sa.get_result()

# 测试
if __name__ == "__main__":
    A = np.array([[1, 2, 3, 4],
                  [5, 6, 7, 8],
                  [9, 10, 11, 12],
                  [13, 14, 15, 16]])
    
    B = np.array([[1, 0, 0, 0],
                  [0, 1, 0, 0],
                  [0, 0, 1, 0],
                  [0, 0, 0, 1]])
    
    print("矩阵A:")
    print(A)
    print("\n矩阵B:")
    print(B)
    
    result = matrix_multiply_systolic(A, B)
    print("\n脉动阵列计算结果:")
    print(result)
    
    print("\nNumPy验证结果:")
    print(np.matmul(A, B))
                        </div>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目1.8：</strong>分析题：为什么大多数NPU采用INT8而不是FP32进行推理？从硬件实现角度分析其优势。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p>NPU采用INT8进行推理的硬件优势：</p>
                        <ol>
                            <li><strong>硬件面积：</strong>
                                <ul>
                                    <li>INT8乘法器面积约为FP32的1/8</li>
                                    <li>INT8加法器面积约为FP32的1/4</li>
                                    <li>相同面积可集成4-8倍的计算单元</li>
                                </ul>
                            </li>
                            <li><strong>功耗效率：</strong>
                                <ul>
                                    <li>INT8运算功耗约为FP32的1/4</li>
                                    <li>数据位宽减少，总线功耗降低75%</li>
                                </ul>
                            </li>
                            <li><strong>内存带宽：</strong>
                                <ul>
                                    <li>数据量减少4倍，缓解内存瓶颈</li>
                                    <li>片上缓存可存储更多数据</li>
                                </ul>
                            </li>
                            <li><strong>时序优化：</strong>
                                <ul>
                                    <li>INT8运算延迟更低，便于提高主频</li>
                                    <li>流水线级数减少，控制逻辑简化</li>
                                </ul>
                            </li>
                        </ol>
                        <p><strong>实际应用中通过量化感知训练，INT8精度损失通常小于1%，是性能功耗比的最佳选择。</strong></p>
                    </div>
                </div>
            </div>
        </div>

        <div id="chapter2" class="chapter">
            <h2>第2章：神经网络计算基础</h2>
            
            <h3>2.1 神经网络基本运算</h3>
            
            <h4>2.1.1 神经元计算模型</h4>
            <p>神经元是神经网络的基本计算单元，其数学模型为：</p>
            <div class="code-block">
y = f(Σ(wi * xi) + b)

其中：
- wi * xi：加权输入 (Weighted Input)
- Σ(...)：求和 (Summation)  
- b：偏置 (Bias)
- f(...)：激活函数 (Activation Function)
            </div>
            
            <div class="info-box">
                <p><strong>硬件视角：</strong>神经元的核心运算是乘累加（MAC），这是NPU设计的基础。一个神经元的计算可以分解为：</p>
                <ol>
                    <li>多个乘法运算：wi * xi</li>
                    <li>累加运算：Σ(wi * xi)</li>
                    <li>加偏置：+ b</li>
                    <li>激活函数：f(...)</li>
                </ol>
            </div>

            <h4>2.1.2 激活函数的硬件实现</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>激活函数</th>
                            <th>公式</th>
                            <th>硬件实现方式</th>
                            <th>硬件成本</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ReLU</td>
                            <td>max(0, x)</td>
                            <td>比较器 + 选择器</td>
                            <td>极低</td>
                        </tr>
                        <tr>
                            <td>Leaky ReLU</td>
                            <td>max(αx, x)</td>
                            <td>乘法器 + 比较器 + 选择器</td>
                            <td>低</td>
                        </tr>
                        <tr>
                            <td>Sigmoid</td>
                            <td>1/(1+e^(-x))</td>
                            <td>查找表(LUT) / 分段线性逼近</td>
                            <td>高</td>
                        </tr>
                        <tr>
                            <td>Tanh</td>
                            <td>(e^x - e^(-x))/(e^x + e^(-x))</td>
                            <td>查找表(LUT) / 分段线性逼近</td>
                            <td>高</td>
                        </tr>
                        <tr>
                            <td>GeLU</td>
                            <td>x * Φ(x)</td>
                            <td>多级查找表 + 插值</td>
                            <td>很高</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>2.2 矩阵乘法与卷积运算</h3>
            
            <h4>2.2.1 通用矩阵乘法（GEMM）</h4>
            <p>全连接层的本质是矩阵乘法：<code>Y = XW + B</code></p>
            
            <div class="code-block">
// 矩阵乘法的基本实现
for (int i = 0; i < M; i++) {
    for (int j = 0; j < N; j++) {
        float sum = 0;
        for (int k = 0; k < K; k++) {
            sum += A[i][k] * B[k][j];  // MAC运算
        }
        C[i][j] = sum;
    }
}

// 硬件视角的优化考虑：
// 1. 内层循环是MAC运算，适合并行化
// 2. 数据复用：A的每一行被复用N次，B的每一列被复用M次
// 3. 访存模式：顺序访问A，跳跃访问B（缓存不友好）
            </div>

            <h4>2.2.2 卷积运算的实现方式</h4>
            
            <div class="warning-box">
                <p><strong>核心挑战：</strong>卷积运算涉及多维数据和复杂的访存模式，如何高效地映射到硬件是NPU设计的关键。</p>
            </div>

            <p><strong>方法1：Im2Col + GEMM</strong></p>
            <div class="code-block">
// Im2Col转换示例
// 输入: [H, W, C_in]
// 卷积核: [K_h, K_w, C_in, C_out]
// 输出: [H_out, W_out, C_out]

// Step 1: Im2Col展开
// 将每个卷积窗口展开成一列
// 展开后矩阵大小: [K_h * K_w * C_in, H_out * W_out]

// Step 2: 矩阵乘法
// 权重矩阵: [C_out, K_h * K_w * C_in]
// 结果 = 权重矩阵 × Im2Col矩阵

// 优点：可以复用高效的GEMM硬件
// 缺点：内存开销大，数据冗余严重
            </div>

            <p><strong>方法2：直接卷积</strong></p>
            <div class="code-block">
// 直接卷积的硬件实现
module ConvolutionEngine #(
    parameter IN_WIDTH = 8,
    parameter WEIGHT_WIDTH = 8,
    parameter OUT_WIDTH = 32
)(
    input clk,
    input rst_n,
    input [IN_WIDTH-1:0] pixel_in,
    input [WEIGHT_WIDTH-1:0] weight,
    input valid_in,
    output [OUT_WIDTH-1:0] conv_out,
    output valid_out
);
    // Line Buffer用于缓存输入行
    // Window Buffer用于提取卷积窗口
    // MAC阵列执行并行乘累加
endmodule
            </div>

            <h3>2.3 数据流与并行计算</h3>
            
            <h4>2.3.1 数据流架构</h4>
            <p>NPU的数据流设计决定了如何在计算单元间移动和复用数据，直接影响性能和功耗。</p>
            
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>数据流类型</th>
                            <th>固定数据</th>
                            <th>移动数据</th>
                            <th>优势</th>
                            <th>适用场景</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>权重固定(WS)</td>
                            <td>权重</td>
                            <td>输入、部分和</td>
                            <td>权重复用率高</td>
                            <td>权重大、批处理小</td>
                        </tr>
                        <tr>
                            <td>输出固定(OS)</td>
                            <td>部分和</td>
                            <td>权重、输入</td>
                            <td>减少部分和读写</td>
                            <td>输出通道多</td>
                        </tr>
                        <tr>
                            <td>输入固定(IS)</td>
                            <td>输入</td>
                            <td>权重、部分和</td>
                            <td>输入复用率高</td>
                            <td>输入大、权重小</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h4>2.3.2 并行计算维度</h4>
            <div class="code-block">
// 卷积运算的7个循环维度
for (n = 0; n < N; n++)         // Batch
  for (k = 0; k < K; k++)       // 输出通道
    for (c = 0; c < C; c++)     // 输入通道
      for (y = 0; y < Y; y++)   // 输出高度
        for (x = 0; x < X; x++) // 输出宽度
          for (fy = 0; fy < FY; fy++)   // 卷积核高度
            for (fx = 0; fx < FX; fx++) // 卷积核宽度
              out[n][k][y][x] += in[n][c][y+fy][x+fx] * w[k][c][fy][fx]

// NPU可以选择在不同维度上并行化：
// 1. 空间并行：在Y、X维度展开
// 2. 通道并行：在K、C维度展开
// 3. 批处理并行：在N维度展开
            </div>

            <h3>2.4 量化与数据格式</h3>
            
            <h4>2.4.1 量化原理</h4>
            <p>量化是将高精度浮点数转换为低精度定点数的过程，是NPU提升效率的关键技术。</p>
            
            <div class="code-block">
// 对称量化
int8_value = round(fp32_value / scale)
fp32_value = int8_value * scale

// 非对称量化
int8_value = round(fp32_value / scale) + zero_point
fp32_value = (int8_value - zero_point) * scale

// 量化参数计算
scale = (max_val - min_val) / (2^bits - 1)
zero_point = round(-min_val / scale)
            </div>

            <h4>2.4.2 不同精度的硬件开销对比</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>数据类型</th>
                            <th>位宽</th>
                            <th>乘法器面积</th>
                            <th>加法器面积</th>
                            <th>功耗比例</th>
                            <th>内存带宽</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>FP32</td>
                            <td>32-bit</td>
                            <td>1.0x</td>
                            <td>1.0x</td>
                            <td>1.0x</td>
                            <td>1.0x</td>
                        </tr>
                        <tr>
                            <td>FP16</td>
                            <td>16-bit</td>
                            <td>~0.25x</td>
                            <td>~0.5x</td>
                            <td>~0.4x</td>
                            <td>0.5x</td>
                        </tr>
                        <tr>
                            <td>INT8</td>
                            <td>8-bit</td>
                            <td>~0.125x</td>
                            <td>~0.25x</td>
                            <td>~0.25x</td>
                            <td>0.25x</td>
                        </tr>
                        <tr>
                            <td>INT4</td>
                            <td>4-bit</td>
                            <td>~0.06x</td>
                            <td>~0.125x</td>
                            <td>~0.1x</td>
                            <td>0.125x</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="exercise">
                <h4>练习题集 2</h4>
                
                <div class="question">
                    <p><strong>题目2.1：</strong>某NPU的MAC阵列大小为32×32，计算一个[512, 1024] × [1024, 2048]的矩阵乘法需要多少个计算周期？假设每个周期可以完成阵列大小的MAC运算。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p>矩阵分块计算：</p>
                        <ol>
                            <li>结果矩阵大小：[512, 2048]</li>
                            <li>总MAC运算次数：512 × 1024 × 2048 = 1,073,741,824</li>
                            <li>MAC阵列每周期运算次数：32 × 32 = 1,024</li>
                            <li>分块数量：
                                <ul>
                                    <li>M维度分块：⌈512/32⌉ = 16</li>
                                    <li>N维度分块：⌈2048/32⌉ = 64</li>
                                    <li>K维度分块：⌈1024/32⌉ = 32</li>
                                </ul>
                            </li>
                            <li>总周期数：16 × 64 × 32 = 32,768 周期</li>
                        </ol>
                        <p><strong>验证：</strong>32,768 × 1,024 = 33,554,432 ≈ 1,073,741,824 / 32（考虑边界填充）</p>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目2.2：</strong>设计一个支持ReLU和Sigmoid激活函数的硬件模块。对于Sigmoid，使用4段分段线性逼近。给出RTL设计框架。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module ActivationUnit #(
    parameter DATA_WIDTH = 16,
    parameter FRAC_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    input wire [DATA_WIDTH-1:0] data_in,
    input wire [1:0] act_type,  // 00: bypass, 01: ReLU, 10: Sigmoid
    input wire valid_in,
    output reg [DATA_WIDTH-1:0] data_out,
    output reg valid_out
);

    // Sigmoid分段线性逼近参数（4段）
    // 区间: [-8, -2.5], [-2.5, 0], [0, 2.5], [2.5, 8]
    localparam signed [DATA_WIDTH-1:0] SIGMOID_X1 = -16'd2048;  // -8 (Q8.8)
    localparam signed [DATA_WIDTH-1:0] SIGMOID_X2 = -16'd640;   // -2.5
    localparam signed [DATA_WIDTH-1:0] SIGMOID_X3 = 16'd0;      // 0
    localparam signed [DATA_WIDTH-1:0] SIGMOID_X4 = 16'd640;    // 2.5
    localparam signed [DATA_WIDTH-1:0] SIGMOID_X5 = 16'd2048;   // 8
    
    // 斜率和截距（根据Sigmoid曲线拟合得出）
    localparam [DATA_WIDTH-1:0] SLOPE1 = 16'd13;    // 0.05
    localparam [DATA_WIDTH-1:0] SLOPE2 = 16'd51;    // 0.2
    localparam [DATA_WIDTH-1:0] SLOPE3 = 16'd64;    // 0.25
    localparam [DATA_WIDTH-1:0] SLOPE4 = 16'd51;    // 0.2
    
    wire signed [DATA_WIDTH-1:0] data_in_signed;
    reg [DATA_WIDTH-1:0] relu_out;
    reg [DATA_WIDTH-1:0] sigmoid_out;
    reg [2*DATA_WIDTH-1:0] mult_result;
    
    assign data_in_signed = data_in;
    
    // ReLU实现
    always @(*) begin
        if (data_in_signed < 0)
            relu_out = 0;
        else
            relu_out = data_in;
    end
    
    // Sigmoid分段线性逼近
    always @(*) begin
        if (data_in_signed <= SIGMOID_X1) begin
            sigmoid_out = 16'd0;  // 0
        end else if (data_in_signed <= SIGMOID_X2) begin
            mult_result = (data_in_signed - SIGMOID_X1) * SLOPE1;
            sigmoid_out = mult_result[DATA_WIDTH+FRAC_WIDTH-1:FRAC_WIDTH];
        end else if (data_in_signed <= SIGMOID_X3) begin
            mult_result = (data_in_signed - SIGMOID_X2) * SLOPE2;
            sigmoid_out = 16'd26 + mult_result[DATA_WIDTH+FRAC_WIDTH-1:FRAC_WIDTH];  // 0.1 + ...
        end else if (data_in_signed <= SIGMOID_X4) begin
            mult_result = data_in_signed * SLOPE3;
            sigmoid_out = 16'd128 + mult_result[DATA_WIDTH+FRAC_WIDTH-1:FRAC_WIDTH];  // 0.5 + ...
        end else if (data_in_signed <= SIGMOID_X5) begin
            mult_result = (data_in_signed - SIGMOID_X4) * SLOPE4;
            sigmoid_out = 16'd230 + mult_result[DATA_WIDTH+FRAC_WIDTH-1:FRAC_WIDTH];  // 0.9 + ...
        end else begin
            sigmoid_out = 16'd256;  // 1.0
        end
    end
    
    // 输出选择
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_out <= 0;
            valid_out <= 0;
        end else if (valid_in) begin
            case (act_type)
                2'b00: data_out <= data_in;      // Bypass
                2'b01: data_out <= relu_out;     // ReLU
                2'b10: data_out <= sigmoid_out;  // Sigmoid
                default: data_out <= data_in;
            endcase
            valid_out <= 1;
        end else begin
            valid_out <= 0;
        end
    end
endmodule
                        </div>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目2.3：</strong>比较Im2Col+GEMM和直接卷积两种实现方式。对于一个输入[224,224,3]、卷积核[3,3,3,64]的卷积层，计算Im2Col的内存开销。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>1. Im2Col内存开销计算：</strong></p>
                        <ol>
                            <li>输出特征图大小（假设stride=1, padding=1）：[224, 224, 64]</li>
                            <li>Im2Col展开后每个位置：3×3×3 = 27个元素</li>
                            <li>总位置数：224×224 = 50,176</li>
                            <li>Im2Col矩阵大小：[27, 50,176]</li>
                            <li>内存占用（FP32）：27 × 50,176 × 4 bytes = 5.42 MB</li>
                            <li>原始输入大小：224 × 224 × 3 × 4 bytes = 0.60 MB</li>
                            <li><strong>内存扩展比例：9.0倍</strong></li>
                        </ol>
                        
                        <p><strong>2. 两种方式对比：</strong></p>
                        <table>
                            <tr>
                                <th>特性</th>
                                <th>Im2Col + GEMM</th>
                                <th>直接卷积</th>
                            </tr>
                            <tr>
                                <td>内存开销</td>
                                <td>高（9倍扩展）</td>
                                <td>低（仅需Line Buffer）</td>
                            </tr>
                            <tr>
                                <td>计算效率</td>
                                <td>高（复用GEMM优化）</td>
                                <td>中等</td>
                            </tr>
                            <tr>
                                <td>硬件复杂度</td>
                                <td>简单（复用GEMM单元）</td>
                                <td>复杂（需要专用控制）</td>
                            </tr>
                            <tr>
                                <td>适用场景</td>
                                <td>大卷积核、服务器端</td>
                                <td>小卷积核、边缘设备</td>
                            </tr>
                        </table>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目2.4：</strong>设计一个简单的脉动阵列数据流控制器，支持权重固定（Weight Stationary）模式。要求能够处理8×8的MAC阵列。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module WeightStationaryController #(
    parameter ARRAY_SIZE = 8,
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 16
)(
    input wire clk,
    input wire rst_n,
    input wire start,
    
    // 配置接口
    input wire [ADDR_WIDTH-1:0] input_base_addr,
    input wire [ADDR_WIDTH-1:0] weight_base_addr,
    input wire [ADDR_WIDTH-1:0] output_base_addr,
    input wire [15:0] M, N, K,  // 矩阵维度
    
    // SRAM接口
    output reg [ADDR_WIDTH-1:0] input_addr,
    output reg input_rd_en,
    input wire [DATA_WIDTH*ARRAY_SIZE-1:0] input_data,
    
    output reg [ADDR_WIDTH-1:0] weight_addr,
    output reg weight_rd_en,
    input wire [DATA_WIDTH*ARRAY_SIZE-1:0] weight_data,
    
    output reg [ADDR_WIDTH-1:0] output_addr,
    output reg output_wr_en,
    output reg [DATA_WIDTH*ARRAY_SIZE-1:0] output_data,
    
    // MAC阵列接口
    output reg [DATA_WIDTH-1:0] input_to_array [0:ARRAY_SIZE-1],
    output reg [DATA_WIDTH-1:0] weight_to_array [0:ARRAY_SIZE-1][0:ARRAY_SIZE-1],
    output reg weight_load,
    output reg compute_en,
    input wire [DATA_WIDTH-1:0] output_from_array [0:ARRAY_SIZE-1],
    
    // 状态输出
    output reg busy,
    output reg done
);

    // 状态机定义
    localparam IDLE = 3'd0;
    localparam LOAD_WEIGHT = 3'd1;
    localparam COMPUTE = 3'd2;
    localparam STORE_OUTPUT = 3'd3;
    localparam NEXT_TILE = 3'd4;
    
    reg [2:0] state, next_state;
    reg [15:0] tile_m, tile_n, tile_k;  // 当前处理的分块索引
    reg [15:0] cycle_cnt;                // 周期计数器
    reg [15:0] k_iter;                   // K维度迭代计数
    
    // 计算分块数量
    wire [15:0] num_tile_m = (M + ARRAY_SIZE - 1) / ARRAY_SIZE;
    wire [15:0] num_tile_n = (N + ARRAY_SIZE - 1) / ARRAY_SIZE;
    wire [15:0] num_tile_k = (K + ARRAY_SIZE - 1) / ARRAY_SIZE;
    
    // 状态机
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // 状态转换逻辑
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (start)
                    next_state = LOAD_WEIGHT;
            end
            
            LOAD_WEIGHT: begin
                if (cycle_cnt == ARRAY_SIZE - 1)
                    next_state = COMPUTE;
            end
            
            COMPUTE: begin
                if (k_iter == K - 1)
                    next_state = STORE_OUTPUT;
            end
            
            STORE_OUTPUT: begin
                if (cycle_cnt == ARRAY_SIZE - 1)
                    next_state = NEXT_TILE;
            end
            
            NEXT_TILE: begin
                if (tile_n == num_tile_n - 1 && 
                    tile_m == num_tile_m - 1)
                    next_state = IDLE;
                else
                    next_state = LOAD_WEIGHT;
            end
        endcase
    end
    
    // 控制逻辑
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            tile_m <= 0;
            tile_n <= 0;
            tile_k <= 0;
            cycle_cnt <= 0;
            k_iter <= 0;
            weight_load <= 0;
            compute_en <= 0;
            busy <= 0;
            done <= 0;
        end else begin
            case (state)
                IDLE: begin
                    if (start) begin
                        tile_m <= 0;
                        tile_n <= 0;
                        tile_k <= 0;
                        busy <= 1;
                        done <= 0;
                    end
                end
                
                LOAD_WEIGHT: begin
                    // 加载权重到阵列
                    weight_load <= 1;
                    weight_rd_en <= 1;
                    weight_addr <= weight_base_addr + 
                                  (tile_n * ARRAY_SIZE + cycle_cnt) * K + 
                                  tile_k * ARRAY_SIZE;
                    
                    // 将权重数据分配到阵列
                    for (int i = 0; i < ARRAY_SIZE; i++) begin
                        for (int j = 0; j < ARRAY_SIZE; j++) begin
                            weight_to_array[i][j] <= weight_data[j*DATA_WIDTH +: DATA_WIDTH];
                        end
                    end
                    
                    cycle_cnt <= cycle_cnt + 1;
                    if (cycle_cnt == ARRAY_SIZE - 1) begin
                        cycle_cnt <= 0;
                        weight_load <= 0;
                        weight_rd_en <= 0;
                    end
                end
                
                COMPUTE: begin
                    // 启动计算
                    compute_en <= 1;
                    input_rd_en <= 1;
                    
                    // 读取输入数据
                    input_addr <= input_base_addr + 
                                 (tile_m * ARRAY_SIZE) * K + 
                                 k_iter;
                    
                    // 将输入数据送入阵列
                    for (int i = 0; i < ARRAY_SIZE; i++) begin
                        input_to_array[i] <= input_data[i*DATA_WIDTH +: DATA_WIDTH];
                    end
                    
                    k_iter <= k_iter + 1;
                    if (k_iter == K - 1) begin
                        k_iter <= 0;
                        compute_en <= 0;
                        input_rd_en <= 0;
                    end
                end
                
                STORE_OUTPUT: begin
                    // 存储输出结果
                    output_wr_en <= 1;
                    output_addr <= output_base_addr + 
                                  (tile_m * ARRAY_SIZE + cycle_cnt) * N + 
                                  tile_n * ARRAY_SIZE;
                    
                    // 从阵列收集输出
                    for (int i = 0; i < ARRAY_SIZE; i++) begin
                        output_data[i*DATA_WIDTH +: DATA_WIDTH] <= output_from_array[i];
                    end
                    
                    cycle_cnt <= cycle_cnt + 1;
                    if (cycle_cnt == ARRAY_SIZE - 1) begin
                        cycle_cnt <= 0;
                        output_wr_en <= 0;
                    end
                end
                
                NEXT_TILE: begin
                    // 移动到下一个分块
                    if (tile_n < num_tile_n - 1) begin
                        tile_n <= tile_n + 1;
                    end else begin
                        tile_n <= 0;
                        tile_m <= tile_m + 1;
                    end
                    
                    if (tile_n == num_tile_n - 1 && 
                        tile_m == num_tile_m - 1) begin
                        busy <= 0;
                        done <= 1;
                    end
                end
            endcase
        end
    end
endmodule
                        </div>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目2.5：</strong>分析深度可分离卷积（Depthwise Separable Convolution）的计算特点，说明为什么它对NPU的内存带宽要求更高。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>深度可分离卷积分解为两步：</strong></p>
                        <ol>
                            <li><strong>Depthwise Convolution：</strong>每个输入通道独立卷积
                                <ul>
                                    <li>计算量：H×W×C×K×K</li>
                                    <li>参数量：C×K×K</li>
                                </ul>
                            </li>
                            <li><strong>Pointwise Convolution (1×1卷积)：</strong>跨通道混合
                                <ul>
                                    <li>计算量：H×W×C×M</li>
                                    <li>参数量：C×M</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <p><strong>计算强度分析（Compute-to-Memory Ratio）：</strong></p>
                        <table>
                            <tr>
                                <th>卷积类型</th>
                                <th>计算量</th>
                                <th>内存访问量</th>
                                <th>计算强度</th>
                            </tr>
                            <tr>
                                <td>标准卷积</td>
                                <td>H×W×C×M×K×K</td>
                                <td>H×W×(C+M) + C×M×K×K</td>
                                <td>O(K×K)</td>
                            </tr>
                            <tr>
                                <td>Depthwise</td>
                                <td>H×W×C×K×K</td>
                                <td>H×W×C×2 + C×K×K</td>
                                <td>O(1)</td>
                            </tr>
                            <tr>
                                <td>Pointwise</td>
                                <td>H×W×C×M</td>
                                <td>H×W×(C+M) + C×M</td>
                                <td>O(1)</td>
                            </tr>
                        </table>
                        
                        <p><strong>为什么内存带宽要求更高：</strong></p>
                        <ol>
                            <li><strong>计算强度低：</strong>Depthwise卷积的计算强度为O(1)，而标准卷积为O(K²)。这意味着每次内存访问只能支撑很少的计算。</li>
                            <li><strong>数据复用率低：</strong>
                                <ul>
                                    <li>标准卷积中，每个输入被M个输出通道复用</li>
                                    <li>Depthwise中，每个输入只被1个输出通道使用</li>
                                </ul>
                            </li>
                            <li><strong>Memory Bound：</strong>NPU的计算单元经常处于空闲状态，等待数据从内存加载。</li>
                        </ol>
                        
                        <p><strong>优化策略：</strong></p>
                        <ul>
                            <li>增加片上缓存容量</li>
                            <li>使用更宽的内存接口</li>
                            <li>将Depthwise和Pointwise融合执行，减少中间结果的存储</li>
                            <li>使用专门的DMA引擎进行数据预取</li>
                        </ul>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目2.6：</strong>实现一个简单的INT8量化模块，支持对称量化和非对称量化两种模式。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module Quantizer #(
    parameter IN_WIDTH = 32,    // FP32输入
    parameter OUT_WIDTH = 8,    // INT8输出
    parameter SCALE_WIDTH = 16  // 定点scale表示
)(
    input wire clk,
    input wire rst_n,
    input wire [IN_WIDTH-1:0] fp_in,      // 浮点输入
    input wire [SCALE_WIDTH-1:0] scale,   // 量化尺度
    input wire [OUT_WIDTH-1:0] zero_point,// 零点（非对称量化）
    input wire symmetric_mode,            // 0: 非对称, 1: 对称
    input wire valid_in,
    
    output reg signed [OUT_WIDTH-1:0] int_out,  // 量化输出
    output reg valid_out
);

    // 内部信号
    reg [IN_WIDTH+SCALE_WIDTH-1:0] scaled_value;
    reg signed [IN_WIDTH-1:0] rounded_value;
    reg signed [IN_WIDTH-1:0] shifted_value;
    wire signed [OUT_WIDTH-1:0] saturated_value;
    
    // 饱和边界
    localparam signed [IN_WIDTH-1:0] MAX_INT8 = 127;
    localparam signed [IN_WIDTH-1:0] MIN_INT8 = -128;
    
    // Step 1: 缩放
    always @(*) begin
        // 假设scale是定点表示 (Q8.8格式)
        // 实际硬件中需要浮点转定点单元
        scaled_value = fp_in * scale;
    end
    
    // Step 2: 四舍五入
    always @(*) begin
        // 简化的四舍五入：加0.5后截断
        rounded_value = scaled_value[IN_WIDTH+SCALE_WIDTH-1:SCALE_WIDTH] + 
                       (scaled_value[SCALE_WIDTH-1] ? 1 : 0);
    end
    
    // Step 3: 加零点（非对称量化）
    always @(*) begin
        if (symmetric_mode)
            shifted_value = rounded_value;
        else
            shifted_value = rounded_value + {{(IN_WIDTH-OUT_WIDTH){1'b0}}, zero_point};
    end
    
    // Step 4: 饱和处理
    assign saturated_value = (shifted_value > MAX_INT8) ? MAX_INT8 :
                            (shifted_value < MIN_INT8) ? MIN_INT8 :
                            shifted_value[OUT_WIDTH-1:0];
    
    // 输出寄存
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            int_out <= 0;
            valid_out <= 0;
        end else if (valid_in) begin
            int_out <= saturated_value;
            valid_out <= 1;
        end else begin
            valid_out <= 0;
        end
    end
endmodule

// 反量化模块
module Dequantizer #(
    parameter IN_WIDTH = 8,     // INT8输入
    parameter OUT_WIDTH = 32,   // FP32输出
    parameter SCALE_WIDTH = 16
)(
    input wire clk,
    input wire rst_n,
    input wire signed [IN_WIDTH-1:0] int_in,
    input wire [SCALE_WIDTH-1:0] scale,
    input wire [IN_WIDTH-1:0] zero_point,
    input wire symmetric_mode,
    input wire valid_in,
    
    output reg [OUT_WIDTH-1:0] fp_out,
    output reg valid_out
);

    // 内部信号
    reg signed [OUT_WIDTH-1:0] shifted_value;
    reg [OUT_WIDTH+SCALE_WIDTH-1:0] scaled_value;
    
    // Step 1: 减去零点
    always @(*) begin
        if (symmetric_mode)
            shifted_value = {{(OUT_WIDTH-IN_WIDTH){int_in[IN_WIDTH-1]}}, int_in};
        else
            shifted_value = {{(OUT_WIDTH-IN_WIDTH){int_in[IN_WIDTH-1]}}, int_in} - 
                           {{(OUT_WIDTH-IN_WIDTH){1'b0}}, zero_point};
    end
    
    // Step 2: 乘以scale
    always @(*) begin
        scaled_value = shifted_value * scale;
    end
    
    // 输出寄存
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            fp_out <= 0;
            valid_out <= 0;
        end else if (valid_in) begin
            // 提取定点结果的整数部分
            fp_out <= scaled_value[OUT_WIDTH+SCALE_WIDTH-1:SCALE_WIDTH];
            valid_out <= 1;
        end else begin
            valid_out <= 0;
        end
    end
endmodule
                        </div>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目2.7：</strong>计算并比较不同批处理大小（batch size）对NPU效率的影响。假设处理一个ResNet50的第一个卷积层，输入[N,224,224,3]，卷积核[7,7,3,64]。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>不同batch size的影响分析：</strong></p>
                        
                        <table>
                            <tr>
                                <th>Batch Size</th>
                                <th>计算量(GFLOPs)</th>
                                <th>内存占用(MB)</th>
                                <th>并行度</th>
                                <th>数据复用率</th>
                            </tr>
                            <tr>
                                <td>1</td>
                                <td>0.118</td>
                                <td>输入: 0.6<br>输出: 3.2</td>
                                <td>低</td>
                                <td>权重复用率: 1x</td>
                            </tr>
                            <tr>
                                <td>8</td>
                                <td>0.944</td>
                                <td>输入: 4.8<br>输出: 25.6</td>
                                <td>中</td>
                                <td>权重复用率: 8x</td>
                            </tr>
                            <tr>
                                <td>32</td>
                                <td>3.776</td>
                                <td>输入: 19.2<br>输出: 102.4</td>
                                <td>高</td>
                                <td>权重复用率: 32x</td>
                            </tr>
                            <tr>
                                <td>128</td>
                                <td>15.104</td>
                                <td>输入: 76.8<br>输出: 409.6</td>
                                <td>很高</td>
                                <td>权重复用率: 128x</td>
                            </tr>
                        </table>
                        
                        <p><strong>计算过程：</strong></p>
                        <ol>
                            <li>输出大小：(224-7+2*3)/2+1 = 112，即[N,112,112,64]</li>
                            <li>每个输出像素的计算量：7×7×3×2 = 294 FLOPs</li>
                            <li>总计算量：N×112×112×64×294</li>
                        </ol>
                        
                        <p><strong>NPU效率影响：</strong></p>
                        <ol>
                            <li><strong>小batch size (1-8)：</strong>
                                <ul>
                                    <li>权重复用率低，需要频繁重新加载权重</li>
                                    <li>MAC阵列利用率低，很多PE空闲</li>
                                    <li>适合边缘设备，响应延迟低</li>
                                </ul>
                            </li>
                            <li><strong>中等batch size (16-32)：</strong>
                                <ul>
                                    <li>权重复用率适中</li>
                                    <li>MAC阵列利用率较好</li>
                                    <li>内存占用在可接受范围</li>
                                </ul>
                            </li>
                            <li><strong>大batch size (64-128)：</strong>
                                <ul>
                                    <li>权重复用率高，摊销权重加载开销</li>
                                    <li>MAC阵列充分利用</li>
                                    <li>可能受限于片上SRAM容量</li>
                                    <li>适合云端训练场景</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <p><strong>优化建议：</strong></p>
                        <ul>
                            <li>边缘NPU：优化batch=1的性能，采用权重固定数据流</li>
                            <li>云端NPU：支持大batch，增加片上SRAM容量</li>
                            <li>动态批处理：根据负载自适应调整batch size</li>
                        </ul>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目2.8：</strong>设计一个简单的稀疏计算单元，能够跳过零值计算。给出零检测和地址生成的RTL框架。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module SparseComputeUnit #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 16,
    parameter PE_NUM = 16       // 并行PE数量
)(
    input wire clk,
    input wire rst_n,
    
    // 输入数据和索引
    input wire [DATA_WIDTH-1:0] activation_data [0:PE_NUM-1],
    input wire [DATA_WIDTH-1:0] weight_data [0:PE_NUM-1],
    input wire [PE_NUM-1:0] activation_valid,  // 非零标志
    input wire [PE_NUM-1:0] weight_valid,      // 非零标志
    input wire data_valid,
    
    // 稀疏索引
    input wire [ADDR_WIDTH-1:0] activation_indices [0:PE_NUM-1],
    input wire [ADDR_WIDTH-1:0] weight_indices [0:PE_NUM-1],
    
    // 输出接口
    output reg [2*DATA_WIDTH-1:0] result_data [0:PE_NUM-1],
    output reg [ADDR_WIDTH-1:0] result_indices [0:PE_NUM-1],
    output reg [PE_NUM-1:0] result_valid,
    output reg output_valid
);

    // 内部信号
    reg [PE_NUM-1:0] compute_mask;
    wire [2*DATA_WIDTH-1:0] mult_results [0:PE_NUM-1];
    reg [4:0] valid_count;
    reg [4:0] compact_indices [0:PE_NUM-1];
    
    // 生成计算掩码（只有当激活值和权重都非零时才计算）
    always @(*) begin
        compute_mask = activation_valid & weight_valid;
    end
    
    // 并行乘法器
    genvar i;
    generate
        for (i = 0; i < PE_NUM; i = i + 1) begin : mult_gen
            assign mult_results[i] = activation_data[i] * weight_data[i];
        end
    endgenerate
    
    // 计算有效结果数量
    always @(*) begin
        valid_count = 0;
        for (int j = 0; j < PE_NUM; j = j + 1) begin
            if (compute_mask[j])
                valid_count = valid_count + 1;
        end
    end
    
    // 压缩有效结果（去除零值结果）
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            output_valid <= 0;
            result_valid <= 0;
        end else if (data_valid) begin
            int compact_idx = 0;
            
            // 压缩非零结果
            for (int j = 0; j < PE_NUM; j = j + 1) begin
                if (compute_mask[j]) begin
                    result_data[compact_idx] <= mult_results[j];
                    result_indices[compact_idx] <= activation_indices[j];
                    result_valid[compact_idx] <= 1'b1;
                    compact_idx = compact_idx + 1;
                end
            end
            
            // 清空未使用的输出
            for (int j = compact_idx; j < PE_NUM; j = j + 1) begin
                result_data[j] <= 0;
                result_indices[j] <= 0;
                result_valid[j] <= 1'b0;
            end
            
            output_valid <= 1;
        end else begin
            output_valid <= 0;
        end
    end
endmodule

// 稀疏数据加载器
module SparseDataLoader #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 16,
    parameter SPARSE_FORMAT = "CSR"  // CSR或COO格式
)(
    input wire clk,
    input wire rst_n,
    
    // 内存接口
    output reg [ADDR_WIDTH-1:0] mem_addr,
    output reg mem_rd_en,
    input wire [31:0] mem_data,
    
    // 稀疏数据输出
    output reg [DATA_WIDTH-1:0] value_out,
    output reg [ADDR_WIDTH-1:0] row_idx_out,
    output reg [ADDR_WIDTH-1:0] col_idx_out,
    output reg data_valid_out,
    
    // 控制接口
    input wire start,
    input wire [ADDR_WIDTH-1:0] base_addr,
    input wire [15:0] nnz,  // 非零元素数量
    output reg done
);

    // CSR格式存储结构
    // values[nnz]: 非零值数组
    // col_indices[nnz]: 列索引数组
    // row_ptrs[rows+1]: 行指针数组
    
    reg [15:0] element_cnt;
    reg [2:0] load_state;
    
    localparam IDLE = 3'd0;
    localparam LOAD_VALUE = 3'd1;
    localparam LOAD_COL_IDX = 3'd2;
    localparam OUTPUT = 3'd3;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            load_state <= IDLE;
            element_cnt <= 0;
            done <= 0;
            mem_rd_en <= 0;
            data_valid_out <= 0;
        end else begin
            case (load_state)
                IDLE: begin
                    if (start) begin
                        element_cnt <= 0;
                        load_state <= LOAD_VALUE;
                        done <= 0;
                    end
                end
                
                LOAD_VALUE: begin
                    mem_rd_en <= 1;
                    mem_addr <= base_addr + element_cnt;
                    load_state <= LOAD_COL_IDX;
                end
                
                LOAD_COL_IDX: begin
                    value_out <= mem_data[DATA_WIDTH-1:0];
                    mem_addr <= base_addr + nnz + element_cnt;
                    load_state <= OUTPUT;
                end
                
                OUTPUT: begin
                    col_idx_out <= mem_data[ADDR_WIDTH-1:0];
                    data_valid_out <= 1;
                    mem_rd_en <= 0;
                    
                    element_cnt <= element_cnt + 1;
                    if (element_cnt == nnz - 1) begin
                        load_state <= IDLE;
                        done <= 1;
                    end else begin
                        load_state <= LOAD_VALUE;
                    end
                end
            endcase
        end
    end
endmodule
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="chapter3" class="chapter">
            <h2>第3章：NPU系统架构</h2>
            
            <h3>3.1 整体架构设计</h3>
            
            <h4>3.1.1 NPU系统组成</h4>
            <p>现代NPU系统通常包含以下核心组件：</p>
            
            <div class="code-block">
NPU系统架构层次：
┌─────────────────────────────────────────┐
│          Host Interface (PCIe/AXI)       │
├─────────────────────────────────────────┤
│         Command Processor & Scheduler    │
├─────────────────────────────────────────┤
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │ Compute │  │ Memory  │  │  DMA    │ │
│  │ Cluster │  │ System  │  │ Engine  │ │
│  └─────────┘  └─────────┘  └─────────┘ │
├─────────────────────────────────────────┤
│         On-chip Interconnect (NoC)      │
├─────────────────────────────────────────┤
│         External Memory Interface        │
└─────────────────────────────────────────┘
            </div>

            <h4>3.1.2 设计考虑因素</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>设计维度</th>
                            <th>关键指标</th>
                            <th>架构影响</th>
                            <th>优化方向</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>算力</td>
                            <td>TOPS/TFLOPS</td>
                            <td>MAC阵列规模</td>
                            <td>增加PE数量、提高频率</td>
                        </tr>
                        <tr>
                            <td>能效</td>
                            <td>TOPS/W</td>
                            <td>数据复用、电压调节</td>
                            <td>减少数据移动、低功耗设计</td>
                        </tr>
                        <tr>
                            <td>灵活性</td>
                            <td>支持的算子类型</td>
                            <td>可编程性</td>
                            <td>VLIW/SIMD混合架构</td>
                        </tr>
                        <tr>
                            <td>成本</td>
                            <td>$/TOPS</td>
                            <td>芯片面积</td>
                            <td>架构简化、工艺选择</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>3.2 计算单元设计</h3>
            
            <h4>3.2.1 计算集群架构</h4>
            <p>NPU的计算能力主要来自于大规模并行的计算集群：</p>
            
            <div class="code-block">
// 典型的计算集群组织
Compute Cluster
├── MAC Array (脉动阵列或其他拓扑)
│   ├── PE[0][0] ... PE[0][N-1]
│   ├── PE[1][0] ... PE[1][N-1]
│   └── PE[M-1][0] ... PE[M-1][N-1]
├── Vector Unit (向量处理单元)
│   ├── SIMD ALU
│   ├── Special Function Unit
│   └── Reduction Unit
├── Local Memory
│   ├── Weight Buffer
│   ├── Input Buffer
│   └── Output Buffer
└── Control Unit
    ├── Instruction Decoder
    ├── Address Generator
    └── Synchronization Logic
            </div>

            <h4>3.2.2 处理单元(PE)设计</h4>
            <div class="info-box">
                <p><strong>PE设计原则：</strong></p>
                <ul>
                    <li>面积效率：最大化MAC密度</li>
                    <li>功耗优化：时钟门控、操作数隔离</li>
                    <li>数据通路：支持多种精度(INT8/16, FP16/32)</li>
                    <li>流水线：平衡延迟和吞吐量</li>
                </ul>
            </div>

            <h3>3.3 存储层次结构</h3>
            
            <h4>3.3.1 存储层次设计</h4>
            <div class="code-block">
存储层次（从快到慢）：
1. Register File (RF)
   - 容量: ~1KB per PE
   - 延迟: 1 cycle
   - 带宽: 极高
   
2. L1 Buffer (私有)
   - 容量: 16-64KB per cluster
   - 延迟: 2-4 cycles
   - 用途: 权重/激活值缓存

3. L2 Buffer (共享)
   - 容量: 256KB-2MB
   - 延迟: 8-16 cycles
   - 用途: 跨cluster数据共享

4. Global Buffer
   - 容量: 4-32MB
   - 延迟: 20-40 cycles
   - 用途: 大型特征图存储

5. External Memory (DDR/HBM)
   - 容量: GB级别
   - 延迟: 100+ cycles
   - 带宽: 受限（关键瓶颈）
            </div>

            <h4>3.3.2 内存访问优化</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>优化技术</th>
                            <th>原理</th>
                            <th>硬件支持</th>
                            <th>效果</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>数据预取</td>
                            <td>提前加载数据到片上</td>
                            <td>硬件预取器</td>
                            <td>隐藏内存延迟</td>
                        </tr>
                        <tr>
                            <td>双缓冲</td>
                            <td>计算与数据传输重叠</td>
                            <td>乒乓Buffer</td>
                            <td>提高利用率</td>
                        </tr>
                        <tr>
                            <td>数据压缩</td>
                            <td>减少传输数据量</td>
                            <td>压缩/解压单元</td>
                            <td>节省带宽</td>
                        </tr>
                        <tr>
                            <td>地址映射</td>
                            <td>优化数据布局</td>
                            <td>可编程DMA</td>
                            <td>提高局部性</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>3.4 互连网络设计</h3>
            
            <h4>3.4.1 片上网络拓扑</h4>
            <div class="code-block">
常见的NoC拓扑结构：

1. Mesh (网格)
   优点：规则、可扩展
   缺点：跳数多、延迟大
   
   [R]--[R]--[R]--[R]
    |    |    |    |
   [R]--[R]--[R]--[R]
    |    |    |    |
   [R]--[R]--[R]--[R]

2. Torus (环面)
   优点：降低平均跳数
   缺点：布线复杂
   
3. Tree (树形)
   优点：层次化、易于广播
   缺点：根节点瓶颈

4. Crossbar (交叉开关)
   优点：单跳连接
   缺点：面积O(N²)，不可扩展
            </div>

            <h4>3.4.2 数据通信模式</h4>
            <p>NPU中的典型通信模式：</p>
            <ul>
                <li><strong>单播(Unicast)：</strong>点对点数据传输</li>
                <li><strong>多播(Multicast)：</strong>权重广播到多个PE</li>
                <li><strong>归约(Reduction)：</strong>部分和累加</li>
                <li><strong>全局同步：</strong>barrier同步</li>
            </ul>

            <div class="warning-box">
                <p><strong>设计挑战：</strong>如何在保证高带宽的同时控制功耗和面积开销是NoC设计的核心挑战。</p>
            </div>

            <div class="exercise">
                <h4>练习题集 3</h4>
                
                <div class="question">
                    <p><strong>题目3.1：</strong>设计一个NPU的存储层次结构。给定：MAC阵列32×32，主频1GHz，外部内存带宽100GB/s。计算各级存储的容量和带宽需求。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>1. 计算MAC阵列带宽需求：</strong></p>
                        <ul>
                            <li>MAC阵列规模：32×32 = 1024个MAC</li>
                            <li>每个MAC每周期需要：2个输入(weight, activation) + 1个输出</li>
                            <li>假设INT8精度：每个数据1字节</li>
                            <li>总带宽需求：1024 × 3 × 1B × 1GHz = 3.072 TB/s</li>
                        </ul>
                        
                        <p><strong>2. 存储层次设计：</strong></p>
                        <table>
                            <tr>
                                <th>存储级别</th>
                                <th>容量</th>
                                <th>带宽</th>
                                <th>设计理由</th>
                            </tr>
                            <tr>
                                <td>L0 (Register)</td>
                                <td>1KB/PE</td>
                                <td>3TB/s</td>
                                <td>直接供给MAC运算</td>
                            </tr>
                            <tr>
                                <td>L1 Buffer</td>
                                <td>64KB</td>
                                <td>1TB/s</td>
                                <td>存储当前tile的数据</td>
                            </tr>
                            <tr>
                                <td>L2 Buffer</td>
                                <td>2MB</td>
                                <td>400GB/s</td>
                                <td>预取下一个tile</td>
                            </tr>
                            <tr>
                                <td>Global Buffer</td>
                                <td>16MB</td>
                                <td>200GB/s</td>
                                <td>存储整层的部分数据</td>
                            </tr>
                            <tr>
                                <td>External Mem</td>
                                <td>16GB</td>
                                <td>100GB/s</td>
                                <td>给定约束</td>
                            </tr>
                        </table>
                        
                        <p><strong>3. 带宽逐级递减原理：</strong></p>
                        <ul>
                            <li>数据复用降低上级需求</li>
                            <li>时分复用共享带宽</li>
                            <li>预取隐藏延迟</li>
                        </ul>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目3.2：</strong>比较Weight Stationary、Output Stationary和Row Stationary三种数据流的优缺点，并给出适用场景。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <table>
                            <tr>
                                <th>数据流</th>
                                <th>固定数据</th>
                                <th>优点</th>
                                <th>缺点</th>
                                <th>适用场景</th>
                            </tr>
                            <tr>
                                <td>Weight Stationary (WS)</td>
                                <td>权重</td>
                                <td>• 权重复用最大化<br>• 减少权重读取能耗<br>• 实现简单</td>
                                <td>• 输入/输出需要大量移动<br>• 对大feature map不友好</td>
                                <td>• 全连接层<br>• 小batch推理<br>• 权重>>激活值</td>
                            </tr>
                            <tr>
                                <td>Output Stationary (OS)</td>
                                <td>部分和</td>
                                <td>• 减少部分和读写<br>• 累加在PE本地完成<br>• 适合深度网络</td>
                                <td>• 权重和输入都需移动<br>• 控制复杂度高</td>
                                <td>• 深度卷积<br>• 输出通道数多<br>• ResNet类结构</td>
                            </tr>
                            <tr>
                                <td>Row Stationary (RS)</td>
                                <td>卷积行</td>
                                <td>• 所有数据类型都有复用<br>• 能量效率最优<br>• 适应性强</td>
                                <td>• 实现最复杂<br>• 需要复杂的控制器<br>• 面积开销大</td>
                                <td>• 通用场景<br>• 各种卷积层<br>• 需要灵活性</td>
                            </tr>
                        </table>
                        
                        <p><strong>具体例子：</strong></p>
                        <p>对于1×1卷积（Pointwise）：</p>
                        <ul>
                            <li>WS最优：因为没有空间维度的复用</li>
                            <li>RS退化为WS</li>
                        </ul>
                        <p>对于3×3卷积：</p>
                        <ul>
                            <li>RS最优：可以复用所有维度的数据</li>
                            <li>OS次优：如果输出通道很多</li>
                        </ul>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目3.3：</strong>设计一个4×4 Mesh NoC的路由器。要求支持XY路由算法，包含5个端口（东南西北+本地）。给出RTL框架。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module MeshRouter #(
    parameter DATA_WIDTH = 32,
    parameter ADDR_WIDTH = 8,
    parameter X_COORD = 0,
    parameter Y_COORD = 0,
    parameter FIFO_DEPTH = 4
)(
    input wire clk,
    input wire rst_n,
    
    // 5个输入端口 (North, South, East, West, Local)
    input wire [DATA_WIDTH-1:0] data_in_n, data_in_s, data_in_e, data_in_w, data_in_l,
    input wire valid_in_n, valid_in_s, valid_in_e, valid_in_w, valid_in_l,
    output wire ready_out_n, ready_out_s, ready_out_e, ready_out_w, ready_out_l,
    
    // 5个输出端口
    output wire [DATA_WIDTH-1:0] data_out_n, data_out_s, data_out_e, data_out_w, data_out_l,
    output wire valid_out_n, valid_out_s, valid_out_e, valid_out_w, valid_out_l,
    input wire ready_in_n, ready_in_s, ready_in_e, ready_in_w, ready_in_l
);

    // 数据包格式：[DATA | SRC_Y | SRC_X | DST_Y | DST_X]
    localparam DST_X_START = 0;
    localparam DST_X_END = 3;
    localparam DST_Y_START = 4;
    localparam DST_Y_END = 7;
    
    // 内部信号
    wire [4:0] route_req_n, route_req_s, route_req_e, route_req_w, route_req_l;
    wire [4:0] grant_n, grant_s, grant_e, grant_w, grant_l;
    
    // 输入FIFO
    wire [DATA_WIDTH-1:0] fifo_data_n, fifo_data_s, fifo_data_e, fifo_data_w, fifo_data_l;
    wire fifo_empty_n, fifo_empty_s, fifo_empty_e, fifo_empty_w, fifo_empty_l;
    wire fifo_rd_en_n, fifo_rd_en_s, fifo_rd_en_e, fifo_rd_en_w, fifo_rd_en_l;
    
    // FIFO实例化（每个输入端口一个）
    genvar i;
    generate
        // North port FIFO
        FIFO #(.WIDTH(DATA_WIDTH), .DEPTH(FIFO_DEPTH)) fifo_n (
            .clk(clk), .rst_n(rst_n),
            .wr_en(valid_in_n), .wr_data(data_in_n),
            .rd_en(fifo_rd_en_n), .rd_data(fifo_data_n),
            .empty(fifo_empty_n), .full(~ready_out_n)
        );
        // 类似地实例化其他4个FIFO...
    endgenerate
    
    // XY路由计算模块
    XYRouteCompute route_comp_n (
        .current_x(X_COORD), .current_y(Y_COORD),
        .dest_x(fifo_data_n[DST_X_END:DST_X_START]),
        .dest_y(fifo_data_n[DST_Y_END:DST_Y_START]),
        .valid(!fifo_empty_n),
        .route_request(route_req_n)  // 5-bit one-hot
    );
    // 为其他端口实例化路由计算...
    
    // 5×5交叉开关仲裁器
    SwitchAllocator allocator (
        .clk(clk), .rst_n(rst_n),
        // 来自5个输入端口的请求
        .req_n(route_req_n), .req_s(route_req_s), 
        .req_e(route_req_e), .req_w(route_req_w), .req_l(route_req_l),
        // 授权信号
        .grant_n(grant_n), .grant_s(grant_s),
        .grant_e(grant_e), .grant_w(grant_w), .grant_l(grant_l)
    );
    
    // 交叉开关矩阵
    Crossbar5x5 xbar (
        // 输入数据
        .data_in({fifo_data_l, fifo_data_w, fifo_data_e, fifo_data_s, fifo_data_n}),
        // 控制信号
        .sel_n(grant_n), .sel_s(grant_s), 
        .sel_e(grant_e), .sel_w(grant_w), .sel_l(grant_l),
        // 输出数据
        .data_out_n(data_out_n), .data_out_s(data_out_s),
        .data_out_e(data_out_e), .data_out_w(data_out_w), .data_out_l(data_out_l)
    );
    
    // 输出valid信号生成
    assign valid_out_n = |grant_n & ready_in_n;
    assign valid_out_s = |grant_s & ready_in_s;
    assign valid_out_e = |grant_e & ready_in_e;
    assign valid_out_w = |grant_w & ready_in_w;
    assign valid_out_l = |grant_l & ready_in_l;
    
    // FIFO读使能
    assign fifo_rd_en_n = |(grant_n & {ready_in_l, ready_in_w, ready_in_e, ready_in_s, ready_in_n});
    // 类似处理其他端口...

endmodule

// XY路由计算模块
module XYRouteCompute #(
    parameter COORD_WIDTH = 4
)(
    input [COORD_WIDTH-1:0] current_x, current_y,
    input [COORD_WIDTH-1:0] dest_x, dest_y,
    input valid,
    output reg [4:0] route_request  // [Local, West, East, South, North]
);
    always @(*) begin
        route_request = 5'b00000;
        if (valid) begin
            if (dest_x == current_x && dest_y == current_y) begin
                route_request[4] = 1'b1;  // Local
            end else if (dest_x < current_x) begin
                route_request[3] = 1'b1;  // West
            end else if (dest_x > current_x) begin
                route_request[2] = 1'b1;  // East
            end else if (dest_y < current_y) begin
                route_request[1] = 1'b1;  // South
            end else begin
                route_request[0] = 1'b1;  // North
            end
        end
    end
endmodule
                        </div>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目3.4：</strong>计算一个NPU执行ResNet50一个残差块所需的片上存储容量。假设特征图大小为56×56×256，使用3×3卷积。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>ResNet50残差块结构：</strong></p>
                        <pre>
Input (56×56×256)
    │
    ├─────────────────────┐
    │                     │
    ▼                     │
Conv1 (1×1, 64)          │
    │                     │
    ▼                     │
Conv2 (3×3, 64)          │
    │                     │
    ▼                     │
Conv3 (1×1, 256)         │
    │                     │
    ▼                     │
    + ←──────────────────┘
    │
Output (56×56×256)
                        </pre>
                        
                        <p><strong>存储需求计算（INT8）：</strong></p>
                        <table>
                            <tr>
                                <th>数据类型</th>
                                <th>尺寸</th>
                                <th>容量(KB)</th>
                                <th>说明</th>
                            </tr>
                            <tr>
                                <td>输入特征图</td>
                                <td>56×56×256</td>
                                <td>784</td>
                                <td>需要保存用于残差连接</td>
                            </tr>
                            <tr>
                                <td>Conv1权重</td>
                                <td>1×1×256×64</td>
                                <td>16</td>
                                <td>Pointwise卷积</td>
                            </tr>
                            <tr>
                                <td>Conv1输出</td>
                                <td>56×56×64</td>
                                <td>196</td>
                                <td>中间特征图</td>
                            </tr>
                            <tr>
                                <td>Conv2权重</td>
                                <td>3×3×64×64</td>
                                <td>36</td>
                                <td>Depthwise卷积</td>
                            </tr>
                            <tr>
                                <td>Conv2输出</td>
                                <td>56×56×64</td>
                                <td>196</td>
                                <td>中间特征图</td>
                            </tr>
                            <tr>
                                <td>Conv3权重</td>
                                <td>1×1×64×256</td>
                                <td>16</td>
                                <td>Pointwise卷积</td>
                            </tr>
                            <tr>
                                <td>Conv3输出</td>
                                <td>56×56×256</td>
                                <td>784</td>
                                <td>用于残差加法</td>
                            </tr>
                            <tr>
                                <td><strong>总计</strong></td>
                                <td>-</td>
                                <td><strong>2028</strong></td>
                                <td>约2MB</td>
                            </tr>
                        </table>
                        
                        <p><strong>优化策略：</strong></p>
                        <ol>
                            <li><strong>层融合：</strong>将Conv1输出直接送入Conv2，节省196KB</li>
                            <li><strong>流水线执行：</strong>分块处理，每块只需存储部分特征图</li>
                            <li><strong>权重压缩：</strong>使用稀疏或量化技术减少权重存储</li>
                            <li><strong>双缓冲：</strong>计算当前块时预取下一块数据</li>
                        </ol>
                        
                        <p><strong>实际需求：</strong>考虑优化后，片上存储约需1MB即可高效执行。</p>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目3.5：</strong>设计一个DMA控制器，支持2D数据传输和简单的数据重排。要求支持stride访问模式。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module DMA2D #(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 128,  // 128-bit宽接口
    parameter BURST_LEN = 16     // 最大突发长度
)(
    input wire clk,
    input wire rst_n,
    
    // 配置接口
    input wire [ADDR_WIDTH-1:0] src_addr,      // 源地址
    input wire [ADDR_WIDTH-1:0] dst_addr,      // 目标地址
    input wire [15:0] width,                   // 2D传输宽度（字节）
    input wire [15:0] height,                  // 2D传输高度
    input wire [15:0] src_stride,              // 源跨步（字节）
    input wire [15:0] dst_stride,              // 目标跨步（字节）
    input wire [2:0] transfer_mode,            // 传输模式
    input wire start,
    output reg done,
    output reg busy,
    
    // 源内存接口（AXI-like）
    output reg [ADDR_WIDTH-1:0] src_araddr,
    output reg src_arvalid,
    input wire src_arready,
    input wire [DATA_WIDTH-1:0] src_rdata,
    input wire src_rvalid,
    output reg src_rready,
    
    // 目标内存接口
    output reg [ADDR_WIDTH-1:0] dst_awaddr,
    output reg dst_awvalid,
    input wire dst_awready,
    output reg [DATA_WIDTH-1:0] dst_wdata,
    output reg dst_wvalid,
    input wire dst_wready,
    input wire dst_bvalid,
    output reg dst_bready
);

    // 传输模式定义
    localparam MODE_LINEAR = 3'd0;      // 线性传输
    localparam MODE_2D_BLOCK = 3'd1;    // 2D块传输
    localparam MODE_TRANSPOSE = 3'd2;   // 转置
    localparam MODE_INTERLEAVE = 3'd3;  // 交织
    
    // 状态机
    localparam IDLE = 3'd0;
    localparam CALC_ADDR = 3'd1;
    localparam READ_REQ = 3'd2;
    localparam READ_DATA = 3'd3;
    localparam WRITE_REQ = 3'd4;
    localparam WRITE_DATA = 3'd5;
    localparam WRITE_RESP = 3'd6;
    localparam NEXT_LINE = 3'd7;
    
    reg [2:0] state, next_state;
    
    // 内部计数器
    reg [15:0] row_cnt, col_cnt;
    reg [15:0] burst_cnt;
    reg [ADDR_WIDTH-1:0] current_src_addr, current_dst_addr;
    
    // 数据缓冲（支持突发传输）
    reg [DATA_WIDTH-1:0] data_buffer [0:BURST_LEN-1];
    reg [4:0] buffer_wr_ptr, buffer_rd_ptr;
    reg [4:0] buffer_count;
    
    // 地址计算单元
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_src_addr <= 0;
            current_dst_addr <= 0;
        end else if (state == CALC_ADDR) begin
            case (transfer_mode)
                MODE_LINEAR: begin
                    current_src_addr <= src_addr + (row_cnt * src_stride) + col_cnt;
                    current_dst_addr <= dst_addr + (row_cnt * dst_stride) + col_cnt;
                end
                MODE_2D_BLOCK: begin
                    current_src_addr <= src_addr + (row_cnt * src_stride) + col_cnt;
                    current_dst_addr <= dst_addr + (row_cnt * dst_stride) + col_cnt;
                end
                MODE_TRANSPOSE: begin
                    // 转置：源按行读，目标按列写
                    current_src_addr <= src_addr + (row_cnt * src_stride) + col_cnt;
                    current_dst_addr <= dst_addr + (col_cnt * dst_stride) + row_cnt * (DATA_WIDTH/8);
                end
                MODE_INTERLEAVE: begin
                    // 交织模式：用于通道重排
                    // 实现NCHW -> NHWC转换等
                    current_src_addr <= src_addr + calculate_interleave_src(row_cnt, col_cnt);
                    current_dst_addr <= dst_addr + calculate_interleave_dst(row_cnt, col_cnt);
                end
            endcase
        end
    end
    
    // 状态机控制
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (start)
                    next_state = CALC_ADDR;
            end
            
            CALC_ADDR: begin
                next_state = READ_REQ;
            end
            
            READ_REQ: begin
                if (src_arready)
                    next_state = READ_DATA;
            end
            
            READ_DATA: begin
                if (src_rvalid && burst_cnt == calculate_burst_len() - 1)
                    next_state = WRITE_REQ;
            end
            
            WRITE_REQ: begin
                if (dst_awready)
                    next_state = WRITE_DATA;
            end
            
            WRITE_DATA: begin
                if (dst_wready && buffer_rd_ptr == buffer_wr_ptr - 1)
                    next_state = WRITE_RESP;
            end
            
            WRITE_RESP: begin
                if (dst_bvalid)
                    next_state = NEXT_LINE;
            end
            
            NEXT_LINE: begin
                if (row_cnt == height - 1 && col_cnt >= width - (DATA_WIDTH/8))
                    next_state = IDLE;
                else
                    next_state = CALC_ADDR;
            end
        endcase
    end
    
    // 数据路径控制
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            row_cnt <= 0;
            col_cnt <= 0;
            burst_cnt <= 0;
            buffer_wr_ptr <= 0;
            buffer_rd_ptr <= 0;
            done <= 0;
            busy <= 0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 0;
                    if (start) begin
                        row_cnt <= 0;
                        col_cnt <= 0;
                        busy <= 1;
                    end
                end
                
                READ_DATA: begin
                    if (src_rvalid) begin
                        data_buffer[buffer_wr_ptr] <= apply_transform(src_rdata);
                        buffer_wr_ptr <= buffer_wr_ptr + 1;
                        burst_cnt <= burst_cnt + 1;
                    end
                end
                
                WRITE_DATA: begin
                    if (dst_wready) begin
                        buffer_rd_ptr <= buffer_rd_ptr + 1;
                    end
                end
                
                NEXT_LINE: begin
                    col_cnt <= col_cnt + (DATA_WIDTH/8) * calculate_burst_len();
                    if (col_cnt >= width - (DATA_WIDTH/8)) begin
                        col_cnt <= 0;
                        row_cnt <= row_cnt + 1;
                        if (row_cnt == height - 1) begin
                            done <= 1;
                            busy <= 0;
                        end
                    end
                    burst_cnt <= 0;
                    buffer_wr_ptr <= 0;
                    buffer_rd_ptr <= 0;
                end
            endcase
        end
    end
    
    // AXI接口信号
    always @(*) begin
        // 默认值
        src_arvalid = 0;
        src_rready = 0;
        dst_awvalid = 0;
        dst_wvalid = 0;
        dst_bready = 0;
        
        case (state)
            READ_REQ: begin
                src_araddr = current_src_addr;
                src_arvalid = 1;
            end
            
            READ_DATA: begin
                src_rready = 1;
            end
            
            WRITE_REQ: begin
                dst_awaddr = current_dst_addr;
                dst_awvalid = 1;
            end
            
            WRITE_DATA: begin
                dst_wdata = data_buffer[buffer_rd_ptr];
                dst_wvalid = 1;
            end
            
            WRITE_RESP: begin
                dst_bready = 1;
            end
        endcase
    end
    
    // 辅助函数
    function [4:0] calculate_burst_len;
        begin
            // 根据剩余数据量计算突发长度
            if (width - col_cnt >= BURST_LEN * (DATA_WIDTH/8))
                calculate_burst_len = BURST_LEN;
            else
                calculate_burst_len = (width - col_cnt) / (DATA_WIDTH/8);
        end
    endfunction
    
    function [DATA_WIDTH-1:0] apply_transform;
        input [DATA_WIDTH-1:0] data;
        begin
            // 根据模式应用数据变换（如字节序转换等）
            case (transfer_mode)
                MODE_LINEAR, MODE_2D_BLOCK: 
                    apply_transform = data;
                MODE_TRANSPOSE:
                    apply_transform = transpose_bytes(data);
                MODE_INTERLEAVE:
                    apply_transform = interleave_channels(data);
                default:
                    apply_transform = data;
            endcase
        end
    endfunction

endmodule
                        </div>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目3.6：</strong>分析Tensor Core架构相比传统MAC阵列的优势，并计算其理论性能提升。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>1. 架构对比：</strong></p>
                        <table>
                            <tr>
                                <th>特性</th>
                                <th>传统MAC阵列</th>
                                <th>Tensor Core</th>
                            </tr>
                            <tr>
                                <td>基本运算</td>
                                <td>标量MAC: c += a × b</td>
                                <td>矩阵MAC: D = A×B + C</td>
                            </tr>
                            <tr>
                                <td>运算粒度</td>
                                <td>1×1</td>
                                <td>4×4×4 (或更大)</td>
                            </tr>
                            <tr>
                                <td>每周期运算量</td>
                                <td>2 ops (乘+加)</td>
                                <td>128 ops (4×4×4×2)</td>
                            </tr>
                            <tr>
                                <td>数据复用</td>
                                <td>有限</td>
                                <td>矩阵级复用</td>
                            </tr>
                        </table>
                        
                        <p><strong>2. Tensor Core工作原理：</strong></p>
                        <div class="code-block">
// Tensor Core执行的运算
D[4×4] = A[4×4] × B[4×4] + C[4×4]

// 分解为标量运算：
for i in 0..3:
    for j in 0..3:
        sum = 0
        for k in 0..3:
            sum += A[i][k] * B[k][j]
        D[i][j] = sum + C[i][j]

// 总运算数：4×4×4 = 64次乘法，48次加法，16次加法
// 共128 ops
                        </div>
                        
                        <p><strong>3. 性能提升计算：</strong></p>
                        <p>假设：</p>
                        <ul>
                            <li>传统MAC阵列：16×16 = 256个MAC单元</li>
                            <li>Tensor Core阵列：4×4 = 16个Tensor Core</li>
                            <li>相同的总硬件面积</li>
                        </ul>
                        
                        <p>性能对比：</p>
                        <ul>
                            <li>传统MAC：256 × 2 = 512 ops/cycle</li>
                            <li>Tensor Core：16 × 128 = 2048 ops/cycle</li>
                            <li><strong>理论加速比：4×</strong></li>
                        </ul>
                        
                        <p><strong>4. 优势分析：</strong></p>
                        <ol>
                            <li><strong>更高的计算密度：</strong>相同面积下提供更多运算</li>
                            <li><strong>更好的数据复用：</strong>矩阵运算天然具有数据复用</li>
                            <li><strong>减少控制开销：</strong>一条指令完成更多运算</li>
                            <li><strong>更适合深度学习：</strong>直接匹配GEMM运算模式</li>
                        </ol>
                        
                        <p><strong>5. 限制条件：</strong></p>
                        <ul>
                            <li>需要对齐到4×4块大小</li>
                            <li>不适合稀疏或不规则运算</li>
                            <li>精度限制（通常是混合精度）</li>
                            <li>编程模型相对复杂</li>
                        </ul>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目3.7：</strong>设计一个简单的NPU指令集架构(ISA)，包含计算、数据传输和控制指令。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>NPU ISA设计：</strong></p>
                        
                        <p><strong>1. 指令格式（32-bit）：</strong></p>
                        <div class="code-block">
[31:28] | [27:24] | [23:16] | [15:8] | [7:0]
OPCODE  | FLAGS   | DEST    | SRC1   | SRC2/IMM

OPCODE: 4-bit 操作码
FLAGS:  4-bit 标志位（精度、饱和模式等）
DEST:   8-bit 目标寄存器/地址
SRC1:   8-bit 源操作数1
SRC2:   8-bit 源操作数2或立即数
                        </div>
                        
                        <p><strong>2. 指令集分类：</strong></p>
                        
                        <p><strong>A. 计算指令：</strong></p>
                        <table>
                            <tr>
                                <th>助记符</th>
                                <th>操作码</th>
                                <th>功能</th>
                                <th>示例</th>
                            </tr>
                            <tr>
                                <td>MMUL</td>
                                <td>0x0</td>
                                <td>矩阵乘法</td>
                                <td>MMUL R0, M1, M2</td>
                            </tr>
                            <tr>
                                <td>CONV</td>
                                <td>0x1</td>
                                <td>卷积运算</td>
                                <td>CONV R0, I1, W1</td>
                            </tr>
                            <tr>
                                <td>MADD</td>
                                <td>0x2</td>
                                <td>矩阵加法</td>
                                <td>MADD R0, M1, M2</td>
                            </tr>
                            <tr>
                                <td>ACTV</td>
                                <td>0x3</td>
                                <td>激活函数</td>
                                <td>ACTV.RELU R0, R1</td>
                            </tr>
                            <tr>
                                <td>POOL</td>
                                <td>0x4</td>
                                <td>池化操作</td>
                                <td>POOL.MAX R0, I1</td>
                            </tr>
                        </table>
                        
                        <p><strong>B. 数据传输指令：</strong></p>
                        <table>
                            <tr>
                                <th>助记符</th>
                                <th>操作码</th>
                                <th>功能</th>
                                <th>示例</th>
                            </tr>
                            <tr>
                                <td>LOAD</td>
                                <td>0x8</td>
                                <td>从内存加载</td>
                                <td>LOAD R0, [ADDR]</td>
                            </tr>
                            <tr>
                                <td>STORE</td>
                                <td>0x9</td>
                                <td>存储到内存</td>
                                <td>STORE [ADDR], R0</td>
                            </tr>
                            <tr>
                                <td>DMA</td>
                                <td>0xA</td>
                                <td>DMA传输</td>
                                <td>DMA DST, SRC, LEN</td>
                            </tr>
                            <tr>
                                <td>BCAST</td>
                                <td>0xB</td>
                                <td>广播数据</td>
                                <td>BCAST R0, VAL</td>
                            </tr>
                        </table>
                        
                        <p><strong>C. 控制指令：</strong></p>
                        <table>
                            <tr>
                                <th>助记符</th>
                                <th>操作码</th>
                                <th>功能</th>
                                <th>示例</th>
                            </tr>
                            <tr>
                                <td>SYNC</td>
                                <td>0xC</td>
                                <td>同步屏障</td>
                                <td>SYNC</td>
                            </tr>
                            <tr>
                                <td>LOOP</td>
                                <td>0xD</td>
                                <td>循环控制</td>
                                <td>LOOP CNT, LABEL</td>
                            </tr>
                            <tr>
                                <td>JUMP</td>
                                <td>0xE</td>
                                <td>跳转</td>
                                <td>JUMP LABEL</td>
                            </tr>
                            <tr>
                                <td>HALT</td>
                                <td>0xF</td>
                                <td>停止执行</td>
                                <td>HALT</td>
                            </tr>
                        </table>
                        
                        <p><strong>3. 寄存器组织：</strong></p>
                        <div class="code-block">
// 通用寄存器
R0-R31: 32个通用寄存器（标量）
M0-M15: 16个矩阵寄存器（每个可存储32×32矩阵）
V0-V15: 16个向量寄存器（每个256元素）

// 特殊寄存器
PC:     程序计数器
SP:     栈指针
STATUS: 状态寄存器
CONFIG: 配置寄存器（精度模式等）
                        </div>
                        
                        <p><strong>4. 示例程序（卷积层）：</strong></p>
                        <div class="code-block">
// 执行一个3×3卷积层
// 输入: I0, 权重: W0, 输出: O0

    // 配置卷积参数
    LOAD  R0, #3        // 卷积核大小
    LOAD  R1, #1        // stride
    LOAD  R2, #1        // padding
    
    // 加载数据
    DMA   M0, [input_addr], #input_size
    DMA   M1, [weight_addr], #weight_size
    
    // 执行卷积
    CONV  M2, M0, M1    // 使用配置的参数
    
    // 应用激活函数
    ACTV.RELU M3, M2
    
    // 存储结果
    DMA   [output_addr], M3, #output_size
    
    // 同步确保完成
    SYNC
    HALT
                        </div>
                        
                        <p><strong>5. ISA特点：</strong></p>
                        <ul>
                            <li><strong>CISC风格：</strong>单条指令完成复杂操作</li>
                            <li><strong>数据并行：</strong>原生支持矩阵/向量操作</li>
                            <li><strong>内存层次感知：</strong>显式DMA管理</li>
                            <li><strong>灵活精度：</strong>通过FLAGS支持多精度</li>
                            <li><strong>硬件加速：</strong>直接映射到硬件单元</li>
                        </ul>
                    </div>
                </div>

                <div class="question">
                    <p><strong>题目3.8：</strong>评估不同的功耗优化技术对NPU的影响。给定一个100 TOPS的NPU，分析各种技术的节能潜力。</p>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <p><strong>答案：</strong></p>
                        <p><strong>基准NPU规格：</strong></p>
                        <ul>
                            <li>峰值性能：100 TOPS (INT8)</li>
                            <li>功耗：50W (2 TOPS/W)</li>
                            <li>工艺：7nm</li>
                            <li>频率：1GHz</li>
                        </ul>
                        
                        <p><strong>功耗优化技术分析：</strong></p>
                        <table>
                            <tr>
                                <th>优化技术</th>
                                <th>原理</th>
                                <th>节能潜力</th>
                                <th>性能影响</th>
                                <th>实现复杂度</th>
                            </tr>
                            <tr>
                                <td>时钟门控</td>
                                <td>关闭空闲单元时钟</td>
                                <td>10-20%</td>
                                <td>无</td>
                                <td>低</td>
                            </tr>
                            <tr>
                                <td>电源门控</td>
                                <td>关闭空闲单元电源</td>
                                <td>20-30%</td>
                                <td>唤醒延迟</td>
                                <td>中</td>
                            </tr>
                            <tr>
                                <td>DVFS</td>
                                <td>动态调节电压频率</td>
                                <td>30-40%</td>
                                <td>性能下降</td>
                                <td>中</td>
                            </tr>
                            <tr>
                                <td>近阈值计算</td>
                                <td>降低工作电压</td>
                                <td>50-70%</td>
                                <td>频率降低</td>
                                <td>高</td>
                            </tr>
                            <tr>
                                <td>数据压缩</td>
                                <td>减少数据传输</td>
                                <td>15-25%</td>
                                <td>轻微</td>
                                <td>中</td>
                            </tr>
                            <tr>
                                <td>稀疏计算</td>
                                <td>跳过零值运算</td>
                                <td>20-60%</td>
                                <td>依赖稀疏度</td>
                                <td>高</td>
                            </tr>
                            <tr>
                                <td>精度缩放</td>
                                <td>动态调整精度</td>
                                <td>25-40%</td>
                                <td>精度损失</td>
                                <td>中</td>
                            </tr>
                        </table>
                        
                        <p><strong>功耗分解（50W总功耗）：</strong></p>
                        <div class="code-block">
计算单元：    20W (40%)
├── MAC阵列： 15W
└── 向量单元： 5W

存储系统：    15W (30%)
├── SRAM：    10W
└── 接口：     5W

互连网络：     8W (16%)

控制逻辑：     4W (8%)

IO接口：       3W (6%)
                        </div>
                        
                        <p><strong>组合优化方案：</strong></p>
                        <ol>
                            <li><strong>方案A（保守型）：</strong>
                                <ul>
                                    <li>时钟门控 + 基础DVFS</li>
                                    <li>预期节能：25%</li>
                                    <li>功耗降至：37.5W</li>
                                    <li>能效提升至：2.67 TOPS/W</li>
                                </ul>
                            </li>
                            <li><strong>方案B（平衡型）：</strong>
                                <ul>
                                    <li>时钟/电源门控 + DVFS + 数据压缩</li>
                                    <li>预期节能：45%</li>
                                    <li>功耗降至：27.5W</li>
                                    <li>能效提升至：3.64 TOPS/W</li>
                                </ul>
                            </li>
                            <li><strong>方案C（激进型）：</strong>
                                <ul>
                                    <li>全部技术组合 + 近阈值计算</li>
                                    <li>预期节能：70%</li>
                                    <li>功耗降至：15W（但性能降至70 TOPS）</li>
                                    <li>能效提升至：4.67 TOPS/W</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <p><strong>实施建议：</strong></p>
                        <ul>
                            <li>优先实施低复杂度高收益技术（时钟门控）</li>
                            <li>根据应用场景选择DVFS策略</li>
                            <li>稀疏计算需要软硬件协同优化</li>
                            <li>考虑功耗-性能-面积(PPA)平衡</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
    </div>

    <script>
        // JavaScript for collapsible answers
        function toggleAnswer(button) {
            const answer = button.nextElementSibling;
            if (answer.classList.contains('show')) {
                answer.classList.remove('show');
                button.textContent = '显示答案';
            } else {
                answer.classList.add('show');
                button.textContent = '隐藏答案';
            }
        }

        // Add event listeners to all toggle buttons
        document.addEventListener('DOMContentLoaded', function() {
            const toggleButtons = document.querySelectorAll('.toggle-answer');
            toggleButtons.forEach(button => {
                button.addEventListener('click', function() {
                    toggleAnswer(this);
                });
            });
        });

        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>