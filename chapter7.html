<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第7章：验证与测试 - NPU设计教程</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .nav-bar {
            background: #34495e;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .nav-bar ul {
            list-style: none;
            display: flex;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        .nav-bar li {
            margin: 0 15px;
        }

        .nav-bar a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .nav-bar a:hover {
            background: #2c3e50;
        }

        .nav-bar .current {
            background: #2c3e50;
            font-weight: bold;
        }

        .chapter {
            background: white;
            margin: 20px 0;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chapter h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .chapter h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        .chapter h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
        }
        
        /* Language label */
        .code-block::before {
            content: attr(data-language);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            color: #95a5a6;
            text-transform: uppercase;
        }
        
        /* Syntax highlighting classes */
        .code-block .keyword { color: #e74c3c; font-weight: bold; }
        .code-block .type { color: #3498db; }
        .code-block .comment { color: #95a5a6; font-style: italic; }
        .code-block .number { color: #e67e22; }
        .code-block .string { color: #2ecc71; }
        .code-block .function { color: #3498db; }

        .exercise {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .exercise h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .question {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .answer {
            margin-top: 10px;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 5px;
            display: none;
            border-left: 4px solid #4caf50;
        }

        .answer.show {
            display: block;
        }
        
        .hint {
            margin: 10px 0;
            padding: 10px 15px;
            background: #fff8dc;
            border-left: 4px solid #ffa500;
            border-radius: 5px;
            font-size: 0.95em;
        }
        
        .hint summary {
            cursor: pointer;
            font-weight: bold;
            color: #ff8c00;
            outline: none;
        }
        
        .hint summary:hover {
            color: #ff6347;
        }
        
        .hint p {
            margin-top: 10px;
            color: #666;
        }

        .toggle-answer {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.3s;
        }

        .toggle-answer:hover {
            background: #2980b9;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .chapter-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
        }

        .chapter-nav a {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .chapter-nav a:hover {
            background: #2980b9;
        }

        .chapter-nav .prev::before {
            content: "← ";
        }

        .chapter-nav .next::after {
            content: " →";
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            header {
                padding: 20px 10px;
            }
            
            header h1 {
                font-size: 1.5em;
            }
            
            .chapter {
                padding: 15px;
                margin: 10px 0;
            }
            
            .chapter h2 {
                font-size: 1.5em;
            }
            
            .chapter h3 {
                font-size: 1.2em;
            }
            
            .nav-bar ul {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .nav-bar li {
                margin: 5px;
            }
            
            .code-block {
                padding: 10px;
                font-size: 12px;
            }
            
            table {
                font-size: 14px;
            }
            
            th, td {
                padding: 8px;
            }
        }

        /* List styles for proper indentation */
        .chapter ul, .chapter ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .chapter li {
            margin-bottom: 8px;
            line-height: 1.8;
        }
        
        .chapter ul ul, .chapter ol ol, .chapter ul ol, .chapter ol ul {
            margin-left: 20px;
            margin-top: 5px;
        }
        
        .info-box ul, .warning-box ul, .answer ul {
            margin-left: 20px;
        }
        
        .info-box li, .warning-box li, .answer li {
            margin-bottom: 10px;
        }
        
        /* Keep nav-bar lists unstyled */
        .nav-bar ul {
            margin-left: 0;
        }
        
        .nav-bar li {
            margin-bottom: 0;
        }
    </style>
    <script>
        // Syntax highlighting functions
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        function highlightSyntax() {
            const codeBlocks = document.querySelectorAll('.code-block');
            
            codeBlocks.forEach(block => {
                const content = block.textContent;
                let language = 'text';
                let highlighted = content;
                
                // Auto-detect language based on content
                if (content.includes('module ') || content.includes('always @') || content.includes('wire ') || content.includes('reg ')) {
                    language = 'verilog';
                    highlighted = highlightVerilog(content);
                } else if (content.includes('import ') || content.includes('def ') || content.includes('class ')) {
                    language = 'python';
                    highlighted = highlightPython(content);
                }
                
                block.innerHTML = highlighted;
                block.classList.add(language);
                block.setAttribute('data-language', language);
            });
        }
        
        function highlightVerilog(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments with placeholders
            code = code.replace(/(\/\/.*$|\/\*[\s\S]*?\*\/)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings with placeholders
            code = code.replace(/("[^"]*")/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(module|endmodule|input|output|wire|reg|always|assign|begin|end|if|else|for|while|parameter|posedge|negedge)\b/g;
            const types = /\b(bit|logic|byte|shortint|int|longint|integer|time|real)\b/g;
            const numbers = /\b(\d+'[hbdo][\da-fA-F_]+|\d+)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(types, '<span class="type">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        function highlightPython(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments
            code = code.replace(/(#.*$)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings
            code = code.replace(/("[^"]*"|'[^']*')/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(and|as|assert|break|class|continue|def|del|elif|else|except|False|finally|for|from|global|if|import|in|is|lambda|None|not|or|pass|raise|return|True|try|while|with|yield)\b/g;
            const builtins = /\b(abs|all|any|bin|bool|dict|float|format|hex|input|int|len|list|map|max|min|open|print|range|round|set|sorted|str|sum|tuple|type|zip)\b/g;
            const numbers = /\b(\d+\.?\d*)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(builtins, '<span class="function">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        // Toggle answer visibility
        document.addEventListener('DOMContentLoaded', function() {
            highlightSyntax();
            
            const toggleButtons = document.querySelectorAll('.toggle-answer');
            toggleButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const answer = this.nextElementSibling;
                    answer.classList.toggle('show');
                    this.textContent = answer.classList.contains('show') ? '隐藏答案' : '显示答案';
                });
            });
        });
    </script>
</head>
<body>
    <header>
        <h1>第7章：验证与测试</h1>
    </header>
    
    <nav class="nav-bar">
        <ul>
            <li><a href="index.html">首页</a></li>
            <li><a href="chapter1.html">第1章</a></li>
            <li><a href="chapter2.html">第2章</a></li>
            <li><a href="chapter3.html">第3章</a></li>
            <li><a href="chapter4.html">第4章</a></li>
            <li><a href="chapter5.html">第5章</a></li>
            <li><a href="chapter6.html">第6章</a></li>
            <li><a href="chapter7.html" class="current">第7章</a></li>
            <li><a href="chapter8.html">第8章</a></li>
            <li><a href="chapter9.html">第9章</a></li>
            <li><a href="chapter10.html">第10章</a></li>
            <li><a href="chapter11.html">第11章</a></li>
            <li><a href="chapter12.html">第12章</a></li>
        </ul>
    </nav>
    
    <div class="container">
        <div class="chapter">
            <h2>第7章：验证与测试</h2>
            
            <p>本章深入探讨NPU芯片的验证策略、测试方法和关键技术，涵盖从RTL验证到后硅验证的完整流程。</p>

            <h3>7.0 制定NPU验证计划</h3>
            
            <p>验证计划是指导整个验证工作的纲领性文档，定义了验证的目标、范围、策略和资源分配。一个完善的验证计划能够确保验证工作的系统性和完整性。验证就像是芯片设计的“质量保证系统”——它不仅要确保功能正确，还要确保在各种极端条件下系统都能稳定工作。</p>
            
            <p>在NPU验证领域，业界有一个著名的经验法则：“验证工作量通常占整个项目的60-70%”。这个数字在NPU这样的复杂系统中可能更高。例如，Google TPU的验证团队规模是设计团队的1.5-2倍，而且验证周期通常比设计周期还要长3-6个月。这些数字背后反映的是一个残酷的现实：一个未被发现的bug可能导致数亿美元的损失。</p>
            
            <p>现代NPU验证计划的制定需要考虑诸多特殊挑战：深度学习算法的快速演进（新的网络结构层出不穷）、数据精度的多样性（从INT4到FP32）、巨大的配置空间（各种卷积核大小、步长、填充等）。这些特点使得NPU的验证比传统处理器更加复杂。</p>
            
            <h4>7.0.1 验证目标与范围</h4>
            <p>定义清晰的验证目标和范围是成功验证的第一步。这就像是在地图上划定探索区域——如果范围太大，资源会被稀释；如果范围太小，可能会遗漏重要的风险点。一个经典的教训来自NVIDIA的早期项目：他们在验证计划中忽略了某些“边缘”配置（如非常规的tensor形状），结果在客户部署时出现了严重问题，不得不通过软件补丁来规避。</p>
            <div class="info-box">
                <p><strong>NPU验证计划模板</strong></p>
                <ul>
                    <li><strong>项目概述：</strong>
                        <ul>
                            <li>NPU架构描述（计算核心数量、存储层次、互连拓扑）</li>
                            <li>目标应用场景（边缘推理、数据中心训练等）</li>
                            <li>关键性能指标（TOPS、功耗、面积）</li>
                        </ul>
                    </li>
                    <li><strong>验证范围定义：</strong>
                        <ul>
                            <li>功能验证：指令集、数据流、控制逻辑</li>
                            <li>性能验证：吞吐量、延迟、带宽利用率</li>
                            <li>功耗验证：动态功耗、静态功耗、功耗管理</li>
                            <li>兼容性验证：软件栈、编译器、驱动程序</li>
                        </ul>
                    </li>
                    <li><strong>验证边界：</strong>
                        <ul>
                            <li>包含的模块：MAC阵列、DMA控制器、调度器、互连</li>
                            <li>排除的模块：外部DDR控制器、PCIe接口（假设已验证）</li>
                            <li>配置范围：支持的数据类型、批处理大小、网络层类型</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <h4>7.0.2 验证策略与方法选择</h4>
            <p>选择合适的验证策略就像是选择武器——不同的挑战需要不同的工具。NPU验证的特殊性在于它涵盖了从底层硬件到上层软件的整个栈。一个类比是：如果把NPU比作一辆汽车，那么验证不仅要测试引擎、变速箱等部件，还要测试整车在各种路况下的表现，甚至要考虑驾驶员（软件）的操作习惯。</p>
            <div class="info-box">
                <p><strong>验证策略金字塔：</strong></p>
                <div style="text-align: center; margin: 20px 0;">
                    <pre style="display: inline-block; text-align: left;">
                    ┌─────────────────┐
                    │  系统级验证      │ ← 软硬件协同、真实应用
                    ├─────────────────┤
                    │  子系统验证      │ ← 多模块集成、数据流
                    ├─────────────────┤  
                    │   模块验证       │ ← UVM环境、功能覆盖
                    ├─────────────────┤
                    │   单元验证       │ ← 形式化验证、定向测试
                    └─────────────────┘
                    </pre>
                </div>
                <p><strong>方法选择准则：</strong></p>
                <ul>
                    <li><strong>形式化验证：</strong>适用于控制密集型模块（如仲裁器、FSM）</li>
                    <li><strong>约束随机验证：</strong>适用于数据路径和配置空间大的模块</li>
                    <li><strong>定向测试：</strong>适用于特定场景和边界条件</li>
                    <li><strong>硬件加速：</strong>适用于系统级性能验证和软件开发</li>
                </ul>
            </div>
            
            <h4>7.0.3 覆盖率驱动的验证</h4>
            <p>覆盖率驱动验证（Coverage-Driven Verification）是现代验证方法学的核心。它的基本理念是：“你无法改进你不能测量的东西”。覆盖率就像是验证工作的“仪表盘”，告诉我们已经探索了设计空间的哪些部分，还有哪些“盲区”。</p>
            
            <p>在NPU验证中，传统的代码覆盖率已经不够用了。我们需要更复杂的覆盖率指标：算法覆盖率（测试了多少种神经网络层）、数据模式覆盖率（各种输入数据分布）、配置空间覆盖率（各种参数组合）、性能场景覆盖率（低负载、高负载、突发流量）等。Apple的Neural Engine验证团队开发了一套复杂的覆盖率模型，包含超过100个维度，才能确保对各种使用场景的全面覆盖。</p>
            <div class="code-block">
// NPU验证计划中的覆盖率定义示例
class npu_coverage_plan;
    
    // 功能覆盖率定义
    covergroup functional_coverage;
        // 指令类型覆盖
        instruction_cp: coverpoint instruction_type {
            bins conv_ops[] = {CONV_1x1, CONV_3x3, CONV_5x5, CONV_DW};
            bins pooling_ops[] = {MAX_POOL_2x2, AVG_POOL_2x2, GLOBAL_POOL};
            bins activation_ops[] = {RELU, RELU6, SIGMOID, TANH};
            bins elementwise_ops[] = {ADD, MUL, CONCAT};
        }
        
        // 数据类型覆盖
        datatype_cp: coverpoint data_type {
            bins integer_types[] = {INT8, UINT8, INT16};
            bins float_types[] = {FP16, BF16, FP32};
            bins mixed_precision = {INT8_INT32};
        }
        
        // 张量大小覆盖
        tensor_size_cp: coverpoint tensor_size {
            bins small = {[1:32]};
            bins medium = {[33:224]};
            bins large = {[225:1024]};
            bins boundary[] = {1, 32, 64, 128, 224, 256, 512, 1024};
        }
        
        // 交叉覆盖：指令×数据类型
        inst_datatype_cross: cross instruction_cp, datatype_cp {
            // 排除不支持的组合
            illegal_bins invalid = binsof(instruction_cp.conv_ops) && 
                                  binsof(datatype_cp.float_types);
        }
        
        // 配置覆盖
        config_cp: coverpoint dma_mode {
            bins normal_mode = {DMA_NORMAL};
            bins scatter_gather = {DMA_SCATTER_GATHER};
            bins circular_buffer = {DMA_CIRCULAR};
        }
        
        // 错误场景覆盖
        error_cp: coverpoint error_injection {
            bins memory_ecc_error = {MEM_ECC_SINGLE, MEM_ECC_DOUBLE};
            bins bus_error = {AXI_DECODE_ERROR, AXI_SLAVE_ERROR};
            bins overflow = {MAC_OVERFLOW, ACCUMULATOR_OVERFLOW};
        }
    endgroup
    
    // 代码覆盖率目标
    class code_coverage_goals;
        parameter LINE_COVERAGE_TARGET = 95;      // 行覆盖率目标
        parameter BRANCH_COVERAGE_TARGET = 90;    // 分支覆盖率目标
        parameter TOGGLE_COVERAGE_TARGET = 85;    // 翻转覆盖率目标
        parameter FSM_COVERAGE_TARGET = 100;      // 状态机覆盖率目标
        parameter ASSERTION_COVERAGE_TARGET = 100; // 断言覆盖率目标
    endclass
    
    // 验证里程碑定义
    typedef enum {
        MILESTONE_UNIT_COMPLETE,      // 单元验证完成
        MILESTONE_INTEGRATION_READY,  // 集成验证就绪
        MILESTONE_RANDOM_STABLE,      // 随机测试稳定
        MILESTONE_COVERAGE_MET,       // 覆盖率达标
        MILESTONE_PERFORMANCE_VERIFIED, // 性能验证完成
        MILESTONE_TAPE_OUT_READY      // 流片就绪
    } verification_milestone_e;
    
endclass
            </div>
            
            <h4>7.0.4 资源规划与进度管理</h4>
            <div class="info-box">
                <p><strong>验证资源估算：</strong></p>
                <table class="comparison-table">
                    <tr>
                        <th>验证任务</th>
                        <th>工作量(人周)</th>
                        <th>所需资源</th>
                        <th>关键依赖</th>
                    </tr>
                    <tr>
                        <td>验证环境搭建</td>
                        <td>4-6</td>
                        <td>高级验证工程师×2</td>
                        <td>设计规格完成</td>
                    </tr>
                    <tr>
                        <td>IP级验证</td>
                        <td>8-12</td>
                        <td>验证工程师×4</td>
                        <td>RTL代码稳定</td>
                    </tr>
                    <tr>
                        <td>系统级验证</td>
                        <td>12-16</td>
                        <td>系统工程师×3</td>
                        <td>子系统验证完成</td>
                    </tr>
                    <tr>
                        <td>性能验证</td>
                        <td>6-8</td>
                        <td>性能工程师×2</td>
                        <td>功能验证稳定</td>
                    </tr>
                    <tr>
                        <td>回归测试维护</td>
                        <td>持续</td>
                        <td>验证工程师×1</td>
                        <td>CI/CD环境</td>
                    </tr>
                </table>
                
                <p><strong>计算资源需求：</strong></p>
                <ul>
                    <li>仿真服务器：128核CPU、512GB内存 × 10台</li>
                    <li>形式化验证：专用服务器 × 2台</li>
                    <li>FPGA原型：Xilinx VU19P × 4块</li>
                    <li>许可证：VCS/Verdi × 20席、Jasper × 4席</li>
                </ul>
            </div>

            <h3>7.1 验证策略与方法学</h3>
            
            <p>NPU验证是一个复杂的系统工程，需要结合多种验证方法和技术来确保设计的正确性。现代NPU验证已经发展成为一门融合了计算机科学、数学、统计学和工程学的交叉学科。它不仅要求验证工程师精通硬件设计，还要理解深度学习算法、熟悉软件堆栈，甚至要掌握一些形式化方法。</p>
            
            <p>一个有趣的现象是，许多领先的AI芯片公司都在招聘拥有机器学习背景的验证工程师。这是因为NPU的验证不仅要检查功能正确性，还要验证数值精度。例如，一个量化的神经网络在NPU上的输出可能与参考模型存在微小差异，但这些差异是否可接受？这需要深入理解算法的容错性和应用场景的需求。</p>
            
            <p>验证策略的选择直接影响项目的成败。Google在开发第一代TPU时，采用了“应用驱动验证”的策略——直接使用真实的TensorFlow模型作为测试用例。这种方法虽然增加了验证的复杂度，但确保了TPU在实际应用中的可用性。相比之下，一些初创公司过度依赖合成测试向量，结果在部署时遇到了大量未预料的问题。</p>
            
            <h4>7.1.1 UVM验证环境</h4>
            <p>UVM（Universal Verification Methodology）提供了标准化的验证组件和可重用的验证环境架构。在NPU验证中，UVM就像是一个精密的工厂流水线——它能够持续不断地生产测试用例，执行测试，收集结果，并分析覆盖率。</p>
            
            <p>NPU的UVM环境设计面临着独特的挑战。与传统处理器不同，NPU的输入不是指令流，而是大量的张量数据。这意味着我们需要创建能够生成各种大小、形状和数据分布的测试激励。此外，由于深度学习计算的数值特性，我们还需要在UVM环境中集成参考模型（通常是Python或C++实现），这增加了环境的复杂度。</p>
            
            <div class="code-block">
// NPU卷积模块的高级UVM测试环境
class conv_sequence_item extends uvm_sequence_item;
    `uvm_object_utils(conv_sequence_item)
    
    // 输入数据
    rand bit [7:0] input_data[];
    rand bit [7:0] weight_data[];
    rand int kernel_size;
    rand int stride;
    rand int padding;
    
    // 错误注入控制
    rand bit enable_error_injection;
    rand error_type_e error_type;
    rand int error_location;
    
    // 错误类型定义
    typedef enum {
        NO_ERROR,
        DATA_CORRUPTION,      // 数据损坏
        WEIGHT_CORRUPTION,    // 权重损坏
        OVERFLOW_ERROR,       // 溢出错误
        BUS_ERROR,           // 总线错误
        MEMORY_ECC_ERROR     // 内存ECC错误
    } error_type_e;
    
    // 约束
    constraint valid_params_c {
        kernel_size inside {1, 3, 5, 7};
        stride inside {1, 2, 4};
        padding inside {0, 1, 2, 3};
        input_data.size() == 224*224*3;  // 假设输入是224x224x3
        weight_data.size() == kernel_size*kernel_size*3*64;  // 输出64通道
    }
    
    // 错误注入约束
    constraint error_injection_c {
        enable_error_injection dist {0 := 90, 1 := 10};  // 10%概率注入错误
        if (enable_error_injection) {
            error_type dist {
                NO_ERROR := 0,
                DATA_CORRUPTION := 30,
                WEIGHT_CORRUPTION := 20,
                OVERFLOW_ERROR := 20,
                BUS_ERROR := 20,
                MEMORY_ECC_ERROR := 10
            };
            error_location inside {[0:input_data.size()-1]};
        } else {
            error_type == NO_ERROR;
        }
    }
    
    function new(string name = "conv_sequence_item");
        super.new(name);
    endfunction
    
    // 后随机化处理
    function void post_randomize();
        // 根据错误类型注入错误
        if (enable_error_injection) begin
            case (error_type)
                DATA_CORRUPTION: begin
                    // 随机翻转数据中的几个比特
                    for (int i = 0; i < 5; i++) begin
                        int idx = $urandom_range(0, input_data.size()-1);
                        input_data[idx] = input_data[idx] ^ (1 << $urandom_range(0, 7));
                    end
                end
                WEIGHT_CORRUPTION: begin
                    // 将某些权重设置为极值
                    for (int i = 0; i < 10; i++) begin
                        int idx = $urandom_range(0, weight_data.size()-1);
                        weight_data[idx] = $urandom_range(0, 1) ? 8'hFF : 8'h00;
                    end
                end
            endcase
        end
    endfunction
endclass

// 增强型卷积模块Driver（支持错误注入）
class conv_driver extends uvm_driver #(conv_sequence_item);
    `uvm_component_utils(conv_driver)
    
    virtual conv_if vif;
    int error_count = 0;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    task run_phase(uvm_phase phase);
        forever begin
            seq_item_port.get_next_item(req);
            drive_transaction(req);
            seq_item_port.item_done();
        end
    endtask
    
    task drive_transaction(conv_sequence_item trans);
        // 配置卷积参数
        vif.kernel_size <= trans.kernel_size;
        vif.stride <= trans.stride;
        vif.padding <= trans.padding;
        @(posedge vif.clk);
        
        // 根据错误类型注入总线错误
        if (trans.enable_error_injection && trans.error_type == conv_sequence_item::BUS_ERROR) begin
            inject_bus_error();
        end
        
        // 加载权重（可能注入ECC错误）
        vif.weight_valid <= 1'b1;
        foreach(trans.weight_data[i]) begin
            vif.weight_data <= trans.weight_data[i];
            
            // 注入内存ECC错误
            if (trans.enable_error_injection && 
                trans.error_type == conv_sequence_item::MEMORY_ECC_ERROR &&
                i == trans.error_location) begin
                vif.mem_ecc_error <= 1'b1;
                `uvm_info("DRIVER", $sformatf("Injecting ECC error at weight[%0d]", i), UVM_LOW)
            end else begin
                vif.mem_ecc_error <= 1'b0;
            end
            
            @(posedge vif.clk);
        end
        vif.weight_valid <= 1'b0;
        vif.mem_ecc_error <= 1'b0;
        
        // 输入数据（可能注入溢出）
        vif.data_valid <= 1'b1;
        foreach(trans.input_data[i]) begin
            vif.input_data <= trans.input_data[i];
            
            // 注入溢出错误
            if (trans.enable_error_injection && 
                trans.error_type == conv_sequence_item::OVERFLOW_ERROR &&
                i % 100 == 0) begin
                vif.force_overflow <= 1'b1;
                `uvm_info("DRIVER", "Forcing accumulator overflow", UVM_LOW)
            end else begin
                vif.force_overflow <= 1'b0;
            end
            
            @(posedge vif.clk);
        end
        vif.data_valid <= 1'b0;
        vif.force_overflow <= 1'b0;
        
        // 记录错误注入统计
        if (trans.enable_error_injection) begin
            error_count++;
            `uvm_info("DRIVER", $sformatf("Total errors injected: %0d", error_count), UVM_MEDIUM)
        end
    endtask
    
    // 注入总线错误
    task inject_bus_error();
        @(posedge vif.clk);
        vif.bus_error_inject <= 1'b1;
        vif.bus_resp <= 2'b10; // SLVERR
        @(posedge vif.clk);
        vif.bus_error_inject <= 1'b0;
        vif.bus_resp <= 2'b00; // OKAY
        `uvm_warning("DRIVER", "Bus error injected")
    endtask
endclass

// Monitor和Scoreboard
class conv_monitor extends uvm_monitor;
    `uvm_component_utils(conv_monitor)
    
    virtual conv_if vif;
    uvm_analysis_port #(conv_result_item) ap;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
        ap = new("ap", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        conv_result_item res;
        forever begin
            wait(vif.output_valid);
            res = conv_result_item::type_id::create("res");
            
            // 收集输出数据
            while(vif.output_valid) begin
                res.output_data.push_back(vif.output_data);
                @(posedge vif.clk);
            end
            
            ap.write(res);
        end
    endtask
endclass

// 高级Scoreboard（支持乱序、预测和详细分析）
class conv_scoreboard extends uvm_scoreboard;
    `uvm_component_utils(conv_scoreboard)
    
    // 分析端口
    uvm_analysis_export #(conv_sequence_item) input_export;
    uvm_analysis_export #(conv_result_item) output_export;
    uvm_tlm_analysis_fifo #(conv_sequence_item) input_fifo;
    uvm_tlm_analysis_fifo #(conv_result_item) output_fifo;
    
    // Python Golden Model接口
    protected int python_model;
    
    // 预测队列（支持乱序）
    typedef struct {
        int transaction_id;
        bit [7:0] expected_data[];
        conv_sequence_item input_item;
        time start_time;
    } prediction_t;
    
    prediction_t prediction_queue[$];
    
    // 统计信息
    int total_transactions = 0;
    int matched_transactions = 0;
    int mismatched_transactions = 0;
    int error_injected_transactions = 0;
    int correct_error_detection = 0;
    real total_latency = 0;
    
    // 详细错误报告
    int mismatch_histogram[bit[7:0]];
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        input_export = new("input_export", this);
        output_export = new("output_export", this);
        input_fifo = new("input_fifo", this);
        output_fifo = new("output_fifo", this);
        
        // 初始化Python Golden Model
        python_model = init_python_model("conv_golden_model.py");
    endfunction
    
    function void connect_phase(uvm_phase phase);
        input_export.connect(input_fifo.analysis_export);
        output_export.connect(output_fifo.analysis_export);
    endfunction
    
    task run_phase(uvm_phase phase);
        fork
            process_inputs();
            process_outputs();
            periodic_report();
        join
    endtask
    
    // 处理输入并生成预测
    task process_inputs();
        conv_sequence_item input_item;
        prediction_t pred;
        
        forever begin
            input_fifo.get(input_item);
            
            // 生成预测
            pred.transaction_id = input_item.get_transaction_id();
            pred.input_item = input_item;
            pred.start_time = $time;
            
            // 调用Golden Model（考虑错误注入）
            if (input_item.enable_error_injection) begin
                case (input_item.error_type)
                    conv_sequence_item::DATA_CORRUPTION,
                    conv_sequence_item::WEIGHT_CORRUPTION:
                        pred.expected_data = compute_corrupted_result(input_item);
                    conv_sequence_item::OVERFLOW_ERROR:
                        pred.expected_data = compute_overflow_result(input_item);
                    default:
                        pred.expected_data = compute_golden_result(input_item);
                endcase
                error_injected_transactions++;
            end else begin
                pred.expected_data = compute_golden_result(input_item);
            end
            
            // 加入预测队列
            prediction_queue.push_back(pred);
            
            `uvm_info("SCOREBOARD", 
                $sformatf("Added prediction for transaction %0d", pred.transaction_id), 
                UVM_HIGH)
        end
    endtask
    
    // 处理输出并比较
    task process_outputs();
        conv_result_item output_item;
        prediction_t pred;
        int match_found;
        
        forever begin
            output_fifo.get(output_item);
            total_transactions++;
            
            // 在预测队列中查找匹配的transaction
            match_found = 0;
            foreach (prediction_queue[i]) begin
                if (prediction_queue[i].transaction_id == output_item.transaction_id) begin
                    pred = prediction_queue[i];
                    prediction_queue.delete(i);
                    match_found = 1;
                    break;
                end
            end
            
            if (!match_found) begin
                `uvm_error("SCOREBOARD", 
                    $sformatf("No prediction found for transaction %0d", 
                    output_item.transaction_id))
                continue;
            end
            
            // 计算延迟
            real latency = ($time - pred.start_time) / 1ns;
            total_latency += latency;
            
            // 详细比较
            if (compare_results(output_item, pred)) begin
                matched_transactions++;
                `uvm_info("SCOREBOARD", 
                    $sformatf("Transaction %0d PASSED (latency: %.2f ns)", 
                    output_item.transaction_id, latency), 
                    UVM_MEDIUM)
                    
                // 检查错误检测是否正确
                if (pred.input_item.enable_error_injection && output_item.error_detected) begin
                    correct_error_detection++;
                    `uvm_info("SCOREBOARD", "Error correctly detected by DUT", UVM_LOW)
                end
            end else begin
                mismatched_transactions++;
                report_mismatch(output_item, pred);
            end
        end
    endtask
    
    // 详细比较函数
    function bit compare_results(conv_result_item got, prediction_t exp);
        bit match = 1;
        int tolerance = exp.input_item.enable_error_injection ? 5 : 1;
        
        // 长度检查
        if (got.output_data.size() != exp.expected_data.size()) begin
            `uvm_error("SCOREBOARD", 
                $sformatf("Size mismatch: got %0d, expected %0d", 
                got.output_data.size(), exp.expected_data.size()))
            return 0;
        end
        
        // 逐元素比较（考虑容差）
        foreach (got.output_data[i]) begin
            int diff = got.output_data[i] - exp.expected_data[i];
            if (diff < 0) diff = -diff;
            
            if (diff > tolerance) begin
                match = 0;
                mismatch_histogram[diff]++;
            end
        end
        
        return match;
    endfunction
    
    // 详细错误报告
    function void report_mismatch(conv_result_item got, prediction_t exp);
        string mismatch_details;
        int first_mismatch_idx = -1;
        int mismatch_count = 0;
        
        // 找出所有不匹配的位置
        foreach (got.output_data[i]) begin
            if (got.output_data[i] != exp.expected_data[i]) begin
                if (first_mismatch_idx == -1) first_mismatch_idx = i;
                mismatch_count++;
                
                if (mismatch_count <= 10) begin  // 只报告前10个
                    mismatch_details = {mismatch_details, 
                        $sformatf("\n  [%0d]: got=%0d, exp=%0d, diff=%0d", 
                        i, got.output_data[i], exp.expected_data[i], 
                        got.output_data[i] - exp.expected_data[i])};
                end
            end
        end
        
        `uvm_error("SCOREBOARD", 
            $sformatf("Transaction %0d FAILED: %0d mismatches out of %0d%s%s",
            got.transaction_id, mismatch_count, got.output_data.size(),
            mismatch_details,
            (mismatch_count > 10) ? "\n  ..." : ""))
            
        // 如果是错误注入的情况，提供额外信息
        if (exp.input_item.enable_error_injection) begin
            `uvm_info("SCOREBOARD", 
                $sformatf("Error injection type: %s", 
                exp.input_item.error_type.name()), UVM_LOW)
        end
    endfunction
    
    // 定期报告
    task periodic_report();
        forever begin
            #10ms;
            report_phase(null);
        end
    endtask
    
    function void report_phase(uvm_phase phase);
        real pass_rate = (total_transactions > 0) ? 
            (100.0 * matched_transactions / total_transactions) : 0;
        real avg_latency = (total_transactions > 0) ? 
            (total_latency / total_transactions) : 0;
        real error_detection_rate = (error_injected_transactions > 0) ?
            (100.0 * correct_error_detection / error_injected_transactions) : 0;
            
        `uvm_info("SCOREBOARD", "==== Scoreboard Report ====", UVM_LOW)
        `uvm_info("SCOREBOARD", $sformatf("Total transactions: %0d", total_transactions), UVM_LOW)
        `uvm_info("SCOREBOARD", $sformatf("Matched: %0d (%.2f%%)", matched_transactions, pass_rate), UVM_LOW)
        `uvm_info("SCOREBOARD", $sformatf("Mismatched: %0d", mismatched_transactions), UVM_LOW)
        `uvm_info("SCOREBOARD", $sformatf("Average latency: %.2f ns", avg_latency), UVM_LOW)
        `uvm_info("SCOREBOARD", $sformatf("Error injected: %0d", error_injected_transactions), UVM_LOW)
        `uvm_info("SCOREBOARD", $sformatf("Error detection rate: %.2f%%", error_detection_rate), UVM_LOW)
        
        // 错误分布直方图
        if (mismatch_histogram.size() > 0) begin
            `uvm_info("SCOREBOARD", "Mismatch histogram:", UVM_LOW)
            foreach (mismatch_histogram[diff]) begin
                `uvm_info("SCOREBOARD", 
                    $sformatf("  Difference %0d: %0d occurrences", 
                    diff, mismatch_histogram[diff]), UVM_LOW)
            end
        end
    endfunction
    
endclass

// 高级测试序列（约束随机和错误注入）
class conv_random_sequence extends uvm_sequence #(conv_sequence_item);
    `uvm_object_utils(conv_random_sequence)
    
    // 配置参数
    rand int num_normal_trans;
    rand int num_error_trans;
    rand bit enable_back_to_back;
    rand bit enable_size_sweep;
    
    constraint sequence_config_c {
        num_normal_trans inside {[100:1000]};
        num_error_trans inside {[10:50]};
        enable_back_to_back dist {0 := 70, 1 := 30};
        enable_size_sweep dist {0 := 60, 1 := 40};
    }
    
    function new(string name = "conv_random_sequence");
        super.new(name);
    endfunction
    
    task body();
        conv_sequence_item trans;
        
        // 尺寸扫描测试
        if (enable_size_sweep) begin
            foreach (int size_list[i] = '{1, 3, 5, 7}) begin
                `uvm_info("SEQUENCE", $sformatf("Testing kernel size %0d", size_list[i]), UVM_LOW)
                repeat(10) begin
                    trans = conv_sequence_item::type_id::create("trans");
                    start_item(trans);
                    assert(trans.randomize() with {
                        kernel_size == size_list[i];
                        enable_error_injection == 0;
                    });
                    finish_item(trans);
                end
            end
        end
        
        // 正常事务
        repeat(num_normal_trans) begin
            trans = conv_sequence_item::type_id::create("trans");
            start_item(trans);
            assert(trans.randomize() with {
                enable_error_injection == 0;
            });
            finish_item(trans);
            
            // 背靠背测试
            if (!enable_back_to_back) begin
                #($urandom_range(10, 100) * 1ns);
            end
        end
        
        // 错误注入事务
        repeat(num_error_trans) begin
            trans = conv_sequence_item::type_id::create("trans");
            start_item(trans);
            assert(trans.randomize() with {
                enable_error_injection == 1;
                // 确保错误类型均匀分布
                error_type dist {
                    conv_sequence_item::DATA_CORRUPTION := 25,
                    conv_sequence_item::WEIGHT_CORRUPTION := 25,
                    conv_sequence_item::OVERFLOW_ERROR := 25,
                    conv_sequence_item::BUS_ERROR := 15,
                    conv_sequence_item::MEMORY_ECC_ERROR := 10
                };
            });
            finish_item(trans);
            
            // 给DUT时间恢复
            #($urandom_range(100, 500) * 1ns);
        end
        
        // 压力测试：最大尺寸配置
        `uvm_info("SEQUENCE", "Starting stress test with maximum configurations", UVM_LOW)
        repeat(20) begin
            trans = conv_sequence_item::type_id::create("trans");
            start_item(trans);
            assert(trans.randomize() with {
                kernel_size == 7;
                stride == 1;
                padding == 3;
                enable_error_injection == 0;
            });
            finish_item(trans);
        end
    endtask
endclass

// 专门的错误恢复测试序列
class error_recovery_sequence extends uvm_sequence #(conv_sequence_item);
    `uvm_object_utils(error_recovery_sequence)
    
    function new(string name = "error_recovery_sequence");
        super.new(name);
    endfunction
    
    task body();
        conv_sequence_item trans;
        
        // 测试每种错误类型的恢复
        foreach (conv_sequence_item::error_type_e error_type = 
                {conv_sequence_item::BUS_ERROR,
                 conv_sequence_item::MEMORY_ECC_ERROR,
                 conv_sequence_item::OVERFLOW_ERROR}) begin
            
            `uvm_info("SEQUENCE", $sformatf("Testing recovery from %s", error_type.name()), UVM_LOW)
            
            // 注入错误
            trans = conv_sequence_item::type_id::create("trans");
            start_item(trans);
            assert(trans.randomize() with {
                enable_error_injection == 1;
                error_type == error_type;
            });
            finish_item(trans);
            
            // 等待错误处理
            #1us;
            
            // 发送正常事务验证恢复
            repeat(5) begin
                trans = conv_sequence_item::type_id::create("trans");
                start_item(trans);
                assert(trans.randomize() with {
                    enable_error_injection == 0;
                    kernel_size == 3;  // 使用标准配置
                });
                finish_item(trans);
                #100ns;
            end
        end
    endtask
endclass
            </div>

            <h4>7.1.2 形式化验证</h4>
            <p>形式化验证通过数学方法证明设计的正确性，特别适合控制密集型逻辑。</p>
            
            <div class="code-block">
// NPU指令调度单元的形式化验证属性
module instruction_scheduler_properties (
    input clk,
    input rst_n,
    input [3:0] inst_valid,
    input [3:0] inst_ready,
    output [3:0] inst_grant
);

    // 假设和约束
    assume property (@(posedge clk) disable iff (!rst_n)
        $countones(inst_grant) <= 1  // 最多授权一个指令
    );
    
    // 属性1：没有饥饿（no starvation）
    property no_starvation(int idx);
        @(posedge clk) disable iff (!rst_n)
        inst_valid[idx] && !inst_grant[idx] |-> 
            ##[1:16] inst_grant[idx];  // 16周期内必须得到授权
    endproperty
    
    generate
        for (genvar i = 0; i < 4; i++) begin : starvation_check
            assert property (no_starvation(i))
            else $error("Instruction %0d starved", i);
        end
    endgenerate
    
    // 属性2：互斥（mutual exclusion）
    property mutual_exclusion;
        @(posedge clk) disable iff (!rst_n)
        $onehot0(inst_grant);  // 最多一位为1
    endproperty
    
    assert property (mutual_exclusion)
    else $error("Multiple grants detected");
    
    // 属性3：有效授权（valid grant）
    property valid_grant;
        @(posedge clk) disable iff (!rst_n)
        |inst_grant |-> inst_grant & inst_valid;
    endproperty
    
    assert property (valid_grant)
    else $error("Grant to invalid instruction");
    
    // 覆盖属性
    covergroup scheduler_coverage @(posedge clk);
        valid_cp: coverpoint inst_valid {
            bins no_req = {4'b0000};
            bins single_req[] = {4'b0001, 4'b0010, 4'b0100, 4'b1000};
            bins multi_req = {[4'b0011:4'b1111]};
        }
        
        grant_cp: coverpoint inst_grant {
            bins no_grant = {4'b0000};
            bins grants[] = {4'b0001, 4'b0010, 4'b0100, 4'b1000};
        }
        
        valid_grant_cross: cross valid_cp, grant_cp {
            illegal_bins invalid = binsof(valid_cp.no_req) && 
                                  !binsof(grant_cp.no_grant);
        }
    endgroup
    
    scheduler_coverage cov_inst = new();

endmodule
            </div>

            <h4>7.1.3 硬件仿真加速</h4>
            <p>使用FPGA进行硬件仿真，实现MHz级别的验证速度。</p>
            
            <div class="code-block">
// Emulation环境配置示例
class npu_emulation_env extends uvm_env;
    `uvm_component_utils(npu_emulation_env)
    
    // 仿真加速器接口
    virtual emulator_if emu_if;
    
    // 软件栈组件
    npu_driver_agent driver_agent;
    npu_runtime_agent runtime_agent;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 配置仿真环境
        if (!uvm_config_db#(virtual emulator_if)::get(
            this, "", "emu_if", emu_if))
            `uvm_fatal("CONFIG", "Cannot get emulator interface")
        
        // 创建软件栈代理
        driver_agent = npu_driver_agent::type_id::create("driver_agent", this);
        runtime_agent = npu_runtime_agent::type_id::create("runtime_agent", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        // 加载NPU固件
        load_firmware("npu_firmware.bin");
        
        // 运行MLPerf基准测试
        run_mlperf_benchmark("mobilenet_v2");
        run_mlperf_benchmark("resnet50");
        run_mlperf_benchmark("bert");
    endtask
    
    task load_firmware(string firmware_path);
        int firmware_data[];
        
        // 读取固件文件
        $readmemh(firmware_path, firmware_data);
        
        // 通过JTAG加载到NPU
        foreach(firmware_data[i]) begin
            emu_if.jtag_write(32'h1000_0000 + i*4, firmware_data[i]);
        end
    endtask
    
    task run_mlperf_benchmark(string model_name);
        real start_time, end_time;
        int inference_count;
        
        `uvm_info("EMULATION", $sformatf("Running %s benchmark", model_name), UVM_LOW)
        
        // 加载模型
        runtime_agent.load_model(model_name);
        
        // 预热
        repeat(10) runtime_agent.run_inference();
        
        // 性能测试
        start_time = $realtime;
        repeat(1000) begin
            runtime_agent.run_inference();
            inference_count++;
        end
        end_time = $realtime;
        
        // 报告性能
        `uvm_info("EMULATION", 
            $sformatf("%s: %0.2f inferences/sec", 
            model_name, inference_count/(end_time-start_time)), 
            UVM_LOW)
    endtask
endclass
            </div>

            <h3>7.2 功能验证层次</h3>
            
            <p>功能验证采用分层的方法，从单元级到系统级逐步构建验证环境。这种分层策略就像建造摩天大楼——从地基开始，逐层向上，每一层都要确保稳固后才能继续建设。在NPU验证中，这种分层方法不仅提高了验证效率，还使得问题定位更加精准。</p>
            
            <p>一个典型的例子来自NVIDIA的Tensor Core验证。他们首先在单元级验证了每个乘加器的正确性，然后在模块级验证了4x4的矩阵运算，接着在子系统级验证了多Tensor Core的协同工作，最后在系统级运行真实的深度学习模型。这种分层方法帮助他们在早期就发现并修复了一个关键的浮点興入错误，避免了后期的大规模返工。</p>
            
            <p>值得注意的是，不同层次的验证关注点不同。单元级更关注逻辑正确性和边界条件，模块级关注接口协议和数据流，系统级则关注性能和应用场景。这种分工明确的方式使得不同专长的验证工程师可以并行工作，大大缩短了验证周期。</p>
            
            <h4>7.2.1 IP级验证</h4>
            <p>IP级验证是最基础的验证层次，关注单个功能模块的正确性。在NPU中，典型的IP包括MAC单元、激活函数单元、数据缓存等。这些看似简单的模块，实际上却隐藏着许多复杂的边界条件和特殊情况。</p>
            <div class="code-block">
// 优化的MAC单元定向测试 - Verilog版本
module mac_unit_test;
    
    parameter DATA_WIDTH = 8;
    parameter ACC_WIDTH = 32;
    parameter PIPE_STAGES = 3;
    
    reg clk, rst_n;
    reg signed [DATA_WIDTH-1:0] a, b;
    reg signed [ACC_WIDTH-1:0] c_in;
    reg valid_in;
    wire signed [ACC_WIDTH-1:0] c_out;
    wire valid_out;
    
    // 测试结果跟踪
    reg [31:0] test_count;
    reg [31:0] pass_count;
    reg [31:0] fail_count;
    
    // 流水线延迟跟踪
    reg signed [DATA_WIDTH-1:0] a_pipe [PIPE_STAGES-1:0];
    reg signed [DATA_WIDTH-1:0] b_pipe [PIPE_STAGES-1:0];
    reg signed [ACC_WIDTH-1:0] c_pipe [PIPE_STAGES-1:0];
    reg valid_pipe [PIPE_STAGES-1:0];
    
    // DUT实例化 - 使用流水线化的MAC
    mac_unit_pipelined #(
        .DATA_WIDTH(DATA_WIDTH),
        .ACC_WIDTH(ACC_WIDTH),
        .PIPE_STAGES(PIPE_STAGES)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .a(a),
        .b(b),
        .c_in(c_in),
        .valid_in(valid_in),
        .c_out(c_out),
        .valid_out(valid_out)
    );
    
    // 时钟生成
    initial clk = 0;
    always #5 clk = ~clk;
    
    // 流水线延迟跟踪
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < PIPE_STAGES; i++) begin
                a_pipe[i] <= 0;
                b_pipe[i] <= 0;
                c_pipe[i] <= 0;
                valid_pipe[i] <= 0;
            end
        end else begin
            a_pipe[0] <= a;
            b_pipe[0] <= b;
            c_pipe[0] <= c_in;
            valid_pipe[0] <= valid_in;
            
            for (int i = 1; i < PIPE_STAGES; i++) begin
                a_pipe[i] <= a_pipe[i-1];
                b_pipe[i] <= b_pipe[i-1];
                c_pipe[i] <= c_pipe[i-1];
                valid_pipe[i] <= valid_pipe[i-1];
            end
        end
    end
    
    // 测试激励
    initial begin
        // 初始化
        rst_n = 0;
        a = 0; b = 0; c_in = 0; valid_in = 0;
        test_count = 0; pass_count = 0; fail_count = 0;
        #20 rst_n = 1;
        
        // 测试1：基本MAC操作
        run_test("Basic MAC", 8'd10, 8'd20, 32'd100, 32'd300);
        
        // 测试2：负数处理
        run_test("Negative MAC", -8'd50, 8'd4, 32'd0, -32'd200);
        
        // 测试3：溢出处理
        run_overflow_test();
        
        // 测试4：连续累加测试
        run_accumulation_test();
        
        // 测试5：随机测试
        run_random_test(1000);
        
        // 测试6：边界值测试
        run_boundary_test();
        
        // 打印测试结果
        $display("\n\n=== TEST SUMMARY ===");
        $display("Total tests: %d", test_count);
        $display("Passed: %d", pass_count);
        $display("Failed: %d", fail_count);
        $display("Pass rate: %.2f%%", pass_count * 100.0 / test_count);
        
        $finish;
    end
    
    // 基本测试任务
    task run_test(input string test_name,
                  input signed [DATA_WIDTH-1:0] test_a,
                  input signed [DATA_WIDTH-1:0] test_b,
                  input signed [ACC_WIDTH-1:0] test_c,
                  input signed [ACC_WIDTH-1:0] expected);
        
        @(posedge clk);
        a = test_a;
        b = test_b;
        c_in = test_c;
        valid_in = 1'b1;
        
        @(posedge clk);
        valid_in = 1'b0;
        
        // 等待流水线延迟
        wait(valid_out);
        @(posedge clk);
        
        test_count = test_count + 1;
        if (c_out == expected) begin
            $display("[PASS] %s: %d * %d + %d = %d", 
                    test_name, test_a, test_b, test_c, c_out);
            pass_count = pass_count + 1;
        end else begin
            $display("[FAIL] %s: Expected %d, got %d", 
                    test_name, expected, c_out);
            fail_count = fail_count + 1;
        end
    endtask
    
    // 溢出测试
    task run_overflow_test();
        reg signed [ACC_WIDTH+8:0] expected;
        
        // 正溢出测试
        @(posedge clk);
        a = 8'd127;
        b = 8'd127;
        c_in = {1'b0, {(ACC_WIDTH-1){1'b1}}} - 16000;
        valid_in = 1'b1;
        
        @(posedge clk);
        valid_in = 1'b0;
        
        wait(valid_out);
        @(posedge clk);
        
        expected = a * b + c_in;
        test_count = test_count + 1;
        
        if (expected > $signed({1'b0, {(ACC_WIDTH-1){1'b1}}}) && 
            c_out == {1'b0, {(ACC_WIDTH-1){1'b1}}}) begin
            $display("[PASS] Positive overflow handling");
            pass_count = pass_count + 1;
        end else begin
            $display("[FAIL] Positive overflow handling");
            fail_count = fail_count + 1;
        end
        
        // 负溢出测试
        @(posedge clk);
        a = -8'd128;
        b = 8'd127;
        c_in = {1'b1, {(ACC_WIDTH-1){1'b0}}} + 16000;
        valid_in = 1'b1;
        
        @(posedge clk);
        valid_in = 1'b0;
        
        wait(valid_out);
        @(posedge clk);
        
        expected = a * b + c_in;
        test_count = test_count + 1;
        
        if (expected < $signed({1'b1, {(ACC_WIDTH-1){1'b0}}}) && 
            c_out == {1'b1, {(ACC_WIDTH-1){1'b0}}}) begin
            $display("[PASS] Negative overflow handling");
            pass_count = pass_count + 1;
        end else begin
            $display("[FAIL] Negative overflow handling");
            fail_count = fail_count + 1;
        end
    endtask
    
    // 累加测试
    task run_accumulation_test();
        reg signed [ACC_WIDTH-1:0] accumulated;
        
        accumulated = 0;
        
        // 连续10次累加
        for (int i = 0; i < 10; i++) begin
            @(posedge clk);
            a = i + 1;
            b = 2;
            c_in = (i == 0) ? 0 : c_out;
            valid_in = 1'b1;
            
            @(posedge clk);
            valid_in = 1'b0;
            
            accumulated = accumulated + (i + 1) * 2;
            
            wait(valid_out);
            @(posedge clk);
        end
        
        test_count = test_count + 1;
        if (c_out == accumulated) begin
            $display("[PASS] Accumulation test: Sum = %d", c_out);
            pass_count = pass_count + 1;
        end else begin
            $display("[FAIL] Accumulation test: Expected %d, got %d", 
                    accumulated, c_out);
            fail_count = fail_count + 1;
        end
    endtask
    
    // 随机测试
    task run_random_test(input int num_tests);
        reg signed [ACC_WIDTH-1:0] expected;
        int errors;
        
        errors = 0;
        
        for (int i = 0; i < num_tests; i++) begin
            @(posedge clk);
            a = $random;
            b = $random;
            c_in = $random;
            valid_in = 1'b1;
            
            expected = a * b + c_in;
            
            @(posedge clk);
            valid_in = 1'b0;
            
            wait(valid_out);
            @(posedge clk);
            
            if (c_out != expected) begin
                errors = errors + 1;
            end
        end
        
        test_count = test_count + 1;
        if (errors == 0) begin
            $display("[PASS] Random test: %d iterations", num_tests);
            pass_count = pass_count + 1;
        end else begin
            $display("[FAIL] Random test: %d errors in %d tests", 
                    errors, num_tests);
            fail_count = fail_count + 1;
        end
    endtask
    
    // 边界值测试
    task run_boundary_test();
        // 测试所有边界值组合
        reg signed [DATA_WIDTH-1:0] boundary_values [4];
        boundary_values[0] = {1'b0, {(DATA_WIDTH-1){1'b1}}}; // 最大正数
        boundary_values[1] = {1'b1, {(DATA_WIDTH-1){1'b0}}}; // 最小负数
        boundary_values[2] = 0;
        boundary_values[3] = -1;
        
        for (int i = 0; i < 4; i++) begin
            for (int j = 0; j < 4; j++) begin
                @(posedge clk);
                a = boundary_values[i];
                b = boundary_values[j];
                c_in = 0;
                valid_in = 1'b1;
                
                @(posedge clk);
                valid_in = 1'b0;
                
                wait(valid_out);
                @(posedge clk);
            end
        end
        
        test_count = test_count + 1;
        $display("[INFO] Boundary test completed");
        pass_count = pass_count + 1;
    endtask
    
endmodule

// 流水线化的MAC单元（用于测试）
module mac_unit_pipelined #(
    parameter DATA_WIDTH = 8,
    parameter ACC_WIDTH = 32,
    parameter PIPE_STAGES = 3
)(
    input wire clk,
    input wire rst_n,
    input wire signed [DATA_WIDTH-1:0] a,
    input wire signed [DATA_WIDTH-1:0] b,
    input wire signed [ACC_WIDTH-1:0] c_in,
    input wire valid_in,
    output reg signed [ACC_WIDTH-1:0] c_out,
    output reg valid_out
);
    
    // 流水线寄存器
    reg signed [DATA_WIDTH-1:0] a_reg1, a_reg2;
    reg signed [DATA_WIDTH-1:0] b_reg1, b_reg2;
    reg signed [ACC_WIDTH-1:0] c_reg1, c_reg2;
    reg signed [DATA_WIDTH*2-1:0] mult_reg;
    reg valid_reg1, valid_reg2, valid_reg3;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            a_reg1 <= 0; a_reg2 <= 0;
            b_reg1 <= 0; b_reg2 <= 0;
            c_reg1 <= 0; c_reg2 <= 0;
            mult_reg <= 0;
            c_out <= 0;
            valid_reg1 <= 0; valid_reg2 <= 0; valid_reg3 <= 0;
            valid_out <= 0;
        end else begin
            // Stage 1: 输入寄存
            a_reg1 <= a;
            b_reg1 <= b;
            c_reg1 <= c_in;
            valid_reg1 <= valid_in;
            
            // Stage 2: 乘法
            a_reg2 <= a_reg1;
            b_reg2 <= b_reg1;
            mult_reg <= a_reg1 * b_reg1;
            c_reg2 <= c_reg1;
            valid_reg2 <= valid_reg1;
            
            // Stage 3: 加法和饱和处理
            if (valid_reg2) begin
                reg signed [ACC_WIDTH+1:0] sum;
                sum = mult_reg + c_reg2;
                
                // 饱和处理
                if (sum > $signed({1'b0, {(ACC_WIDTH-1){1'b1}}})) begin
                    c_out <= {1'b0, {(ACC_WIDTH-1){1'b1}}};
                end else if (sum < $signed({1'b1, {(ACC_WIDTH-1){1'b0}}})) begin
                    c_out <= {1'b1, {(ACC_WIDTH-1){1'b0}}};
                end else begin
                    c_out <= sum[ACC_WIDTH-1:0];
                end
            end
            valid_reg3 <= valid_reg2;
            valid_out <= valid_reg3;
        end
    end
    
endmodule
            </div>
            
            <p>Chisel版本的MAC单元测试：</p>
            <div class="code-block">
import chisel3._
import chisel3.util._
import chiseltest._

class MACUnitTest extends FlatSpec with ChiselScalatestTester {
  behavior of "MACUnit"
  
  it should "perform basic MAC operations" in {
    test(new MACUnitPipelined(8, 32, 3)) { dut =>
      // 初始化
      dut.io.a.poke(0.S)
      dut.io.b.poke(0.S)
      dut.io.c_in.poke(0.S)
      dut.io.valid_in.poke(false.B)
      dut.clock.step(5)
      
      // 基本MAC测试
      dut.io.a.poke(10.S)
      dut.io.b.poke(20.S)
      dut.io.c_in.poke(100.S)
      dut.io.valid_in.poke(true.B)
      dut.clock.step(1)
      dut.io.valid_in.poke(false.B)
      
      // 等待输出
      while (!dut.io.valid_out.peek().litToBoolean) {
        dut.clock.step(1)
      }
      
      dut.io.c_out.expect(300.S)
      
      // 负数测试
      dut.io.a.poke((-50).S)
      dut.io.b.poke(4.S)
      dut.io.c_in.poke(0.S)
      dut.io.valid_in.poke(true.B)
      dut.clock.step(1)
      dut.io.valid_in.poke(false.B)
      
      while (!dut.io.valid_out.peek().litToBoolean) {
        dut.clock.step(1)
      }
      
      dut.io.c_out.expect((-200).S)
    }
  }
  
  it should "handle overflow correctly" in {
    test(new MACUnitPipelined(8, 32, 3)) { dut =>
      // 正溢出测试
      dut.io.a.poke(127.S)
      dut.io.b.poke(127.S)
      dut.io.c_in.poke((Int.MaxValue - 16000).S)
      dut.io.valid_in.poke(true.B)
      dut.clock.step(1)
      dut.io.valid_in.poke(false.B)
      
      while (!dut.io.valid_out.peek().litToBoolean) {
        dut.clock.step(1)
      }
      
      dut.io.c_out.expect(Int.MaxValue.S)
    }
  }
}
            </div>

            <h4>7.2.2 子系统级验证</h4>
            <div class="code-block">
// PE阵列的随机测试
class pe_array_test extends uvm_test;
    `uvm_component_utils(pe_array_test)
    
    pe_array_env env;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        env = pe_array_env::type_id::create("env", this);
        
        // 配置测试参数
        uvm_config_db#(int)::set(this, "env.agent", "array_size", 16);
        uvm_config_db#(int)::set(this, "env.agent", "data_width", 8);
    endfunction
    
    task run_phase(uvm_phase phase);
        pe_array_sequence seq;
        
        phase.raise_objection(this);
        
        // 运行不同的测试序列
        
        // 1. 单位矩阵测试
        seq = identity_matrix_seq::type_id::create("seq");
        seq.start(env.agent.sequencer);
        
        // 2. 稀疏矩阵测试
        seq = sparse_matrix_seq::type_id::create("seq");
        seq.sparsity = 0.9;  // 90%稀疏
        seq.start(env.agent.sequencer);
        
        // 3. 随机矩阵测试
        seq = random_matrix_seq::type_id::create("seq");
        seq.num_iterations = 1000;
        seq.start(env.agent.sequencer);
        
        // 4. 边界条件测试
        seq = boundary_test_seq::type_id::create("seq");
        seq.start(env.agent.sequencer);
        
        phase.drop_objection(this);
    endtask
    
endclass

// 覆盖率收集
class pe_array_coverage extends uvm_subscriber #(pe_array_transaction);
    `uvm_component_utils(pe_array_coverage)
    
    covergroup pe_cg;
        // 数据模式覆盖
        data_pattern_cp: coverpoint trans.get_data_pattern() {
            bins zeros = {PATTERN_ZEROS};
            bins ones = {PATTERN_ONES};
            bins sparse = {PATTERN_SPARSE};
            bins dense = {PATTERN_DENSE};
            bins random = {PATTERN_RANDOM};
        }
        
        // 计算模式覆盖
        compute_mode_cp: coverpoint trans.compute_mode {
            bins matmul = {MODE_MATMUL};
            bins conv = {MODE_CONV};
            bins pooling = {MODE_POOLING};
        }
        
        // 精度覆盖
        precision_cp: coverpoint trans.precision {
            bins int8 = {PREC_INT8};
            bins int16 = {PREC_INT16};
            bins fp16 = {PREC_FP16};
        }
        
        // 交叉覆盖
        mode_precision_cross: cross compute_mode_cp, precision_cp;
    endgroup
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
        pe_cg = new();
    endfunction
    
    function void write(pe_array_transaction t);
        trans = t;
        pe_cg.sample();
    endfunction
endclass
            </div>

            <h3>7.3 系统级验证</h3>
            
            <p>系统级验证验证完整的NPU功能，包括多模块协同工作、真实神经网络层的执行，以及与主机的交互。系统级验证是验证金字塔的塔尖，也是最接近真实使用场景的验证层次。在这个层次，我们不再关注单个模块的行为，而是关注整个系统作为一个整体如何响应各种复杂的工作负载。</p>
            
            <p>一个典型的系统级验证挑战是“长尾问题”。在实际应用中，80%的工作负载可能只使用了20%的功能，但剩下的20%的“长尾”场景却可能导致系统崩溃。例如，Google在TPU v2的系统级验证中发现，当某些特殊的网络结构（如动态RNN）在特定的batch size下运行时，会触发一个罕见的死锁条件。这种问题在模块级验证中几乎不可能发现。</p>
            
            <p>系统级验证还需要考虑“涌现属性”——那些只有在多个组件交互时才会出现的问题。一个经典的例子是带宽竞争：当多个计算单元同时访问存储时，实际性能可能远低于理论值。这种问题需要通过运行真实的工作负载并进行细致的性能分析才能发现。</p>
            
            <h4>7.3.1 端到端网络层验证</h4>
            
            <p>端到端验证是系统级验证的核心，它模拟真实的数据流通过NPU的全过程。这就像是在流水线上追踪一个产品从原料到成品的完整过程，任何环节的问题都可能影响最终质量。在NPU中，一个特征图从输入到输出可能要经过卷积、激活、池化等多个步骤，每个步骤都有其特定的时序要求和数据依赖。</p>
            <div class="code-block">
// Conv-ReLU-Pooling完整链条验证环境
class conv_relu_pooling_env extends uvm_env;
    `uvm_component_utils(conv_relu_pooling_env)
    
    // 各模块的代理
    conv_agent conv_agt;
    relu_agent relu_agt;
    pooling_agent pool_agt;
    memory_agent mem_agt;
    
    // 系统级监控器
    system_monitor sys_mon;
    system_scoreboard sys_scb;
    
    // 虚拟序列器
    virtual_sequencer v_sqr;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 创建代理
        conv_agt = conv_agent::type_id::create("conv_agt", this);
        relu_agt = relu_agent::type_id::create("relu_agt", this);
        pool_agt = pooling_agent::type_id::create("pool_agt", this);
        mem_agt = memory_agent::type_id::create("mem_agt", this);
        
        // 创建系统级组件
        sys_mon = system_monitor::type_id::create("sys_mon", this);
        sys_scb = system_scoreboard::type_id::create("sys_scb", this);
        v_sqr = virtual_sequencer::type_id::create("v_sqr", this);
        
        // 配置内存映射
        uvm_config_db#(memory_map)::set(this, "*", "mem_map", create_memory_map());
    endfunction
    
    function void connect_phase(uvm_phase phase);
        // 连接虚拟序列器
        v_sqr.conv_sqr = conv_agt.sequencer;
        v_sqr.relu_sqr = relu_agt.sequencer;
        v_sqr.pool_sqr = pool_agt.sequencer;
        v_sqr.mem_sqr = mem_agt.sequencer;
        
        // 连接监控器到记分板
        conv_agt.monitor.ap.connect(sys_scb.conv_export);
        relu_agt.monitor.ap.connect(sys_scb.relu_export);
        pool_agt.monitor.ap.connect(sys_scb.pool_export);
        sys_mon.ap.connect(sys_scb.sys_export);
    endfunction
    
    function memory_map create_memory_map();
        memory_map mmap = new();
        mmap.add_region("input_buffer", 32'h0000_0000, 32'h000F_FFFF);
        mmap.add_region("weight_buffer", 32'h0010_0000, 32'h001F_FFFF);
        mmap.add_region("inter_buffer", 32'h0020_0000, 32'h002F_FFFF);
        mmap.add_region("output_buffer", 32'h0030_0000, 32'h003F_FFFF);
        return mmap;
    endfunction
endclass

// 端到端测试序列
class end_to_end_sequence extends uvm_sequence;
    `uvm_object_utils(end_to_end_sequence)
    `uvm_declare_p_sequencer(virtual_sequencer)
    
    // 测试参数
    rand int input_height, input_width, input_channels;
    rand int conv_filters, kernel_size, stride;
    rand int pool_size, pool_stride;
    
    constraint valid_dims_c {
        input_height inside {[16:256]};
        input_width inside {[16:256]};
        input_channels inside {[3:64]};
        conv_filters inside {[16:128]};
        kernel_size inside {3, 5};
        stride inside {1, 2};
        pool_size inside {2, 3};
        pool_stride inside {1, 2};
        
        // 确保维度兼容
        (input_height - kernel_size) % stride == 0;
        (input_width - kernel_size) % stride == 0;
    }
    
    function new(string name = "end_to_end_sequence");
        super.new(name);
    endfunction
    
    task body();
        // 子序列
        load_input_sequence load_seq;
        load_weight_sequence weight_seq;
        conv_compute_sequence conv_seq;
        relu_sequence relu_seq;
        pooling_sequence pool_seq;
        verify_output_sequence verify_seq;
        
        `uvm_info("E2E_SEQ", 
            $sformatf("Starting Conv(%0dx%0d)→ReLU→Pool(%0dx%0d) test", 
            kernel_size, kernel_size, pool_size, pool_size), UVM_LOW)
        
        // 1. 加载输入数据到内存
        load_seq = load_input_sequence::type_id::create("load_seq");
        load_seq.height = input_height;
        load_seq.width = input_width;
        load_seq.channels = input_channels;
        load_seq.start(p_sequencer.mem_sqr);
        
        // 2. 加载卷积权重
        weight_seq = load_weight_sequence::type_id::create("weight_seq");
        weight_seq.filters = conv_filters;
        weight_seq.kernel_size = kernel_size;
        weight_seq.input_channels = input_channels;
        weight_seq.randomize_weights();
        weight_seq.start(p_sequencer.mem_sqr);
        
        // 3. 配置并执行卷积
        conv_seq = conv_compute_sequence::type_id::create("conv_seq");
        conv_seq.configure(
            .input_addr(32'h0000_0000),
            .weight_addr(32'h0010_0000),
            .output_addr(32'h0020_0000),
            .input_dims('{input_height, input_width, input_channels}),
            .kernel_size(kernel_size),
            .stride(stride),
            .filters(conv_filters)
        );
        conv_seq.start(p_sequencer.conv_sqr);
        
        // 等待卷积完成
        wait_for_completion("CONV");
        
        // 4. 执行ReLU激活
        relu_seq = relu_sequence::type_id::create("relu_seq");
        relu_seq.configure(
            .input_addr(32'h0020_0000),
            .output_addr(32'h0020_0000),  // 原地操作
            .size(calculate_conv_output_size())
        );
        relu_seq.start(p_sequencer.relu_sqr);
        
        wait_for_completion("RELU");
        
        // 5. 执行池化
        pool_seq = pooling_sequence::type_id::create("pool_seq");
        pool_seq.configure(
            .input_addr(32'h0020_0000),
            .output_addr(32'h0030_0000),
            .input_dims(calculate_conv_output_dims()),
            .pool_size(pool_size),
            .pool_stride(pool_stride),
            .pool_type(MAX_POOLING)
        );
        pool_seq.start(p_sequencer.pool_sqr);
        
        wait_for_completion("POOL");
        
        // 6. 验证最终输出
        verify_seq = verify_output_sequence::type_id::create("verify_seq");
        verify_seq.golden_model = create_golden_model();
        verify_seq.output_addr = 32'h0030_0000;
        verify_seq.output_size = calculate_final_output_size();
        verify_seq.start(p_sequencer.mem_sqr);
        
        `uvm_info("E2E_SEQ", "End-to-end test completed", UVM_LOW)
    endtask
    
    // 辅助函数
    function int calculate_conv_output_size();
        int h_out = (input_height - kernel_size) / stride + 1;
        int w_out = (input_width - kernel_size) / stride + 1;
        return h_out * w_out * conv_filters;
    endfunction
    
    function int_array_t calculate_conv_output_dims();
        int h_out = (input_height - kernel_size) / stride + 1;
        int w_out = (input_width - kernel_size) / stride + 1;
        return '{h_out, w_out, conv_filters};
    endfunction
    
    function golden_model create_golden_model();
        golden_model gm = new();
        gm.add_layer(new conv_layer(kernel_size, stride, conv_filters));
        gm.add_layer(new relu_layer());
        gm.add_layer(new pooling_layer(pool_size, pool_stride));
        return gm;
    endfunction
    
    task wait_for_completion(string module_name);
        // 等待特定模块完成处理
        @(posedge p_sequencer.completion_event[module_name]);
        `uvm_info("E2E_SEQ", $sformatf("%s processing completed", module_name), UVM_MEDIUM)
    endtask
endclass

// 系统级记分板
class system_scoreboard extends uvm_scoreboard;
    `uvm_component_utils(system_scoreboard)
    
    // 分析端口
    uvm_analysis_export #(conv_transaction) conv_export;
    uvm_analysis_export #(relu_transaction) relu_export;
    uvm_analysis_export #(pooling_transaction) pool_export;
    uvm_analysis_export #(system_transaction) sys_export;
    
    // 内部FIFO
    uvm_tlm_analysis_fifo #(conv_transaction) conv_fifo;
    uvm_tlm_analysis_fifo #(relu_transaction) relu_fifo;
    uvm_tlm_analysis_fifo #(pooling_transaction) pool_fifo;
    uvm_tlm_analysis_fifo #(system_transaction) sys_fifo;
    
    // 参考模型
    npu_reference_model ref_model;
    
    // 流水线跟踪
    pipeline_tracker tracker;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        conv_export = new("conv_export", this);
        relu_export = new("relu_export", this);
        pool_export = new("pool_export", this);
        sys_export = new("sys_export", this);
        
        conv_fifo = new("conv_fifo", this);
        relu_fifo = new("relu_fifo", this);
        pool_fifo = new("pool_fifo", this);
        sys_fifo = new("sys_fifo", this);
        
        ref_model = npu_reference_model::type_id::create("ref_model", this);
        tracker = new("pipeline_tracker");
    endfunction
    
    function void connect_phase(uvm_phase phase);
        conv_export.connect(conv_fifo.analysis_export);
        relu_export.connect(relu_fifo.analysis_export);
        pool_export.connect(pool_fifo.analysis_export);
        sys_export.connect(sys_fifo.analysis_export);
    endfunction
    
    task run_phase(uvm_phase phase);
        fork
            process_pipeline();
            check_data_consistency();
            monitor_performance();
        join
    endtask
    
    task process_pipeline();
        forever begin
            system_transaction sys_trans;
            sys_fifo.get(sys_trans);
            
            // 跟踪事务流经流水线
            tracker.add_transaction(sys_trans);
            
            // 在每个阶段验证
            case (sys_trans.stage)
                STAGE_CONV: verify_conv_stage(sys_trans);
                STAGE_RELU: verify_relu_stage(sys_trans);
                STAGE_POOL: verify_pool_stage(sys_trans);
                STAGE_COMPLETE: verify_complete(sys_trans);
            endcase
        end
    endtask
    
    task verify_complete(system_transaction trans);
        real_array_t expected, actual;
        real error_rate;
        
        // 获取参考模型结果
        expected = ref_model.compute(trans.input_data);
        actual = trans.output_data;
        
        // 计算误差
        error_rate = calculate_error_rate(expected, actual);
        
        if (error_rate > 0.01) begin  // 1%容差
            `uvm_error("SCOREBOARD", 
                $sformatf("Output mismatch! Error rate: %.2f%%", error_rate * 100))
            dump_comparison(expected, actual);
        end else begin
            `uvm_info("SCOREBOARD", 
                $sformatf("Pipeline verification PASSED. Error: %.4f%%", 
                error_rate * 100), UVM_MEDIUM)
        end
        
        // 更新统计
        tracker.update_statistics(trans, error_rate);
    endtask
    
    function real calculate_error_rate(real_array_t expected, real_array_t actual);
        real total_error = 0;
        int num_elements = expected.size();
        
        foreach (expected[i]) begin
            real diff = expected[i] - actual[i];
            total_error += (diff * diff);
        end
        
        return $sqrt(total_error / num_elements) / get_data_range();
    endfunction
endclass
            </div>
            
            <h4>7.3.2 多核NPU同步验证</h4>
            
            <div class="code-block">
// 多核NPU验证环境
class multi_core_npu_env extends uvm_env;
    `uvm_component_utils(multi_core_npu_env)
    
    parameter NUM_CORES = 4;
    parameter NUM_CLUSTERS = 2;
    
    // 每个核心的代理
    npu_core_agent core_agents[NUM_CLUSTERS][NUM_CORES];
    
    // 共享资源代理
    memory_controller_agent mem_ctrl_agent;
    interconnect_agent noc_agent;
    
    // 同步监控器
    synchronization_monitor sync_mon;
    coherence_checker coherence_chk;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 创建核心代理
        foreach (core_agents[i,j]) begin
            core_agents[i][j] = npu_core_agent::type_id::create(
                $sformatf("core_agent[%0d][%0d]", i, j), this);
        end
        
        // 创建共享组件
        mem_ctrl_agent = memory_controller_agent::type_id::create("mem_ctrl_agent", this);
        noc_agent = interconnect_agent::type_id::create("noc_agent", this);
        
        sync_mon = synchronization_monitor::type_id::create("sync_mon", this);
        coherence_chk = coherence_checker::type_id::create("coherence_chk", this);
    endfunction
endclass

// 多核同步测试
class multi_core_sync_test extends uvm_test;
    `uvm_component_utils(multi_core_sync_test)
    
    multi_core_npu_env env;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    task run_phase(uvm_phase phase);
        parallel_conv_sequence para_seq;
        barrier_sync_sequence barrier_seq;
        data_sharing_sequence share_seq;
        
        phase.raise_objection(this);
        
        // 测试1: 并行卷积with同步
        `uvm_info("TEST", "Starting parallel convolution test", UVM_LOW)
        para_seq = parallel_conv_sequence::type_id::create("para_seq");
        para_seq.configure_workload_distribution();
        para_seq.start(env.v_sqr);
        
        // 测试2: Barrier同步
        `uvm_info("TEST", "Testing barrier synchronization", UVM_LOW)
        barrier_seq = barrier_sync_sequence::type_id::create("barrier_seq");
        barrier_seq.num_sync_points = 5;
        barrier_seq.start(env.v_sqr);
        
        // 测试3: 核间数据共享
        `uvm_info("TEST", "Testing inter-core data sharing", UVM_LOW)
        share_seq = data_sharing_sequence::type_id::create("share_seq");
        share_seq.sharing_pattern = NEIGHBOR_EXCHANGE;
        share_seq.start(env.v_sqr);
        
        phase.drop_objection(this);
    endtask
endclass

// 并行卷积序列
class parallel_conv_sequence extends uvm_sequence;
    `uvm_object_utils(parallel_conv_sequence)
    
    // 工作负载分配
    typedef struct {
        int core_id;
        int start_channel;
        int end_channel;
        bit is_master;
    } workload_t;
    
    workload_t workload_map[4];
    
    task body();
        // 主核心初始化
        init_master_core();
        
        // 分发工作负载
        fork
            foreach (workload_map[i]) begin
                automatic int idx = i;
                execute_core_workload(idx);
            end
        join
        
        // 收集并合并结果
        collect_results();
    endtask
    
    task execute_core_workload(int core_idx);
        core_conv_sequence core_seq;
        workload_t wl = workload_map[core_idx];
        
        core_seq = core_conv_sequence::type_id::create(
            $sformatf("core_seq_%0d", core_idx));
        
        core_seq.core_id = wl.core_id;
        core_seq.channel_start = wl.start_channel;
        core_seq.channel_end = wl.end_channel;
        core_seq.sync_mode = BARRIER_SYNC;
        
        // 在对应核心的序列器上启动
        core_seq.start(p_sequencer.core_sqr[core_idx]);
        
        `uvm_info("PARA_SEQ", 
            $sformatf("Core %0d completed channels [%0d:%0d]", 
            core_idx, wl.start_channel, wl.end_channel), UVM_MEDIUM)
    endtask
endclass
            </div>

            <h3>7.4 性能验证</h3>
            
            <p>NPU的性能验证不仅要确认峰值性能，还要验证在各种实际工作负载下的性能表现。性能验证就像是对运动员的全面体检——不仅要测试最大负荷下的表现，还要考察耐力、稳定性和恢复能力。在NPU领域，“纸面性能”与“实际性能”之间的差距往往令人惊讶。</p>
            
            <p>一个血的教训来自某著名芯片公司：他们的NPU在实验室测试中达到了惊人的100 TOPS，但在客户部署时，实际性能只有30-40 TOPS。原因是他们的性能测试使用的是特别优化过的基准程序，而真实的神经网络模型却有着更复杂的访存模式和数据依赖。这个案例提醒我们：性能验证必须基于真实场景。</p>
            
            <p>现代NPU性能验证的另一个挑战是“性能可预测性”。用户不仅关心平均性能，更关心性能的一致性。一个偶尔出现的性能抖动可能导致自动驾驶系统错过关键的决策时机。因此，除了测试平均性能和峰值性能，我们还需要关注长尾延迟（99%、999%分位数）和性能波动。</p>
            
            <h4>7.4.1 性能计数器设计</h4>
            <p>性能计数器是性能验证的基础设施，就像是芯片内部的“传感器网络”。一个设计良好的性能监控系统不仅要能捕捉关键指标，还要尽可能减少对正常功能的干扰。这就像医生的听诊器——既要能听到心跳，又不能影响患者的正常呼吸。</p>
            <div class="code-block">
// NPU性能监控模块
module npu_performance_monitor (
    input wire clk,
    input wire rst_n,
    
    // 监控信号
    input wire mac_valid,
    input wire [15:0] mac_count,
    input wire cache_hit,
    input wire cache_miss,
    input wire dma_busy,
    input wire compute_stall,
    
    // APB接口
    input wire psel,
    input wire penable,
    input wire pwrite,
    input wire [11:0] paddr,
    output reg [31:0] prdata
);

    // 性能计数器
    reg [63:0] cycle_count;
    reg [63:0] mac_op_count;
    reg [31:0] cache_hit_count;
    reg [31:0] cache_miss_count;
    reg [31:0] dma_busy_cycles;
    reg [31:0] compute_stall_cycles;
    
    // 性能指标计算
    wire [31:0] mac_utilization;
    wire [31:0] cache_hit_rate;
    wire [31:0] bandwidth_efficiency;
    
    // 计数器更新
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            cycle_count <= 64'h0;
            mac_op_count <= 64'h0;
            cache_hit_count <= 32'h0;
            cache_miss_count <= 32'h0;
            dma_busy_cycles <= 32'h0;
            compute_stall_cycles <= 32'h0;
        end else begin
            cycle_count <= cycle_count + 1;
            
            if (mac_valid)
                mac_op_count <= mac_op_count + mac_count;
            
            if (cache_hit)
                cache_hit_count <= cache_hit_count + 1;
                
            if (cache_miss)
                cache_miss_count <= cache_miss_count + 1;
                
            if (dma_busy)
                dma_busy_cycles <= dma_busy_cycles + 1;
                
            if (compute_stall)
                compute_stall_cycles <= compute_stall_cycles + 1;
        end
    end
    
    // 性能指标计算
    assign mac_utilization = (mac_op_count * 100) / (cycle_count * 256); // 假设256个MAC单元
    assign cache_hit_rate = (cache_hit_count * 100) / (cache_hit_count + cache_miss_count);
    assign bandwidth_efficiency = ((cycle_count - dma_busy_cycles) * 100) / cycle_count;
    
    // APB读操作
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            prdata <= 32'h0;
        end else if (psel && !pwrite && penable) begin
            case (paddr[11:0])
                12'h000: prdata <= cycle_count[31:0];
                12'h004: prdata <= cycle_count[63:32];
                12'h008: prdata <= mac_op_count[31:0];
                12'h00C: prdata <= mac_op_count[63:32];
                12'h010: prdata <= cache_hit_count;
                12'h014: prdata <= cache_miss_count;
                12'h018: prdata <= cache_hit_rate;
                12'h01C: prdata <= mac_utilization;
                12'h020: prdata <= bandwidth_efficiency;
                12'h024: prdata <= compute_stall_cycles;
                12'h028: prdata <= dma_busy_cycles;
                default: prdata <= 32'h0;
            endcase
        end
    end

endmodule
            </div>

            <h4>7.3.2 性能测试基准</h4>
            <div class="code-block">
// 性能基准测试类
class npu_performance_benchmark extends uvm_sequence;
    `uvm_object_utils(npu_performance_benchmark)
    
    // 测试配置
    int num_iterations = 100;
    string model_name = "resnet50";
    
    // 性能统计
    real total_inference_time;
    int total_mac_operations;
    real power_consumption;
    
    function new(string name = "npu_performance_benchmark");
        super.new(name);
    endfunction
    
    task body();
        npu_model_config cfg;
        npu_inference_seq inference_seq;
        real start_time, end_time;
        
        // 加载模型配置
        cfg = load_model_config(model_name);
        
        // 配置NPU
        configure_npu(cfg);
        
        // 预热
        repeat(10) begin
            inference_seq = npu_inference_seq::type_id::create("inference_seq");
            inference_seq.model_cfg = cfg;
            inference_seq.start(m_sequencer);
        end
        
        // 性能测试
        start_time = $realtime;
        repeat(num_iterations) begin
            inference_seq = npu_inference_seq::type_id::create("inference_seq");
            inference_seq.model_cfg = cfg;
            inference_seq.start(m_sequencer);
        end
        end_time = $realtime;
        
        // 收集性能数据
        collect_performance_data();
        
        // 报告结果
        report_performance();
    endtask
    
    function void collect_performance_data();
        // 从性能计数器读取数据
        total_inference_time = $realtime;
        total_mac_operations = read_performance_counter(PERF_MAC_OPS);
        power_consumption = read_power_monitor();
    endfunction
    
    function void report_performance();
        real throughput, efficiency, tops;
        
        throughput = num_iterations / total_inference_time;
        tops = total_mac_operations / total_inference_time / 1e12;
        efficiency = tops / power_consumption;  // TOPS/W
        
        `uvm_info("PERF", "=== Performance Report ===", UVM_LOW)
        `uvm_info("PERF", $sformatf("Model: %s", model_name), UVM_LOW)
        `uvm_info("PERF", $sformatf("Throughput: %.2f inferences/sec", throughput), UVM_LOW)
        `uvm_info("PERF", $sformatf("Performance: %.2f TOPS", tops), UVM_LOW)
        `uvm_info("PERF", $sformatf("Power: %.2f W", power_consumption), UVM_LOW)
        `uvm_info("PERF", $sformatf("Efficiency: %.2f TOPS/W", efficiency), UVM_LOW)
    endfunction
    
endclass
            </div>

            <div class="exercise">
                <h4>练习 7.1-7.3</h4>
                <div class="question">
                    <p><strong>题目：</strong>设计一个完整的UVM验证环境来验证一个4x4 MAC阵列，要求：
                    1) 实现完整的UVM组件（Driver、Monitor、Scoreboard）
                    2) 使用Python golden model进行结果比较
                    3) 实现功能覆盖率收集
                    4) 支持随机和定向测试</p>
                    <details class="hint">
                        <summary>💡 提示</summary>
                        <p>思考方向：UVM环境包括agent（driver+monitor）、scoreboard、env等层次。使用DPI-C接口调用Python模型。功能覆盖率应包括数据范围、操作模式、边界条件。随机约束应考虑实际使用场景。</p>
                    </details>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
// MAC阵列接口定义
interface mac_array_if(input clk);
    logic rst_n;
    logic enable;
    logic [7:0] a_in[3:0];
    logic [7:0] b_in[3:0][3:0];
    logic [31:0] c_out[3:0][3:0];
    logic valid_out;
    
    modport dut(
        input clk, rst_n, enable, a_in, b_in,
        output c_out, valid_out
    );
    
    modport tb(
        input clk, c_out, valid_out,
        output rst_n, enable, a_in, b_in
    );
endinterface

// Transaction定义
class mac_array_trans extends uvm_sequence_item;
    `uvm_object_utils(mac_array_trans)
    
    rand bit [7:0] a_matrix[3:0][3:0];
    rand bit [7:0] b_matrix[3:0][3:0];
    bit [31:0] c_matrix[3:0][3:0];
    
    constraint data_c {
        foreach(a_matrix[i,j]) {
            a_matrix[i][j] inside {[0:255]};
            b_matrix[i][j] inside {[0:255]};
        }
    }
    
    function new(string name = "mac_array_trans");
        super.new(name);
    endfunction
    
    function void do_copy(uvm_object rhs);
        mac_array_trans t;
        super.do_copy(rhs);
        $cast(t, rhs);
        a_matrix = t.a_matrix;
        b_matrix = t.b_matrix;
        c_matrix = t.c_matrix;
    endfunction
endclass

// Driver实现
class mac_array_driver extends uvm_driver#(mac_array_trans);
    `uvm_component_utils(mac_array_driver)
    
    virtual mac_array_if.tb vif;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual mac_array_if.tb)::get(
            this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    task run_phase(uvm_phase phase);
        forever begin
            seq_item_port.get_next_item(req);
            drive_trans(req);
            seq_item_port.item_done();
        end
    endtask
    
    task drive_trans(mac_array_trans t);
        // 复位
        vif.rst_n = 0;
        vif.enable = 0;
        repeat(5) @(posedge vif.clk);
        vif.rst_n = 1;
        
        // 发送数据（脉动输入）
        for (int cycle = 0; cycle < 7; cycle++) begin
            @(posedge vif.clk);
            vif.enable = 1;
            
            // 对角线输入模式
            for (int i = 0; i < 4; i++) begin
                if (cycle >= i && cycle - i < 4) begin
                    vif.a_in[i] = t.a_matrix[i][cycle-i];
                    for (int j = 0; j < 4; j++) begin
                        if (i == 0)
                            vif.b_in[j][i] = t.b_matrix[cycle-j][j];
                    end
                end else begin
                    vif.a_in[i] = 0;
                end
            end
        end
        
        vif.enable = 0;
        
        // 等待计算完成
        wait(vif.valid_out);
        repeat(2) @(posedge vif.clk);
    endtask
endclass

// Monitor实现
class mac_array_monitor extends uvm_monitor;
    `uvm_component_utils(mac_array_monitor)
    
    virtual mac_array_if.tb vif;
    uvm_analysis_port#(mac_array_trans) ap;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
        ap = new("ap", this);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        if (!uvm_config_db#(virtual mac_array_if.tb)::get(
            this, "", "vif", vif))
            `uvm_fatal("NOVIF", "Virtual interface not found")
    endfunction
    
    task run_phase(uvm_phase phase);
        mac_array_trans t;
        
        forever begin
            // 监控输入
            t = mac_array_trans::type_id::create("t");
            collect_input(t);
            
            // 等待输出
            wait(vif.valid_out);
            @(posedge vif.clk);
            
            // 收集输出
            for (int i = 0; i < 4; i++) begin
                for (int j = 0; j < 4; j++) begin
                    t.c_matrix[i][j] = vif.c_out[i][j];
                end
            end
            
            ap.write(t);
        end
    endtask
    
    task collect_input(mac_array_trans t);
        // 收集输入矩阵（简化版）
        @(posedge vif.clk iff vif.enable);
        // 实际实现需要根据脉动输入模式重建完整矩阵
    endtask
endclass

// Scoreboard with Python Golden Model
class mac_array_scoreboard extends uvm_scoreboard;
    `uvm_component_utils(mac_array_scoreboard)
    
    uvm_analysis_export#(mac_array_trans) analysis_export;
    
    // Python接口
    int python_fd;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        analysis_export = new("analysis_export", this);
        
        // 启动Python进程
        python_fd = $system("python3 mac_golden_model.py &");
    endfunction
    
    function void write(mac_array_trans t);
        bit [31:0] expected[3:0][3:0];
        
        // 调用Python计算期望结果
        compute_expected(t.a_matrix, t.b_matrix, expected);
        
        // 比较结果
        for (int i = 0; i < 4; i++) begin
            for (int j = 0; j < 4; j++) begin
                if (t.c_matrix[i][j] !== expected[i][j]) begin
                    `uvm_error("SCOREBOARD", 
                        $sformatf("Mismatch at [%0d][%0d]: got=%0d, exp=%0d",
                        i, j, t.c_matrix[i][j], expected[i][j]))
                end
            end
        end
        
        `uvm_info("SCOREBOARD", "Matrix multiplication passed", UVM_MEDIUM)
    endfunction
    
    function void compute_expected(
        bit [7:0] a[3:0][3:0], 
        bit [7:0] b[3:0][3:0],
        ref bit [31:0] c[3:0][3:0]
    );
        // 与Python通信计算结果
        // 简化示例：直接计算
        for (int i = 0; i < 4; i++) begin
            for (int j = 0; j < 4; j++) begin
                c[i][j] = 0;
                for (int k = 0; k < 4; k++) begin
                    c[i][j] += a[i][k] * b[k][j];
                end
            end
        end
    endfunction
endclass

// 覆盖率收集
class mac_array_coverage extends uvm_subscriber#(mac_array_trans);
    `uvm_component_utils(mac_array_coverage)
    
    mac_array_trans t;
    
    covergroup mac_cg;
        // 输入数据模式
        a_pattern: coverpoint get_pattern(t.a_matrix) {
            bins zero = {0};
            bins identity = {1};
            bins sparse = {2};
            bins dense = {3};
        }
        
        b_pattern: coverpoint get_pattern(t.b_matrix) {
            bins zero = {0};
            bins identity = {1};
            bins sparse = {2};
            bins dense = {3};
        }
        
        // 交叉覆盖
        pattern_cross: cross a_pattern, b_pattern;
        
        // 数值范围覆盖
        a_values: coverpoint t.a_matrix[0][0] {
            bins low = {[0:63]};
            bins mid = {[64:191]};
            bins high = {[192:255]};
        }
    endgroup
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
        mac_cg = new();
    endfunction
    
    function void write(mac_array_trans tr);
        t = tr;
        mac_cg.sample();
    endfunction
    
    function int get_pattern(bit [7:0] matrix[3:0][3:0]);
        int zero_count = 0;
        
        // 检查零矩阵
        foreach(matrix[i,j]) if (matrix[i][j] == 0) zero_count++;
        if (zero_count == 16) return 0;
        
        // 检查单位矩阵
        bit is_identity = 1;
        foreach(matrix[i,j]) begin
            if (i == j && matrix[i][j] != 1) is_identity = 0;
            if (i != j && matrix[i][j] != 0) is_identity = 0;
        end
        if (is_identity) return 1;
        
        // 稀疏/稠密
        if (zero_count > 12) return 2;
        else return 3;
    endfunction
endclass
                        </div>
                    </div>
                </div>
            </div>

            <h3>7.4 可测试性设计（DFT）</h3>
            
            <p>可测试性设计（Design for Testability, DFT）是在芯片设计阶段加入的专门电路，用于提高芯片的可测试性，确保能够高效地检测制造缺陷。NPU由于其高集成度和复杂性，DFT设计尤为重要。DFT就像是给芯片安装了“透视眼”——让我们能看到芯片内部的健康状况，及时发现和诊断问题。</p>
            
            <p>一个惊人的数据：在现代7nm工艺下，一个NPU芯片可能包含超过100亿个晶体管。即使制造工艺的良率达到99.99%，仍然意味着每个芯片可能有上百万个潜在缺陷。没有有效的DFT设计，这些缺陷就像“定时炸弹”，可能在产品使用过程中突然爆发。特别是对于汽车级NPU，任何一个未被检测到的缺陷都可能导致灾难性后果。</p>
            
            <p>DFT的挑战在于平衡“可测试性”和“开销”。增加DFT电路会带来面积、功耗和时序的开销，但这些开销换来的是更高的产品质量和更低的故障率。业界的经验法则是：DFT电路通常占芯片总面积的5-10%，但能将测试成本降低90%以上。对于大规模量产的NPU，这是一个非常划算的投资。</p>
            
            <div class="info-box">
                <p><strong>DFT核心概念：</strong></p>
                <ul>
                    <li><strong>故障模型：</strong>
                        <ul>
                            <li>固定型故障（Stuck-at faults）：信号固定在0或1</li>
                            <li>转换故障（Transition faults）：信号无法在规定时间内转换</li>
                            <li>桥接故障（Bridging faults）：信号间短路</li>
                            <li>开路故障（Open faults）：信号断开</li>
                        </ul>
                    </li>
                    <li><strong>测试目标：</strong>
                        <ul>
                            <li>故障覆盖率 > 99%（汽车级要求99.5%+）</li>
                            <li>测试时间最小化</li>
                            <li>测试成本优化</li>
                            <li>良率提升</li>
                        </ul>
                    </li>
                    <li><strong>DFT技术分类：</strong>
                        <ul>
                            <li>结构测试：扫描链、边界扫描</li>
                            <li>内建自测试：MBIST、LBIST</li>
                            <li>功能测试：at-speed测试</li>
                            <li>诊断功能：故障定位、修复</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <h4>7.4.1 扫描链设计</h4>
            <p>扫描链是DFT的基础技术，通过将设计中的触发器连接成移位寄存器链，实现对内部节点的可控性和可观测性。扫描链的原理很简单，就像是给芯片内部的每个“小盒子”（触发器）都安装了一扇“后门”，测试时可以直接访问这些盒子的内容。</p>
            
            <p>扫描链设计的艺术在于如何高效地组织这些“后门”。在一个典型的NPU中，可能有数百万个触发器需要加入扫描链。如果把它们全部串成一条链，测试时间会长得不可接受。因此，我们需要将它们分成多条平衡的链，并行测试。这就像是机场安检——多个通道同时工作，大大缩短了排队时间。</p>
            
            <div class="info-box">
                <p><strong>扫描链设计要点：</strong></p>
                <div style="text-align: center; margin: 20px 0;">
                    <pre style="display: inline-block; text-align: left;">
    功能模式：     D ──→ [FF] ──→ Q ──→ 组合逻辑
                        ↑
                       CLK
    
    扫描模式：  SI ──→ [MUX] ──→ [FF] ──→ Q/SO ──→ 下一个FF
                       ↑  ↑           ↑
                      SE  D          CLK
                    </pre>
                </div>
                <ul>
                    <li><strong>扫描链分组：</strong>按时钟域、电压域、功能模块分组</li>
                    <li><strong>链长平衡：</strong>各扫描链长度均衡，减少测试时间</li>
                    <li><strong>扫描压缩：</strong>使用压缩技术减少测试数据量</li>
                    <li><strong>时序考虑：</strong>扫描路径的时序约束相对宽松</li>
                </ul>
            </div>
            
            <div class="code-block">
// 扫描触发器实现
module scan_ff (
    input wire clk,
    input wire rst_n,
    input wire d,          // 功能数据输入
    input wire si,         // 扫描输入
    input wire se,         // 扫描使能
    output reg q,          // 数据输出
    output wire so         // 扫描输出
);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            q <= 1'b0;
        end else begin
            q <= se ? si : d;  // 扫描模式时选择扫描输入
        end
    end
    
    assign so = q;  // 扫描输出连接到Q

endmodule

// NPU控制器的扫描链插入
module npu_controller_with_scan (
    input wire clk,
    input wire rst_n,
    
    // 功能接口
    input wire [31:0] instruction,
    input wire inst_valid,
    output reg inst_ready,
    output reg [7:0] control_signals,
    
    // DFT接口
    input wire scan_enable,
    input wire scan_in,
    output wire scan_out
);

    // 状态机寄存器（使用扫描触发器）
    wire [2:0] state_d, state_q;
    wire [2:0] state_scan_chain;
    
    scan_ff state_ff[2:0] (
        .clk(clk),
        .rst_n(rst_n),
        .d(state_d),
        .si({state_scan_chain[1:0], scan_in}),
        .se(scan_enable),
        .q(state_q),
        .so(state_scan_chain)
    );
    
    // 指令寄存器（使用扫描触发器）
    wire [31:0] inst_reg_d, inst_reg_q;
    wire [31:0] inst_scan_chain;
    
    genvar i;
    generate
        for (i = 0; i < 32; i = i + 1) begin : inst_scan_gen
            scan_ff inst_ff (
                .clk(clk),
                .rst_n(rst_n),
                .d(inst_reg_d[i]),
                .si(i == 0 ? state_scan_chain[2] : inst_scan_chain[i-1]),
                .se(scan_enable),
                .q(inst_reg_q[i]),
                .so(inst_scan_chain[i])
            );
        end
    endgenerate
    
    // 控制逻辑
    always @(*) begin
        // 状态机逻辑
        case (state_q)
            3'b000: begin  // IDLE
                if (inst_valid) begin
                    state_d = 3'b001;  // DECODE
                    inst_reg_d = instruction;
                end else begin
                    state_d = state_q;
                    inst_reg_d = inst_reg_q;
                end
            end
            // ... 其他状态
        endcase
    end
    
    assign scan_out = inst_scan_chain[31];

endmodule

// ATPG测试模式生成
module atpg_controller (
    input wire clk,
    input wire rst_n,
    
    // ATPG控制
    input wire test_mode,
    input wire scan_enable,
    input wire [3:0] test_pattern_sel,
    
    // 扫描链接口
    output reg [7:0] scan_in_ports,
    input wire [7:0] scan_out_ports,
    
    // 测试结果
    output reg test_done,
    output reg test_pass
);

    // 测试向量ROM
    reg [7:0] test_vectors [0:1023];
    reg [7:0] expected_responses [0:1023];
    
    // 测试状态机
    localparam TEST_IDLE = 2'b00;
    localparam TEST_SHIFT = 2'b01;
    localparam TEST_CAPTURE = 2'b10;
    localparam TEST_COMPARE = 2'b11;
    
    reg [1:0] test_state;
    reg [9:0] vector_cnt;
    reg [7:0] shift_cnt;
    reg [7:0] captured_data [0:127];
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            test_state <= TEST_IDLE;
            test_done <= 1'b0;
            test_pass <= 1'b1;
        end else if (test_mode) begin
            case (test_state)
                TEST_IDLE: begin
                    if (scan_enable) begin
                        test_state <= TEST_SHIFT;
                        vector_cnt <= 0;
                        shift_cnt <= 0;
                    end
                end
                
                TEST_SHIFT: begin
                    // 移入测试向量
                    scan_in_ports <= test_vectors[vector_cnt];
                    shift_cnt <= shift_cnt + 1;
                    
                    if (shift_cnt == 127) begin  // 假设链长128
                        test_state <= TEST_CAPTURE;
                    end
                end
                
                TEST_CAPTURE: begin
                    // 捕获响应
                    captured_data[shift_cnt] <= scan_out_ports;
                    shift_cnt <= shift_cnt + 1;
                    
                    if (shift_cnt == 127) begin
                        test_state <= TEST_COMPARE;
                    end
                end
                
                TEST_COMPARE: begin
                    // 比较结果
                    for (int i = 0; i < 128; i++) begin
                        if (captured_data[i] != expected_responses[vector_cnt + i]) begin
                            test_pass <= 1'b0;
                        end
                    end
                    
                    vector_cnt <= vector_cnt + 128;
                    if (vector_cnt >= 1024) begin
                        test_done <= 1'b1;
                        test_state <= TEST_IDLE;
                    end else begin
                        test_state <= TEST_SHIFT;
                        shift_cnt <= 0;
                    end
                end
            endcase
        end
    end

endmodule
            </div>

            <h4>7.4.2 存储器内建自测试（MBIST）</h4>
            
            <p>NPU包含大量SRAM用于存储权重、激活值和中间结果。MBIST是测试这些存储器的关键技术，能够以全速测试存储单元，检测各种故障模式。</p>
            
            <div class="info-box">
                <p><strong>MBIST关键特性：</strong></p>
                <ul>
                    <li><strong>测试算法：</strong>
                        <ul>
                            <li>March C-：检测所有SAF、TF、耦合故障</li>
                            <li>March C+：增强版，更高故障覆盖率</li>
                            <li>Checkerboard：检测相邻单元耦合</li>
                            <li>Walking 1/0：检测地址解码故障</li>
                        </ul>
                    </li>
                    <li><strong>NPU特殊考虑：</strong>
                        <ul>
                            <li>权重存储器：需要retention测试</li>
                            <li>激活值缓存：需要高速测试</li>
                            <li>多端口SRAM：端口间干扰测试</li>
                            <li>ECC保护：需要ECC逻辑测试</li>
                        </ul>
                    </li>
                    <li><strong>测试效率优化：</strong>
                        <ul>
                            <li>并行测试多个存储器</li>
                            <li>分层测试大容量存储器</li>
                            <li>可编程测试算法</li>
                            <li>故障诊断和修复支持</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <div class="code-block">
// 增强型MBIST控制器（支持多种算法和诊断）
module mbist_controller #(
    parameter ADDR_WIDTH = 10,
    parameter DATA_WIDTH = 32
)(
    input wire clk,
    input wire rst_n,
    
    // BIST控制
    input wire bist_en,
    input wire bist_mode,  // 0: March C-, 1: Checkerboard
    
    // 存储器接口
    output reg mem_en,
    output reg mem_we,
    output reg [ADDR_WIDTH-1:0] mem_addr,
    output reg [DATA_WIDTH-1:0] mem_wdata,
    input wire [DATA_WIDTH-1:0] mem_rdata,
    
    // BIST状态
    output reg bist_done,
    output reg bist_fail,
    output reg [ADDR_WIDTH-1:0] fail_addr,
    output reg [DATA_WIDTH-1:0] fail_data
);

    // March C- 算法状态
    localparam IDLE = 4'b0000;
    localparam W0_UP = 4'b0001;    // 写0，地址递增
    localparam R0W1_UP = 4'b0010;  // 读0写1，地址递增
    localparam R1W0_UP = 4'b0011;  // 读1写0，地址递增
    localparam R0W1_DN = 4'b0100;  // 读0写1，地址递减
    localparam R1W0_DN = 4'b0101;  // 读1写0，地址递减
    localparam R0_UP = 4'b0110;    // 读0，地址递增
    localparam DONE = 4'b0111;
    
    reg [3:0] state, next_state;
    reg [ADDR_WIDTH-1:0] addr_cnt;
    reg addr_dir;  // 0: up, 1: down
    reg [DATA_WIDTH-1:0] expected_data;
    
    // 状态机
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            bist_done <= 1'b0;
            bist_fail <= 1'b0;
        end else begin
            state <= next_state;
            
            // 错误检测
            if (mem_en && !mem_we && state != IDLE) begin
                if (mem_rdata !== expected_data) begin
                    bist_fail <= 1'b1;
                    fail_addr <= mem_addr;
                    fail_data <= mem_rdata;
                end
            end
        end
    end
    
    // 下一状态逻辑
    always @(*) begin
        next_state = state;
        
        case (state)
            IDLE: begin
                if (bist_en) begin
                    if (bist_mode == 0)  // March C-
                        next_state = W0_UP;
                    else  // 其他算法
                        next_state = W0_UP;
                end
            end
            
            W0_UP: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}})
                    next_state = R0W1_UP;
            end
            
            R0W1_UP: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}})
                    next_state = R1W0_UP;
            end
            
            R1W0_UP: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}})
                    next_state = R0W1_DN;
            end
            
            R0W1_DN: begin
                if (addr_cnt == 0)
                    next_state = R1W0_DN;
            end
            
            R1W0_DN: begin
                if (addr_cnt == 0)
                    next_state = R0_UP;
            end
            
            R0_UP: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}})
                    next_state = DONE;
            end
            
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end
    
    // 地址和数据生成
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            addr_cnt <= 0;
            mem_en <= 1'b0;
            mem_we <= 1'b0;
            mem_addr <= 0;
            mem_wdata <= 0;
            expected_data <= 0;
        end else begin
            case (state)
                W0_UP: begin  // 写0
                    mem_en <= 1'b1;
                    mem_we <= 1'b1;
                    mem_addr <= addr_cnt;
                    mem_wdata <= 0;
                    addr_cnt <= addr_cnt + 1;
                end
                
                R0W1_UP: begin  // 读0写1
                    mem_en <= 1'b1;
                    if (mem_we) begin  // 写周期
                        mem_we <= 1'b0;
                        expected_data <= 0;
                    end else begin  // 读周期
                        mem_we <= 1'b1;
                        mem_wdata <= {DATA_WIDTH{1'b1}};
                        addr_cnt <= addr_cnt + 1;
                    end
                    mem_addr <= addr_cnt;
                end
                
                // 类似处理其他状态...
                
                DONE: begin
                    bist_done <= 1'b1;
                    mem_en <= 1'b0;
                end
            endcase
        end
    end

endmodule

// 逻辑BIST（LBIST）
module lbist_controller (
    input wire clk,
    input wire rst_n,
    
    // LBIST控制
    input wire lbist_en,
    input wire [15:0] pattern_count,
    
    // PRPG（伪随机图形生成器）
    output reg [31:0] prpg_out,
    
    // MISR（多输入特征寄存器）
    input wire [31:0] response_in,
    output reg [31:0] signature,
    
    // 状态输出
    output reg lbist_done,
    output reg signature_valid
);

    // LFSR用于PRPG
    reg [31:0] lfsr;
    wire feedback = lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0];
    
    // MISR寄存器
    reg [31:0] misr;
    
    // 模式计数器
    reg [15:0] pattern_cnt;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            lfsr <= 32'h12345678;  // 非零种子
            misr <= 32'h0;
            pattern_cnt <= 0;
            lbist_done <= 1'b0;
            signature_valid <= 1'b0;
        end else if (lbist_en) begin
            // PRPG: LFSR更新
            lfsr <= {lfsr[30:0], feedback};
            prpg_out <= lfsr;
            
            // MISR: 特征压缩
            misr <= {misr[30:0], misr[31]} ^ response_in;
            
            // 模式计数
            pattern_cnt <= pattern_cnt + 1;
            if (pattern_cnt == pattern_count - 1) begin
                lbist_done <= 1'b1;
                signature <= misr;
                signature_valid <= 1'b1;
            end
        end
    end

endmodule
            </div>

            <h4>7.4.3 JTAG与TAP控制器设计</h4>
            
            <p>JTAG（Joint Test Action Group）提供标准化的测试访问接口，TAP（Test Access Port）控制器是其核心。</p>

            <div class="code-block">
// TAP控制器状态机
module tap_controller (
    input  wire        tck,      // 测试时钟
    input  wire        tms,      // 测试模式选择
    input  wire        tdi,      // 测试数据输入
    input  wire        trst_n,   // 测试复位
    output reg         tdo,      // 测试数据输出
    output reg         tdo_en,   // TDO输出使能
    
    // TAP状态输出
    output reg         capture_dr,
    output reg         shift_dr,
    output reg         update_dr,
    output reg         capture_ir,
    output reg         shift_ir,
    output reg         update_ir,
    output reg  [3:0]  tap_state
);

    // TAP状态编码
    localparam TEST_LOGIC_RESET = 4'h0;
    localparam RUN_TEST_IDLE    = 4'h1;
    localparam SELECT_DR_SCAN   = 4'h2;
    localparam CAPTURE_DR       = 4'h3;
    localparam SHIFT_DR         = 4'h4;
    localparam EXIT1_DR         = 4'h5;
    localparam PAUSE_DR         = 4'h6;
    localparam EXIT2_DR         = 4'h7;
    localparam UPDATE_DR        = 4'h8;
    localparam SELECT_IR_SCAN   = 4'h9;
    localparam CAPTURE_IR       = 4'hA;
    localparam SHIFT_IR         = 4'hB;
    localparam EXIT1_IR         = 4'hC;
    localparam PAUSE_IR         = 4'hD;
    localparam EXIT2_IR         = 4'hE;
    localparam UPDATE_IR        = 4'hF;

    // TAP状态机
    always @(posedge tck or negedge trst_n) begin
        if (!trst_n) begin
            tap_state <= TEST_LOGIC_RESET;
        end else begin
            case (tap_state)
                TEST_LOGIC_RESET: tap_state <= tms ? TEST_LOGIC_RESET : RUN_TEST_IDLE;
                RUN_TEST_IDLE:    tap_state <= tms ? SELECT_DR_SCAN : RUN_TEST_IDLE;
                SELECT_DR_SCAN:   tap_state <= tms ? SELECT_IR_SCAN : CAPTURE_DR;
                CAPTURE_DR:       tap_state <= tms ? EXIT1_DR : SHIFT_DR;
                SHIFT_DR:         tap_state <= tms ? EXIT1_DR : SHIFT_DR;
                EXIT1_DR:         tap_state <= tms ? UPDATE_DR : PAUSE_DR;
                PAUSE_DR:         tap_state <= tms ? EXIT2_DR : PAUSE_DR;
                EXIT2_DR:         tap_state <= tms ? UPDATE_DR : SHIFT_DR;
                UPDATE_DR:        tap_state <= tms ? SELECT_DR_SCAN : RUN_TEST_IDLE;
                SELECT_IR_SCAN:   tap_state <= tms ? TEST_LOGIC_RESET : CAPTURE_IR;
                CAPTURE_IR:       tap_state <= tms ? EXIT1_IR : SHIFT_IR;
                SHIFT_IR:         tap_state <= tms ? EXIT1_IR : SHIFT_IR;
                EXIT1_IR:         tap_state <= tms ? UPDATE_IR : PAUSE_IR;
                PAUSE_IR:         tap_state <= tms ? EXIT2_IR : PAUSE_IR;
                EXIT2_IR:         tap_state <= tms ? UPDATE_IR : SHIFT_IR;
                UPDATE_IR:        tap_state <= tms ? SELECT_DR_SCAN : RUN_TEST_IDLE;
            endcase
        end
    end

    // 状态解码
    always @(*) begin
        capture_dr = (tap_state == CAPTURE_DR);
        shift_dr   = (tap_state == SHIFT_DR);
        update_dr  = (tap_state == UPDATE_DR);
        capture_ir = (tap_state == CAPTURE_IR);
        shift_ir   = (tap_state == SHIFT_IR);
        update_ir  = (tap_state == UPDATE_IR);
        tdo_en     = shift_dr || shift_ir;
    end

endmodule

// NPU JTAG包装器
module npu_jtag_wrapper (
    input  wire        tck,
    input  wire        tms,
    input  wire        tdi,
    input  wire        trst_n,
    output wire        tdo,
    
    // NPU接口
    input  wire        npu_clk,
    input  wire        npu_rst_n,
    output reg         jtag_access_req,
    output reg  [31:0] jtag_addr,
    output reg  [31:0] jtag_wdata,
    output reg         jtag_write,
    input  wire [31:0] jtag_rdata,
    input  wire        jtag_ready
);

    // 指令寄存器
    localparam EXTEST   = 4'b0000;
    localparam BYPASS   = 4'b1111;
    localparam IDCODE   = 4'b0010;
    localparam NPU_ACC  = 4'b1000;  // NPU访问指令
    localparam NPU_CTRL = 4'b1001;  // NPU控制指令
    
    reg [3:0] instruction_reg;
    reg [31:0] idcode_reg = 32'h12345678;  // 示例ID
    reg [31:0] data_reg;
    
    // TAP控制器实例
    wire capture_dr, shift_dr, update_dr;
    wire capture_ir, shift_ir, update_ir;
    wire [3:0] tap_state;
    wire tdo_en;
    reg tdo_reg;
    
    tap_controller u_tap (
        .tck(tck),
        .tms(tms),
        .tdi(tdi),
        .trst_n(trst_n),
        .tdo(tdo_reg),
        .tdo_en(tdo_en),
        .capture_dr(capture_dr),
        .shift_dr(shift_dr),
        .update_dr(update_dr),
        .capture_ir(capture_ir),
        .shift_ir(shift_ir),
        .update_ir(update_ir),
        .tap_state(tap_state)
    );
    
    // TDO输出多路选择
    assign tdo = tdo_en ? tdo_reg : 1'bz;
    
    // 指令寄存器操作
    always @(posedge tck or negedge trst_n) begin
        if (!trst_n) begin
            instruction_reg <= IDCODE;
        end else if (capture_ir) begin
            instruction_reg <= BYPASS;
        end else if (shift_ir) begin
            instruction_reg <= {tdi, instruction_reg[3:1]};
        end
    end
    
    // 数据寄存器操作
    always @(posedge tck or negedge trst_n) begin
        if (!trst_n) begin
            data_reg <= 32'h0;
        end else if (capture_dr) begin
            case (instruction_reg)
                IDCODE:   data_reg <= idcode_reg;
                NPU_ACC:  data_reg <= jtag_rdata;
                default:  data_reg <= 32'h0;
            endcase
        end else if (shift_dr) begin
            data_reg <= {tdi, data_reg[31:1]};
        end
    end
    
    // TDO输出选择
    always @(*) begin
        if (shift_ir) begin
            tdo_reg = instruction_reg[0];
        end else if (shift_dr) begin
            case (instruction_reg)
                BYPASS:   tdo_reg = tdi;  // 旁路
                default:  tdo_reg = data_reg[0];
            endcase
        end else begin
            tdo_reg = 1'b0;
        end
    end
    
    // NPU访问控制（跨时钟域）
    reg update_dr_sync1, update_dr_sync2, update_dr_sync3;
    always @(posedge npu_clk or negedge npu_rst_n) begin
        if (!npu_rst_n) begin
            update_dr_sync1 <= 1'b0;
            update_dr_sync2 <= 1'b0;
            update_dr_sync3 <= 1'b0;
        end else begin
            update_dr_sync1 <= update_dr;
            update_dr_sync2 <= update_dr_sync1;
            update_dr_sync3 <= update_dr_sync2;
        end
    end
    
    wire update_dr_pulse = update_dr_sync2 && !update_dr_sync3;
    
    always @(posedge npu_clk or negedge npu_rst_n) begin
        if (!npu_rst_n) begin
            jtag_access_req <= 1'b0;
            jtag_addr <= 32'h0;
            jtag_wdata <= 32'h0;
            jtag_write <= 1'b0;
        end else if (update_dr_pulse && (instruction_reg == NPU_ACC)) begin
            jtag_access_req <= 1'b1;
            jtag_addr <= data_reg;
            jtag_wdata <= data_reg;  // 简化示例
            jtag_write <= data_reg[31];  // MSB表示读/写
        end else if (jtag_ready) begin
            jtag_access_req <= 1'b0;
        end
    end

endmodule
            </div>

            <h4>7.4.4 DFT验证流程</h4>
            
            <p>DFT特性的验证同样重要，需要确保所有测试结构正确工作。</p>

            <div class="code-block">
// DFT验证测试平台
class dft_test_env extends uvm_env;
    `uvm_component_utils(dft_test_env)
    
    // DFT代理
    jtag_agent     jtag_agt;
    scan_agent     scan_agt;
    mbist_monitor  mbist_mon;
    
    // 记分板
    dft_scoreboard scb;
    
    function new(string name = "dft_test_env", uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        jtag_agt = jtag_agent::type_id::create("jtag_agt", this);
        scan_agt = scan_agent::type_id::create("scan_agt", this);
        mbist_mon = mbist_monitor::type_id::create("mbist_mon", this);
        scb = dft_scoreboard::type_id::create("scb", this);
    endfunction
    
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        
        jtag_agt.ap.connect(scb.jtag_export);
        scan_agt.ap.connect(scb.scan_export);
        mbist_mon.ap.connect(scb.mbist_export);
    endfunction
endclass

// 扫描链测试序列
class scan_chain_test_seq extends uvm_sequence;
    `uvm_object_utils(scan_chain_test_seq)
    
    rand int chain_length;
    rand bit [1023:0] scan_pattern;
    
    constraint c_chain_length {
        chain_length inside {[100:1000]};
    }
    
    task body();
        scan_seq_item req;
        
        // 1. 进入扫描模式
        req = scan_seq_item::type_id::create("req");
        req.scan_mode = 1'b1;
        req.scan_enable = 1'b0;
        start_item(req);
        finish_item(req);
        
        // 2. 移入测试向量
        req.scan_enable = 1'b1;
        for (int i = 0; i < chain_length; i++) begin
            req.scan_in = scan_pattern[i];
            start_item(req);
            finish_item(req);
        end
        
        // 3. 捕获响应
        req.scan_enable = 1'b0;
        start_item(req);
        finish_item(req);
        
        // 4. 移出响应
        req.scan_enable = 1'b1;
        for (int i = 0; i < chain_length; i++) begin
            start_item(req);
            finish_item(req);
            // 收集scan_out用于比较
        end
        
        // 5. 退出扫描模式
        req.scan_mode = 1'b0;
        req.scan_enable = 1'b0;
        start_item(req);
        finish_item(req);
    endtask
endclass

// DFT覆盖率收集
class dft_coverage extends uvm_subscriber #(uvm_sequence_item);
    `uvm_component_utils(dft_coverage)
    
    // 覆盖率组
    covergroup scan_cg;
        scan_length: coverpoint scan_length {
            bins short = {[1:100]};
            bins medium = {[101:500]};
            bins long = {[501:1000]};
        }
        
        scan_pattern: coverpoint scan_pattern_type {
            bins all_zeros = {ALL_ZEROS};
            bins all_ones = {ALL_ONES};
            bins checkerboard = {CHECKERBOARD};
            bins random = {RANDOM};
        }
        
        fault_coverage: coverpoint fault_cov_percent {
            bins low = {[0:85]};
            bins medium = {[85:95]};
            bins high = {[95:99]};
            bins excellent = {[99:100]};
        }
    endgroup
    
    covergroup mbist_cg;
        algorithm: coverpoint mbist_algorithm {
            bins march_c = {MARCH_C};
            bins march_c_minus = {MARCH_C_MINUS};
            bins checkerboard = {CHECKERBOARD};
            bins address_decoder = {ADDR_DECODER};
        }
        
        memory_size: coverpoint mem_size {
            bins small = {[0:1024]};
            bins medium = {[1024:64*1024]};
            bins large = {[64*1024:$]};
        }
        
        fault_type: coverpoint detected_fault {
            bins stuck_at = {STUCK_AT};
            bins transition = {TRANSITION};
            bins coupling = {COUPLING};
            bins address = {ADDRESS};
        }
    endgroup
    
    function new(string name = "dft_coverage", uvm_component parent);
        super.new(name, parent);
        scan_cg = new();
        mbist_cg = new();
    endfunction
    
    function void write(uvm_sequence_item t);
        // 根据事务类型采样覆盖率
        if ($cast(scan_item, t)) begin
            scan_length = scan_item.chain_length;
            scan_pattern_type = scan_item.pattern_type;
            fault_cov_percent = scan_item.fault_coverage;
            scan_cg.sample();
        end else if ($cast(mbist_item, t)) begin
            mbist_algorithm = mbist_item.algorithm;
            mem_size = mbist_item.memory_size;
            detected_fault = mbist_item.fault_type;
            mbist_cg.sample();
        end
    endfunction
endclass
            </div>

            <div class="info-box">
                <strong>DFT验证要点：</strong>
                <ul>
                    <li>扫描链连通性测试：验证所有扫描链路径</li>
                    <li>ATPG向量仿真：运行自动生成的测试向量</li>
                    <li>故障注入测试：验证故障检测能力</li>
                    <li>时序验证：确保扫描模式时序满足要求</li>
                    <li>功耗分析：评估测试模式功耗</li>
                </ul>
            </div>

            <h3>7.5 软硬件协同验证</h3>
            
            <p>NPU是软件驱动的硬件，其功能正确性高度依赖于编译器、驱动程序和固件。软硬件协同验证确保整个系统栈的正确性。软硬件协同验证就像是一场精心编排的交响乐——硬件是乐器，软件是乐谱，只有两者完美配合，才能奏出美妙的旋律。</p>
            
            <p>软硬件协同验证的挑战来自于两个世界的差异。硬件工程师习惯于确定性和并行性，而软件工程师则更熟悉顺序执行和抽象层次。一个经典的例子是“内存一致性问题”：软件开发者假设写入内存的数据会立即对所有观察者可见，但在实际硬件中，由于缓存和DMA的存在，这个假设并不总是成立的。Google的TPU团队就曾因为这类问题花费了数周时间进行调试。</p>
            
            <p>现代软硬件协同验证的另一个趋势是“左移”（Shift-Left）——让软件开发在硬件设计的早期就开始。这种方法的好处是双向的：软件开发者可以早期发现API设计的问题，硬件设计者也可以根据软件需求优化硬件架构。Apple的Neural Engine就是通过这种紧密的软硬件协同设计，实现了出色的能效比。</p>
            
            <h4>7.5.1 协同验证平台架构</h4>
            
            <p>协同验证平台需要模拟完整的系统环境，包括CPU、内存、总线和NPU。这就像是搭建一个“虚拟机”，让软件以为自己运行在真实的硬件上。这种平台的构建需要跨领域的专业知识，既要理解硬件的时序精确模型，又要熟悉软件的执行流程。</p>
            <div class="code-block">
// 软硬件协同验证环境
class sw_hw_co_verification_env extends uvm_env;
    `uvm_component_utils(sw_hw_co_verification_env)
    
    // CPU模型（QEMU或ARM Fast Model）
    virtual cpu_model_if cpu_if;
    
    // NPU RTL包装器
    npu_rtl_wrapper npu_wrapper;
    
    // 系统总线
    axi_interconnect_agent axi_agent;
    
    // 内存模型
    memory_model sys_mem;
    
    // 软件代理
    software_agent sw_agent;
    driver_monitor drv_mon;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // 获取CPU模型接口
        if (!uvm_config_db#(virtual cpu_model_if)::get(this, "", "cpu_if", cpu_if))
            `uvm_fatal("CONFIG", "Cannot get CPU model interface")
        
        // 创建组件
        npu_wrapper = npu_rtl_wrapper::type_id::create("npu_wrapper", this);
        axi_agent = axi_interconnect_agent::type_id::create("axi_agent", this);
        sys_mem = memory_model::type_id::create("sys_mem", this);
        sw_agent = software_agent::type_id::create("sw_agent", this);
        drv_mon = driver_monitor::type_id::create("drv_mon", this);
        
        // 配置地址映射
        configure_address_map();
    endfunction
    
    function void configure_address_map();
        // NPU寄存器空间
        uvm_config_db#(addr_range)::set(this, "*", "npu_reg_base", 32'h4000_0000);
        uvm_config_db#(addr_range)::set(this, "*", "npu_reg_size", 32'h0001_0000);
        
        // NPU本地内存
        uvm_config_db#(addr_range)::set(this, "*", "npu_mem_base", 32'h8000_0000);
        uvm_config_db#(addr_range)::set(this, "*", "npu_mem_size", 32'h0400_0000);
        
        // 系统内存
        uvm_config_db#(addr_range)::set(this, "*", "sys_mem_base", 32'h0000_0000);
        uvm_config_db#(addr_range)::set(this, "*", "sys_mem_size", 32'h4000_0000);
    endfunction
endclass

// NPU驱动程序监控器
class driver_monitor extends uvm_monitor;
    `uvm_component_utils(driver_monitor)
    
    // 分析端口
    uvm_analysis_port #(driver_transaction) ap;
    
    // 驱动API跟踪
    typedef enum {
        DRV_INIT,
        DRV_LOAD_MODEL,
        DRV_SET_INPUT,
        DRV_RUN_INFERENCE,
        DRV_GET_OUTPUT,
        DRV_CLEANUP
    } driver_api_e;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
        ap = new("ap", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        driver_transaction trans;
        
        forever begin
            // 监控驱动程序API调用
            wait_for_driver_call();
            
            trans = driver_transaction::type_id::create("trans");
            trans.api_type = get_api_type();
            trans.timestamp = $time;
            
            case (trans.api_type)
                DRV_INIT: capture_init_params(trans);
                DRV_LOAD_MODEL: capture_model_info(trans);
                DRV_RUN_INFERENCE: capture_inference_params(trans);
                default: ;
            endcase
            
            ap.write(trans);
            
            // 验证寄存器访问序列
            verify_register_sequence(trans);
        end
    endtask
    
    task verify_register_sequence(driver_transaction trans);
        // 检查驱动程序是否按照正确顺序访问寄存器
        case (trans.api_type)
            DRV_INIT: begin
                // 验证初始化序列
                check_register_write(NPU_CTRL_REG, NPU_RESET);
                check_register_write(NPU_CTRL_REG, NPU_ENABLE);
                check_register_read(NPU_STATUS_REG);
            end
            
            DRV_LOAD_MODEL: begin
                // 验证模型加载序列
                check_dma_setup();
                check_weight_loading();
                check_config_update();
            end
        endcase
    endtask
endclass

// 软硬件协同测试用例
class sw_hw_co_test extends uvm_test;
    `uvm_component_utils(sw_hw_co_test)
    
    sw_hw_co_verification_env env;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    task run_phase(uvm_phase phase);
        driver_api_sequence drv_seq;
        ml_inference_sequence ml_seq;
        stress_test_sequence stress_seq;
        
        phase.raise_objection(this);
        
        // 测试1: 基本驱动API测试
        `uvm_info("TEST", "Testing driver API compliance", UVM_LOW)
        drv_seq = driver_api_sequence::type_id::create("drv_seq");
        drv_seq.test_all_apis = 1;
        drv_seq.start(env.sw_agent.sequencer);
        
        // 测试2: 真实ML模型推理
        `uvm_info("TEST", "Testing ML model inference", UVM_LOW)
        ml_seq = ml_inference_sequence::type_id::create("ml_seq");
        ml_seq.model_path = "models/mobilenet_v2.tflite";
        ml_seq.input_data = load_test_image("test_data/cat.jpg");
        ml_seq.expected_class = 281; // Cat class ID
        ml_seq.start(env.sw_agent.sequencer);
        
        // 测试3: 压力测试
        `uvm_info("TEST", "Running stress test", UVM_LOW)
        stress_seq = stress_test_sequence::type_id::create("stress_seq");
        stress_seq.num_threads = 4;
        stress_seq.iterations_per_thread = 100;
        stress_seq.start(env.sw_agent.sequencer);
        
        phase.drop_objection(this);
    endtask
endclass
            </div>
            
            <h4>7.5.2 驱动程序验证</h4>
            
            <div class="code-block">
// NPU驱动程序验证检查器
class npu_driver_checker extends uvm_component;
    `uvm_component_utils(npu_driver_checker)
    
    // 寄存器模型
    npu_reg_model reg_model;
    
    // 状态跟踪
    typedef enum {
        NPU_UNINITIALIZED,
        NPU_IDLE,
        NPU_CONFIGURING,
        NPU_RUNNING,
        NPU_ERROR
    } npu_state_e;
    
    npu_state_e current_state = NPU_UNINITIALIZED;
    
    // 寄存器访问历史
    typedef struct {
        bit [31:0] addr;
        bit [31:0] data;
        bit is_write;
        time timestamp;
    } reg_access_t;
    
    reg_access_t access_history[$];
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    // 验证初始化序列
    function bit verify_init_sequence();
        int idx = 0;
        
        // 检查软复位
        if (!check_reg_write(idx++, NPU_CTRL_REG, 32'h0000_0001))
            return 0;
            
        // 检查复位释放
        if (!check_reg_write(idx++, NPU_CTRL_REG, 32'h0000_0000))
            return 0;
            
        // 检查中断使能
        if (!check_reg_write(idx++, NPU_INT_ENABLE_REG, 32'hFFFF_FFFF))
            return 0;
            
        // 检查DMA配置
        if (!check_reg_write(idx++, NPU_DMA_CTRL_REG, 32'h0000_0003))
            return 0;
            
        current_state = NPU_IDLE;
        return 1;
    endfunction
    
    // 验证模型配置序列
    function bit verify_model_config();
        // 检查是否在正确状态
        if (current_state != NPU_IDLE) begin
            `uvm_error("DRV_CHECK", $sformatf(
                "Model config in wrong state: %s", current_state.name()))
            return 0;
        end
        
        // 验证层配置顺序
        if (!verify_layer_config_sequence())
            return 0;
            
        // 验证权重加载
        if (!verify_weight_loading_sequence())
            return 0;
            
        current_state = NPU_CONFIGURING;
        return 1;
    endfunction
    
    // 验证推理执行
    function bit verify_inference_execution();
        bit [31:0] status;
        
        // 检查输入数据DMA
        if (!verify_input_dma_setup())
            return 0;
            
        // 检查启动命令
        if (!check_reg_write_recent(NPU_CMD_REG, NPU_CMD_START))
            return 0;
            
        // 检查状态轮询
        if (!verify_status_polling())
            return 0;
            
        // 检查完成中断处理
        if (!verify_interrupt_handling())
            return 0;
            
        // 检查输出数据DMA
        if (!verify_output_dma_setup())
            return 0;
            
        return 1;
    endfunction
    
    // 检测常见驱动错误
    function void detect_driver_errors();
        // 错误1: 未初始化就使用
        foreach (access_history[i]) begin
            if (access_history[i].addr != NPU_CTRL_REG && 
                i == 0) begin
                `uvm_error("DRV_CHECK", 
                    "NPU accessed before initialization")
            end
        end
        
        // 错误2: 重复初始化
        int init_count = 0;
        foreach (access_history[i]) begin
            if (access_history[i].addr == NPU_CTRL_REG &&
                access_history[i].data == 32'h0000_0001) begin
                init_count++;
            end
        end
        if (init_count > 1) begin
            `uvm_warning("DRV_CHECK", 
                $sformatf("NPU initialized %0d times", init_count))
        end
        
        // 错误3: 未等待操作完成
        check_operation_completion();
        
        // 错误4: 资源泄露
        check_resource_cleanup();
    endfunction
endclass

// 驱动API一致性测试
class driver_api_test_sequence extends uvm_sequence;
    `uvm_object_utils(driver_api_test_sequence)
    
    task body();
        // 测试正常流程
        test_normal_flow();
        
        // 测试错误处理
        test_error_handling();
        
        // 测试并发访问
        test_concurrent_access();
        
        // 测试资源管理
        test_resource_management();
    endtask
    
    task test_normal_flow();
        cpu_instruction_seq cpu_seq;
        
        // 初始化NPU
        cpu_seq = cpu_instruction_seq::type_id::create("cpu_seq");
        cpu_seq.inline_c_code = "npu_init()";
        cpu_seq.start(p_sequencer.cpu_sqr);
        
        // 加载模型
        cpu_seq = cpu_instruction_seq::type_id::create("cpu_seq");
        cpu_seq.inline_c_code = "npu_load_model('resnet50.model')";
        cpu_seq.start(p_sequencer.cpu_sqr);
        
        // 运行推理
        cpu_seq = cpu_instruction_seq::type_id::create("cpu_seq");
        cpu_seq.inline_c_code = "npu_run_inference(input_buffer, output_buffer)";
        cpu_seq.start(p_sequencer.cpu_sqr);
        
        // 验证结果
        verify_inference_result();
    endtask
    
    task test_error_handling();
        // 测试无效参数
        test_invalid_parameters();
        
        // 测试超时处理
        test_timeout_handling();
        
        // 测试中断处理
        test_interrupt_handling();
        
        // 测试恢复机制
        test_error_recovery();
    endtask
endclass
            </div>
            
            <h4>7.5.3 固件验证</h4>
            
            <div class="code-block">
// NPU固件验证环境
class npu_firmware_verification extends uvm_component;
    `uvm_component_utils(npu_firmware_verification)
    
    // 固件加载器
    firmware_loader fw_loader;
    
    // 指令跟踪器
    instruction_tracer inst_tracer;
    
    // 性能分析器
    firmware_profiler fw_profiler;
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    task verify_firmware_boot();
        bit [31:0] boot_status;
        
        // 加载固件到NPU内部RAM
        fw_loader.load_firmware("npu_firmware.bin", 32'h0000_0000);
        
        // 释放NPU复位
        write_register(NPU_CTRL_REG, 32'h0000_0010); // RELEASE_RESET
        
        // 等待启动完成
        wait_boot_complete(boot_status);
        
        // 验证启动状态
        if (boot_status != 32'hBOOT_SUCCESS) begin
            `uvm_error("FW_VERIFY", 
                $sformatf("Firmware boot failed: 0x%08x", boot_status))
        end
        
        // 验证固件版本
        verify_firmware_version();
        
        // 验证功能模块初始化
        verify_module_initialization();
    endtask
    
    task verify_firmware_scheduler();
        scheduler_test_sequence sched_seq;
        
        // 测试任务调度
        sched_seq = scheduler_test_sequence::type_id::create("sched_seq");
        sched_seq.num_tasks = 10;
        sched_seq.task_priorities = '{3, 1, 2, 1, 3, 2, 1, 3, 2, 1};
        sched_seq.start(null);
        
        // 验证调度顺序
        verify_task_execution_order();
        
        // 验证资源分配
        verify_resource_allocation();
        
        // 验证死锁避免
        verify_deadlock_avoidance();
    endtask
    
    task verify_firmware_power_management();
        power_state_e current_state, expected_state;
        
        // 测试空闲时进入低功耗
        force_idle_state(100us);
        current_state = read_power_state();
        expected_state = POWER_STATE_SLEEP;
        
        if (current_state != expected_state) begin
            `uvm_error("FW_VERIFY", 
                $sformatf("Wrong power state: got %s, expected %s",
                current_state.name(), expected_state.name()))
        end
        
        // 测试唤醒延迟
        measure_wakeup_latency();
        
        // 测试动态电压频率调节
        verify_dvfs_operation();
    endtask
endclass

// 固件与驱动交互验证
class fw_driver_interaction_test extends uvm_test;
    `uvm_component_utils(fw_driver_interaction_test)
    
    task run_phase(uvm_phase phase);
        phase.raise_objection(this);
        
        // 测试命令队列
        test_command_queue();
        
        // 测试事件通知
        test_event_notification();
        
        // 测试共享内存
        test_shared_memory();
        
        // 测试同步机制
        test_synchronization();
        
        phase.drop_objection(this);
    endtask
    
    task test_command_queue();
        // 驱动发送多个命令
        for (int i = 0; i < 10; i++) begin
            send_driver_command(CMD_LOAD_LAYER, i);
        end
        
        // 验证固件按序处理
        verify_command_processing_order();
        
        // 测试队列满处理
        fill_command_queue();
        verify_queue_full_handling();
        
        // 测试优先级命令
        test_priority_commands();
    endtask
endclass
            </div>

            <h3>7.6 后硅验证</h3>
            
            <p>后硅验证是芯片流片后的最后一道关卡，也是最令人兴奋和紧张的阶段。当第一批芯片从晶圆厂运回来时，整个团队都屏住呼吸——几个月的努力将在这一刻揭晓。后硅验证就像是新生儿的第一声啼啭，它告诉我们芯片是否健康地来到这个世界。</p>
            
            <p>后硅验证的挑战在于“未知的未知”。即使经过了最严格的前端验证，实际硅片中仍可能存在各种意外：工艺偏差、电源噪声、温度效应、封装应力等。一个著名的例子是Intel的Pentium FDIV bug——这个浮点除法错误在数百万片芯片出货后才被发现，导致了巨额的召回成本。这个教训提醒我们：后硅验证不仅要验证功能，还要在各种极限条件下测试芯片的鲁棒性。</p>
            
            <p>现代NPU的后硅验证特别复杂，因为它们通常包含多种新技术：先进工艺节点、高速串行接口、HBM存储、多芯片封装等。每一项新技术都可能带来新的问题。例如，NVIDIA在其首次采用HBM的GPU中遇到了严重的信号完整性问题，需要通过复杂的固件补丁和信号调整才解决。</p>
            
            <h4>7.6.1 芯片带起（Bring-up）</h4>
            <p>芯片带起是后硅验证的第一步，就像是唤醒一个沉睡的巨人。这个过程需要极大的耐心和细心——从最基本的电源上电开始，逐步验证时钟、复位、JTAG、基本寄存器访问，直到能够运行第一个程序。每一步都可能遇到意想不到的问题。</p>
            <div class="code-block">
// JTAG调试接口
module jtag_debug_interface (
    // JTAG接口
    input wire tck,
    input wire tms,
    input wire tdi,
    output reg tdo,
    input wire trst_n,
    
    // 内部调试接口
    output reg [31:0] debug_addr,
    output reg [31:0] debug_wdata,
    output reg debug_wen,
    output reg debug_ren,
    input wire [31:0] debug_rdata,
    input wire debug_ready
);

    // TAP状态机
    localparam TEST_LOGIC_RESET = 4'h0;
    localparam RUN_TEST_IDLE = 4'h1;
    localparam SELECT_DR_SCAN = 4'h2;
    localparam CAPTURE_DR = 4'h3;
    localparam SHIFT_DR = 4'h4;
    localparam EXIT1_DR = 4'h5;
    localparam PAUSE_DR = 4'h6;
    localparam EXIT2_DR = 4'h7;
    localparam UPDATE_DR = 4'h8;
    localparam SELECT_IR_SCAN = 4'h9;
    localparam CAPTURE_IR = 4'hA;
    localparam SHIFT_IR = 4'hB;
    localparam EXIT1_IR = 4'hC;
    localparam PAUSE_IR = 4'hD;
    localparam EXIT2_IR = 4'hE;
    localparam UPDATE_IR = 4'hF;
    
    reg [3:0] tap_state;
    reg [4:0] ir_reg;  // 指令寄存器
    reg [63:0] dr_reg;  // 数据寄存器
    
    // 指令定义
    localparam IDCODE = 5'b00001;
    localparam ADDR = 5'b00010;
    localparam DATA = 5'b00011;
    localparam CONTROL = 5'b00100;
    
    // TAP控制器状态机
    always @(posedge tck or negedge trst_n) begin
        if (!trst_n) begin
            tap_state <= TEST_LOGIC_RESET;
        end else begin
            case (tap_state)
                TEST_LOGIC_RESET: tap_state <= tms ? TEST_LOGIC_RESET : RUN_TEST_IDLE;
                RUN_TEST_IDLE: tap_state <= tms ? SELECT_DR_SCAN : RUN_TEST_IDLE;
                SELECT_DR_SCAN: tap_state <= tms ? SELECT_IR_SCAN : CAPTURE_DR;
                CAPTURE_DR: tap_state <= tms ? EXIT1_DR : SHIFT_DR;
                SHIFT_DR: tap_state <= tms ? EXIT1_DR : SHIFT_DR;
                EXIT1_DR: tap_state <= tms ? UPDATE_DR : PAUSE_DR;
                PAUSE_DR: tap_state <= tms ? EXIT2_DR : PAUSE_DR;
                EXIT2_DR: tap_state <= tms ? UPDATE_DR : SHIFT_DR;
                UPDATE_DR: tap_state <= tms ? SELECT_DR_SCAN : RUN_TEST_IDLE;
                SELECT_IR_SCAN: tap_state <= tms ? TEST_LOGIC_RESET : CAPTURE_IR;
                CAPTURE_IR: tap_state <= tms ? EXIT1_IR : SHIFT_IR;
                SHIFT_IR: tap_state <= tms ? EXIT1_IR : SHIFT_IR;
                EXIT1_IR: tap_state <= tms ? UPDATE_IR : PAUSE_IR;
                PAUSE_IR: tap_state <= tms ? EXIT2_IR : PAUSE_IR;
                EXIT2_IR: tap_state <= tms ? UPDATE_IR : SHIFT_IR;
                UPDATE_IR: tap_state <= tms ? SELECT_DR_SCAN : RUN_TEST_IDLE;
            endcase
        end
    end
    
    // IR和DR操作
    always @(posedge tck) begin
        case (tap_state)
            SHIFT_IR: begin
                ir_reg <= {tdi, ir_reg[4:1]};
                tdo <= ir_reg[0];
            end
            
            CAPTURE_DR: begin
                case (ir_reg)
                    IDCODE: dr_reg[31:0] <= 32'h12345678;  // 芯片ID
                    DATA: dr_reg[31:0] <= debug_rdata;
                endcase
            end
            
            SHIFT_DR: begin
                dr_reg <= {tdi, dr_reg[63:1]};
                tdo <= dr_reg[0];
            end
            
            UPDATE_DR: begin
                case (ir_reg)
                    ADDR: debug_addr <= dr_reg[31:0];
                    DATA: begin
                        debug_wdata <= dr_reg[31:0];
                        debug_wen <= dr_reg[32];
                        debug_ren <= dr_reg[33];
                    end
                endcase
            end
        endcase
    end

endmodule

// 片上调试监控器
module on_chip_debug_monitor (
    input wire clk,
    input wire rst_n,
    
    // 监控信号
    input wire [31:0] pc,
    input wire [31:0] instruction,
    input wire inst_valid,
    input wire [31:0] npu_status,
    
    // 触发控制
    input wire [31:0] trigger_pc,
    input wire trigger_en,
    
    // Trace缓冲区接口
    output reg trace_wen,
    output reg [63:0] trace_data,
    output reg [9:0] trace_addr
);

    // 触发检测
    wire trigger_hit = trigger_en && (pc == trigger_pc);
    reg triggered;
    reg [9:0] trace_cnt;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            triggered <= 1'b0;
            trace_cnt <= 0;
            trace_wen <= 1'b0;
        end else begin
            if (trigger_hit) begin
                triggered <= 1'b1;
                trace_cnt <= 0;
            end
            
            if (triggered && inst_valid) begin
                trace_wen <= 1'b1;
                trace_data <= {pc, instruction};
                trace_addr <= trace_cnt;
                trace_cnt <= trace_cnt + 1;
                
                if (trace_cnt == 1023) begin  // Trace buffer满
                    triggered <= 1'b0;
                end
            end else begin
                trace_wen <= 1'b0;
            end
        end
    end

endmodule
            </div>

            <h4>7.5.2 性能调优与Shmoo测试</h4>
            <div class="code-block">
// 优化的Shmoo测试控制器 - Verilog版本
module shmoo_test_controller (
    input wire clk,
    input wire rst_n,
    
    // 测试控制
    input wire shmoo_start,
    input wire [7:0] vdd_start,      // 起始电压（单位：10mV）
    input wire [7:0] vdd_end,        // 结束电压
    input wire [7:0] vdd_step,       // 电压步进
    input wire [9:0] freq_start,     // 起始频率（单位：MHz）
    input wire [9:0] freq_end,       // 结束频率
    input wire [9:0] freq_step,      // 频率步进
    
    // 电源和时钟控制
    output reg [7:0] vdd_ctrl,
    output reg [9:0] freq_ctrl,
    output reg pll_reconfig,
    output reg vdd_stable,           // 电压稳定指示
    output reg pll_locked,           // PLL锁定指示
    
    // 测试执行
    output reg test_trigger,
    input wire test_done,
    input wire test_pass,
    input wire test_error,           // 测试错误标志
    
    // 结果存储
    output reg result_wen,
    output reg [17:0] result_addr,   // [17:10]=VDD, [9:0]=Freq
    output reg [1:0] result_data,    // 00=Fail, 01=Pass, 10=Error, 11=Skip
    
    // 状态输出
    output reg shmoo_done,
    output reg [2:0] current_state,  // 调试用状态输出
    output reg [31:0] test_count,    // 测试计数
    output reg [31:0] pass_count     // 通过计数
);

    // 状态机定义
    localparam IDLE = 3'b000;
    localparam SET_VDD = 3'b001;
    localparam WAIT_VDD = 3'b010;
    localparam SET_FREQ = 3'b011;
    localparam WAIT_PLL = 3'b100;
    localparam RUN_TEST = 3'b101;
    localparam STORE_RESULT = 3'b110;
    localparam NEXT_POINT = 3'b111;
    
    // 内部寄存器
    reg [2:0] state, next_state;
    reg [7:0] current_vdd, next_vdd;
    reg [9:0] current_freq, next_freq;
    reg [15:0] settle_cnt;
    reg [3:0] retry_cnt;
    
    // 流水线寄存器 - 避免组合逻辑
    reg [7:0] vdd_target;
    reg [9:0] freq_target;
    reg test_in_progress;
    reg result_pending;
    
    // 配置参数寄存器（避免直接使用输入）
    reg [7:0] vdd_start_reg, vdd_end_reg, vdd_step_reg;
    reg [9:0] freq_start_reg, freq_end_reg, freq_step_reg;
    
    // 参数锁存
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            vdd_start_reg <= 8'd70;   // 默认0.7V
            vdd_end_reg <= 8'd120;    // 默认1.2V
            vdd_step_reg <= 8'd5;     // 默认50mV步进
            freq_start_reg <= 10'd100; // 默认100MHz
            freq_end_reg <= 10'd1000;  // 默认1GHz
            freq_step_reg <= 10'd50;   // 默认50MHz步进
        end else if (state == IDLE && shmoo_start) begin
            vdd_start_reg <= vdd_start;
            vdd_end_reg <= vdd_end;
            vdd_step_reg <= vdd_step;
            freq_start_reg <= freq_start;
            freq_end_reg <= freq_end;
            freq_step_reg <= freq_step;
        end
    end
    
    // 状态机 - 时序逻辑
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            current_vdd <= 8'd0;
            current_freq <= 10'd0;
            settle_cnt <= 16'd0;
            retry_cnt <= 4'd0;
            test_count <= 32'd0;
            pass_count <= 32'd0;
        end else begin
            state <= next_state;
            current_vdd <= next_vdd;
            current_freq <= next_freq;
            
            // 稳定计数器
            if (state == SET_VDD || state == SET_FREQ) begin
                settle_cnt <= 16'hFFFF;
            end else if (settle_cnt > 0) begin
                settle_cnt <= settle_cnt - 1;
            end
            
            // 重试计数器
            if (state == RUN_TEST && test_error) begin
                retry_cnt <= retry_cnt + 1;
            end else if (state == IDLE) begin
                retry_cnt <= 4'd0;
            end
        end
    end
    
    // 状态机 - 组合逻辑（完全打拍子）
    always @(*) begin
        next_state = state;
        next_vdd = current_vdd;
        next_freq = current_freq;
        
        case (state)
            IDLE: begin
                if (shmoo_start) begin
                    next_state = SET_VDD;
                    next_vdd = vdd_start_reg;
                    next_freq = freq_start_reg;
                end
            end
            
            SET_VDD: begin
                next_state = WAIT_VDD;
            end
            
            WAIT_VDD: begin
                if (settle_cnt == 0) begin
                    next_state = SET_FREQ;
                end
            end
            
            SET_FREQ: begin
                next_state = WAIT_PLL;
            end
            
            WAIT_PLL: begin
                if (settle_cnt == 0) begin
                    next_state = RUN_TEST;
                end
            end
            
            RUN_TEST: begin
                if (test_done || retry_cnt > 4'd3) begin
                    next_state = STORE_RESULT;
                end
            end
            
            STORE_RESULT: begin
                next_state = NEXT_POINT;
            end
            
            NEXT_POINT: begin
                if (current_freq + freq_step_reg <= freq_end_reg) begin
                    next_freq = current_freq + freq_step_reg;
                    next_state = SET_FREQ;
                end else if (current_vdd + vdd_step_reg <= vdd_end_reg) begin
                    next_vdd = current_vdd + vdd_step_reg;
                    next_freq = freq_start_reg;
                    next_state = SET_VDD;
                end else begin
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    // 输出逻辑 - 全部寄存器化
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            vdd_ctrl <= 8'd0;
            freq_ctrl <= 10'd0;
            pll_reconfig <= 1'b0;
            vdd_stable <= 1'b0;
            pll_locked <= 1'b0;
            test_trigger <= 1'b0;
            result_wen <= 1'b0;
            result_addr <= 18'd0;
            result_data <= 2'b00;
            shmoo_done <= 1'b0;
            current_state <= 3'd0;
            test_in_progress <= 1'b0;
            result_pending <= 1'b0;
        end else begin
            // 默认值
            pll_reconfig <= 1'b0;
            test_trigger <= 1'b0;
            result_wen <= 1'b0;
            shmoo_done <= 1'b0;
            
            // 状态输出
            current_state <= state;
            
            case (state)
                SET_VDD: begin
                    vdd_ctrl <= current_vdd;
                    vdd_stable <= 1'b0;
                end
                
                WAIT_VDD: begin
                    vdd_stable <= (settle_cnt < 16'd256);
                end
                
                SET_FREQ: begin
                    freq_ctrl <= current_freq;
                    pll_reconfig <= 1'b1;
                    pll_locked <= 1'b0;
                end
                
                WAIT_PLL: begin
                    pll_locked <= (settle_cnt < 16'd256);
                end
                
                RUN_TEST: begin
                    if (!test_in_progress && !test_done) begin
                        test_trigger <= 1'b1;
                        test_in_progress <= 1'b1;
                    end else if (test_done) begin
                        test_in_progress <= 1'b0;
                        result_pending <= 1'b1;
                    end
                end
                
                STORE_RESULT: begin
                    if (result_pending) begin
                        result_wen <= 1'b1;
                        result_addr <= {current_vdd, current_freq};
                        
                        // 结果编码
                        if (retry_cnt > 4'd3) begin
                            result_data <= 2'b10; // Error
                        end else if (test_pass) begin
                            result_data <= 2'b01; // Pass
                            pass_count <= pass_count + 1;
                        end else begin
                            result_data <= 2'b00; // Fail
                        end
                        
                        test_count <= test_count + 1;
                        result_pending <= 1'b0;
                    end
                end
                
                IDLE: begin
                    if (test_count > 0 && !shmoo_start) begin
                        shmoo_done <= 1'b1;
                    end
                end
            endcase
        end
    end

endmodule
            </div>
            
            <div class="code-block">
// Chisel版本对比：
import chisel3._
import chisel3.util._

class ShmooTestController extends Module {
  val io = IO(new Bundle {
    // 测试控制
    val shmoo_start = Input(Bool())
    val vdd_start = Input(UInt(8.W))
    val vdd_end = Input(UInt(8.W))
    val vdd_step = Input(UInt(8.W))
    val freq_start = Input(UInt(10.W))
    val freq_end = Input(UInt(10.W))
    val freq_step = Input(UInt(10.W))
    
    // 电源和时钟控制
    val vdd_ctrl = Output(UInt(8.W))
    val freq_ctrl = Output(UInt(10.W))
    val pll_reconfig = Output(Bool())
    val vdd_stable = Output(Bool())
    val pll_locked = Output(Bool())
    
    // 测试执行
    val test_trigger = Output(Bool())
    val test_done = Input(Bool())
    val test_pass = Input(Bool())
    val test_error = Input(Bool())
    
    // 结果存储
    val result_wen = Output(Bool())
    val result_addr = Output(UInt(18.W))
    val result_data = Output(UInt(2.W))
    
    // 状态输出
    val shmoo_done = Output(Bool())
    val current_state = Output(UInt(3.W))
    val test_count = Output(UInt(32.W))
    val pass_count = Output(UInt(32.W))
  })
  
  // 状态机定义
  val idle :: setVdd :: waitVdd :: setFreq :: waitPll :: runTest :: storeResult :: nextPoint :: Nil = Enum(8)
  
  val state = RegInit(idle)
  val currentVdd = RegInit(0.U(8.W))
  val currentFreq = RegInit(0.U(10.W))
  val settleCnt = RegInit(0.U(16.W))
  val retryCnt = RegInit(0.U(4.W))
  val testCount = RegInit(0.U(32.W))
  val passCount = RegInit(0.U(32.W))
  
  // 配置参数寄存器
  val vddStartReg = RegInit(70.U(8.W))
  val vddEndReg = RegInit(120.U(8.W))
  val vddStepReg = RegInit(5.U(8.W))
  val freqStartReg = RegInit(100.U(10.W))
  val freqEndReg = RegInit(1000.U(10.W))
  val freqStepReg = RegInit(50.U(10.W))
  
  // 参数锁存
  when(state === idle && io.shmoo_start) {
    vddStartReg := io.vdd_start
    vddEndReg := io.vdd_end
    vddStepReg := io.vdd_step
    freqStartReg := io.freq_start
    freqEndReg := io.freq_end
    freqStepReg := io.freq_step
  }
  
  // 稳定计数器
  when(state === setVdd || state === setFreq) {
    settleCnt := "hFFFF".U
  }.elsewhen(settleCnt > 0.U) {
    settleCnt := settleCnt - 1.U
  }
  
  // 状态机
  switch(state) {
    is(idle) {
      when(io.shmoo_start) {
        state := setVdd
        currentVdd := vddStartReg
        currentFreq := freqStartReg
      }
    }
    is(setVdd) {
      state := waitVdd
    }
    is(waitVdd) {
      when(settleCnt === 0.U) {
        state := setFreq
      }
    }
    is(setFreq) {
      state := waitPll
    }
    is(waitPll) {
      when(settleCnt === 0.U) {
        state := runTest
      }
    }
    is(runTest) {
      when(io.test_done || retryCnt > 3.U) {
        state := storeResult
      }
    }
    is(storeResult) {
      state := nextPoint
      testCount := testCount + 1.U
      when(!io.test_error && io.test_pass) {
        passCount := passCount + 1.U
      }
    }
    is(nextPoint) {
      when(currentFreq + freqStepReg <= freqEndReg) {
        currentFreq := currentFreq + freqStepReg
        state := setFreq
      }.elsewhen(currentVdd + vddStepReg <= vddEndReg) {
        currentVdd := currentVdd + vddStepReg
        currentFreq := freqStartReg
        state := setVdd
      }.otherwise {
        state := idle
      }
    }
  }
  
  // 输出逻辑
  io.vdd_ctrl := RegNext(Mux(state === setVdd, currentVdd, io.vdd_ctrl))
  io.freq_ctrl := RegNext(Mux(state === setFreq, currentFreq, io.freq_ctrl))
  io.pll_reconfig := RegNext(state === setFreq)
  io.vdd_stable := RegNext(state === waitVdd && settleCnt < 256.U)
  io.pll_locked := RegNext(state === waitPll && settleCnt < 256.U)
  
  val testInProgress = RegInit(false.B)
  io.test_trigger := RegNext(state === runTest && !testInProgress && !io.test_done)
  when(io.test_trigger) {
    testInProgress := true.B
  }.elsewhen(io.test_done) {
    testInProgress := false.B
  }
  
  // 结果存储
  io.result_wen := RegNext(state === storeResult)
  io.result_addr := RegNext(Cat(currentVdd, currentFreq))
  io.result_data := RegNext(MuxCase(0.U, Seq(
    (retryCnt > 3.U) -> 2.U,  // Error
    io.test_pass -> 1.U,       // Pass
    true.B -> 0.U              // Fail
  )))
  
  // 状态输出
  io.shmoo_done := RegNext(state === idle && testCount > 0.U && !io.shmoo_start)
  io.current_state := state
  io.test_count := testCount
  io.pass_count := passCount
}
            </div>

            <h3>7.6 测试向量生成</h3>
            
            <p>测试向量生成是NPU验证的关键环节，它决定了我们能够覆盖多少实际场景。传统的随机测试向量在NPU验证中往往效果有限，因为真实的神经网络数据具有特定的统计特性和结构。这就像是测试一个语音识别系统——随机噪声并不能有效地测试其性能，我们需要真实的语音数据。</p>
            
            <p>现代NPU测试向量生成面临着“维度爆炸”的挑战。一个简单的卷积层就有多个参数：输入大小、卷积核大小、步长、填充、通道数、数据精度等。这些参数的组合可能达到数十亿种。Apple的验证团队分享过一个数据：他们为Neural Engine生成了超过1000万个测试向量，总数据量超过100TB。这种规模的测试需要高度自动化的生成和管理系统。</p>
            
            <p>更具挑战性的是，NPU的测试向量不仅要覆盖功能正确性，还要考虑数值精度。由于量化和近似计算，NPU的输出可能与理论值存在微小差异。如何判断这些差异是否可接受？这需要结合应用场景和算法特性进行判断。一个典型的做法是设置不同的误差阈值：对于分类任务，可能允许1-2%的误差；但对于医疗影像处理，可能需要更严格的精度要求。</p>
            
            <h4>7.6.1 基于模型的向量生成</h4>
            <p>基于模型的测试向量生成是现代NPU验证的主流方法。它直接使用真实的神经网络模型作为测试源，确保测试向量具有实际意义。这种方法的优势是明显的：它能够捕捉到真实应用中的复杂模式，而这些模式很难通过人工构造来复现。</p>
            <div class="code-block">
// Python脚本：从神经网络模型生成测试向量
"""
npu_test_vector_generator.py
从PyTorch/TensorFlow模型生成NPU测试向量
"""

import numpy as np
import torch
import struct

class NPUTestVectorGenerator:
    def __init__(self, model, quantization_bits=8):
        self.model = model
        self.quant_bits = quantization_bits
        self.test_vectors = []
        
    def quantize(self, tensor, scale, zero_point):
        """量化浮点张量到定点"""
        q_min = -(2**(self.quant_bits-1))
        q_max = 2**(self.quant_bits-1) - 1
        
        q_tensor = np.round(tensor / scale + zero_point)
        q_tensor = np.clip(q_tensor, q_min, q_max)
        return q_tensor.astype(np.int8)
    
    def generate_conv_test(self, layer_name, input_shape):
        """生成卷积层测试向量"""
        # 创建测试输入
        test_input = torch.randn(input_shape)
        
        # 获取层参数
        conv_layer = getattr(self.model, layer_name)
        weight = conv_layer.weight.detach().numpy()
        bias = conv_layer.bias.detach().numpy() if conv_layer.bias is not None else None
        
        # 执行前向传播获取golden输出
        with torch.no_grad():
            golden_output = conv_layer(test_input).numpy()
        
        # 量化参数计算
        input_scale = np.max(np.abs(test_input.numpy())) / 127
        weight_scale = np.max(np.abs(weight)) / 127
        output_scale = input_scale * weight_scale
        
        # 量化
        q_input = self.quantize(test_input.numpy(), input_scale, 0)
        q_weight = self.quantize(weight, weight_scale, 0)
        q_output = self.quantize(golden_output, output_scale, 0)
        
        # 生成测试向量
        test_vector = {
            'layer': layer_name,
            'operation': 'conv2d',
            'input_shape': input_shape,
            'kernel_size': conv_layer.kernel_size,
            'stride': conv_layer.stride,
            'padding': conv_layer.padding,
            'input_data': q_input.flatten().tolist(),
            'weight_data': q_weight.flatten().tolist(),
            'bias_data': bias.tolist() if bias is not None else None,
            'expected_output': q_output.flatten().tolist(),
            'scales': {
                'input': input_scale,
                'weight': weight_scale,
                'output': output_scale
            }
        }
        
        self.test_vectors.append(test_vector)
        return test_vector
    
    def generate_corner_cases(self):
        """生成边界测试用例"""
        corner_cases = []
        
        # 全零输入
        zero_input = np.zeros((1, 3, 224, 224), dtype=np.int8)
        corner_cases.append({
            'name': 'all_zeros',
            'input': zero_input,
            'expected_behavior': 'zero_output'
        })
        
        # 最大值输入
        max_input = np.full((1, 3, 224, 224), 127, dtype=np.int8)
        corner_cases.append({
            'name': 'max_values',
            'input': max_input,
            'expected_behavior': 'saturation_check'
        })
        
        # 稀疏输入（90%零值）
        sparse_input = np.random.choice([0, 1], size=(1, 3, 224, 224), p=[0.9, 0.1])
        sparse_input = sparse_input.astype(np.int8) * 127
        corner_cases.append({
            'name': 'sparse_input',
            'input': sparse_input,
            'expected_behavior': 'sparse_optimization'
        })
        
        return corner_cases
    
    def export_to_npu_format(self, filename):
        """导出为NPU可读的二进制格式"""
        with open(filename, 'wb') as f:
            # 文件头
            f.write(struct.pack('I', 0x4E505554))  # 'NPUT' magic
            f.write(struct.pack('I', len(self.test_vectors)))
            
            for vector in self.test_vectors:
                # 向量头
                layer_name = vector['layer'].encode('utf-8')
                f.write(struct.pack('I', len(layer_name)))
                f.write(layer_name)
                
                # 操作类型
                op_type = vector['operation'].encode('utf-8')
                f.write(struct.pack('I', len(op_type)))
                f.write(op_type)
                
                # 数据
                input_data = vector['input_data']
                f.write(struct.pack('I', len(input_data)))
                for val in input_data:
                    f.write(struct.pack('b', val))
                
                # 权重
                weight_data = vector['weight_data']
                f.write(struct.pack('I', len(weight_data)))
                for val in weight_data:
                    f.write(struct.pack('b', val))
                
                # 期望输出
                output_data = vector['expected_output']
                f.write(struct.pack('I', len(output_data)))
                for val in output_data:
                    f.write(struct.pack('b', val))

# 使用示例
if __name__ == "__main__":
    # 加载模型
    model = torch.load('mobilenet_v2.pth')
    model.eval()
    
    # 创建测试向量生成器
    generator = NPUTestVectorGenerator(model)
    
    # 生成各层测试向量
    generator.generate_conv_test('features.0.0', (1, 3, 224, 224))
    generator.generate_conv_test('features.1.conv.0', (1, 32, 112, 112))
    
    # 生成边界测试
    corner_cases = generator.generate_corner_cases()
    
    # 导出测试向量
    generator.export_to_npu_format('npu_test_vectors.bin')
            </div>

            <h4>7.6.2 测试向量验证框架</h4>
            <div class="code-block">
// SystemVerilog测试向量加载和验证框架
class test_vector_loader extends uvm_component;
    `uvm_component_utils(test_vector_loader)
    
    // 测试向量数据结构
    typedef struct {
        string layer_name;
        string operation;
        int input_size;
        int weight_size;
        int output_size;
        byte input_data[];
        byte weight_data[];
        byte expected_output[];
        real input_scale;
        real weight_scale;
        real output_scale;
    } test_vector_t;
    
    test_vector_t test_vectors[$];
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    // 从文件加载测试向量
    function void load_vectors(string filename);
        int fd;
        bit [31:0] magic, num_vectors;
        
        fd = $fopen(filename, "rb");
        if (fd == 0) begin
            `uvm_fatal("LOADER", $sformatf("Cannot open file %s", filename))
        end
        
        // 读取文件头
        $fread(magic, fd);
        if (magic != 32'h4E505554) begin  // 'NPUT'
            `uvm_fatal("LOADER", "Invalid file format")
        end
        
        $fread(num_vectors, fd);
        `uvm_info("LOADER", $sformatf("Loading %0d test vectors", num_vectors), UVM_LOW)
        
        // 读取每个测试向量
        for (int i = 0; i < num_vectors; i++) begin
            test_vector_t vec;
            int name_len, op_len;
            
            // 读取层名称
            $fread(name_len, fd);
            vec.layer_name = "";
            for (int j = 0; j < name_len; j++) begin
                byte ch;
                $fread(ch, fd);
                vec.layer_name = {vec.layer_name, ch};
            end
            
            // 读取操作类型
            $fread(op_len, fd);
            vec.operation = "";
            for (int j = 0; j < op_len; j++) begin
                byte ch;
                $fread(ch, fd);
                vec.operation = {vec.operation, ch};
            end
            
            // 读取数据
            $fread(vec.input_size, fd);
            vec.input_data = new[vec.input_size];
            for (int j = 0; j < vec.input_size; j++) begin
                $fread(vec.input_data[j], fd);
            end
            
            $fread(vec.weight_size, fd);
            vec.weight_data = new[vec.weight_size];
            for (int j = 0; j < vec.weight_size; j++) begin
                $fread(vec.weight_data[j], fd);
            end
            
            $fread(vec.output_size, fd);
            vec.expected_output = new[vec.output_size];
            for (int j = 0; j < vec.output_size; j++) begin
                $fread(vec.expected_output[j], fd);
            end
            
            test_vectors.push_back(vec);
        end
        
        $fclose(fd);
    endfunction
    
    // 获取下一个测试向量
    function test_vector_t get_next_vector();
        if (test_vectors.size() > 0) begin
            return test_vectors.pop_front();
        end else begin
            `uvm_warning("LOADER", "No more test vectors")
            return null;
        end
    endfunction
    
endclass

// 测试执行序列
class npu_test_vector_sequence extends uvm_sequence;
    `uvm_object_utils(npu_test_vector_sequence)
    
    test_vector_loader loader;
    
    function new(string name = "npu_test_vector_sequence");
        super.new(name);
    endfunction
    
    task body();
        test_vector_loader::test_vector_t vec;
        npu_layer_config_seq config_seq;
        npu_data_load_seq data_seq;
        npu_compute_seq compute_seq;
        npu_result_check_seq check_seq;
        
        // 加载测试向量
        loader = test_vector_loader::type_id::create("loader");
        loader.load_vectors("npu_test_vectors.bin");
        
        // 执行每个测试向量
        while (1) begin
            vec = loader.get_next_vector();
            if (vec == null) break;
            
            `uvm_info("TEST", $sformatf("Testing layer: %s", vec.layer_name), UVM_LOW)
            
            // 配置NPU层参数
            config_seq = npu_layer_config_seq::type_id::create("config_seq");
            config_seq.layer_name = vec.layer_name;
            config_seq.operation = vec.operation;
            config_seq.start(m_sequencer);
            
            // 加载输入数据和权重
            data_seq = npu_data_load_seq::type_id::create("data_seq");
            data_seq.input_data = vec.input_data;
            data_seq.weight_data = vec.weight_data;
            data_seq.start(m_sequencer);
            
            // 执行计算
            compute_seq = npu_compute_seq::type_id::create("compute_seq");
            compute_seq.start(m_sequencer);
            
            // 检查结果
            check_seq = npu_result_check_seq::type_id::create("check_seq");
            check_seq.expected_output = vec.expected_output;
            check_seq.tolerance = 1;  // INT8量化容差
            check_seq.start(m_sequencer);
        end
    endtask
    
endclass
            </div>

            <div class="exercise">
                <h4>练习 7.4-7.6</h4>
                <div class="question">
                    <p><strong>题目：</strong>设计一个完整的MBIST控制器用于测试NPU中的SRAM，要求：
                    1) 支持March C-和Checkerboard算法
                    2) 支持多个SRAM并行测试
                    3) 实现故障诊断和修复
                    4) 提供测试结果统计</p>
                    <details class="hint">
                        <summary>💡 提示</summary>
                        <p>思考方向：March算法是顺序访问模式，Checkerboard是棋盘图案。并行测试需要考虑功耗限制。故障诊断需要记录失败地址和数据。修复可以使用冗余行/列替换。状态机设计要清晰。</p>
                    </details>
                    <button class="toggle-answer">显示答案</button>
                    <div class="answer">
                        <div class="code-block">
module npu_mbist_top #(
    parameter NUM_SRAMS = 4,
    parameter ADDR_WIDTH = 10,
    parameter DATA_WIDTH = 32,
    parameter REPAIR_WIDTH = 4  // 修复行数
)(
    input wire clk,
    input wire rst_n,
    
    // MBIST控制
    input wire mbist_en,
    input wire [1:0] mbist_mode,  // 00: March C-, 01: Checkerboard, 10: Walking 1/0
    input wire repair_en,
    
    // SRAM接口（简化）
    output wire [NUM_SRAMS-1:0] sram_en,
    output wire [NUM_SRAMS-1:0] sram_we,
    output wire [ADDR_WIDTH-1:0] sram_addr [NUM_SRAMS-1:0],
    output wire [DATA_WIDTH-1:0] sram_wdata [NUM_SRAMS-1:0],
    input wire [DATA_WIDTH-1:0] sram_rdata [NUM_SRAMS-1:0],
    
    // 测试结果
    output reg mbist_done,
    output reg [NUM_SRAMS-1:0] mbist_fail,
    output reg [31:0] total_faults,
    output reg [31:0] repaired_faults,
    
    // 诊断接口
    output reg diag_valid,
    output reg [7:0] diag_sram_id,
    output reg [ADDR_WIDTH-1:0] diag_addr,
    output reg [DATA_WIDTH-1:0] diag_expected,
    output reg [DATA_WIDTH-1:0] diag_actual
);

    // MBIST FSM状态
    localparam IDLE = 4'h0;
    localparam INIT = 4'h1;
    localparam MARCH_W0 = 4'h2;
    localparam MARCH_R0W1_UP = 4'h3;
    localparam MARCH_R1W0_UP = 4'h4;
    localparam MARCH_R0W1_DN = 4'h5;
    localparam MARCH_R1W0_DN = 4'h6;
    localparam MARCH_R0 = 4'h7;
    localparam CHECKER_W0 = 4'h8;
    localparam CHECKER_W1 = 4'h9;
    localparam CHECKER_R = 4'hA;
    localparam DIAGNOSE = 4'hB;
    localparam REPAIR = 4'hC;
    localparam DONE = 4'hD;
    
    reg [3:0] state, next_state;
    reg [ADDR_WIDTH-1:0] addr_cnt;
    reg addr_dir;  // 0: up, 1: down
    reg [1:0] phase;
    
    // 每个SRAM的独立控制
    reg [NUM_SRAMS-1:0] sram_fail_flag;
    reg [ADDR_WIDTH-1:0] fail_addr [NUM_SRAMS-1:0];
    reg [DATA_WIDTH-1:0] fail_data [NUM_SRAMS-1:0];
    
    // 修复信息
    reg [ADDR_WIDTH-1:0] repair_rows [NUM_SRAMS-1:0][REPAIR_WIDTH-1:0];
    reg [REPAIR_WIDTH-1:0] repair_used [NUM_SRAMS-1:0];
    
    // 生成期望数据
    function [DATA_WIDTH-1:0] generate_pattern;
        input [1:0] mode;
        input [ADDR_WIDTH-1:0] addr;
        input [1:0] phase;
        
        case (mode)
            2'b00: begin  // March C-
                case (phase)
                    2'b00: generate_pattern = {DATA_WIDTH{1'b0}};
                    2'b01: generate_pattern = {DATA_WIDTH{1'b1}};
                    default: generate_pattern = {DATA_WIDTH{1'b0}};
                endcase
            end
            
            2'b01: begin  // Checkerboard
                generate_pattern = {DATA_WIDTH/2{addr[0] ? 2'b10 : 2'b01}};
            end
            
            2'b10: begin  // Walking 1/0
                generate_pattern = phase[0] ? (1 << (addr % DATA_WIDTH)) : 
                                             ~(1 << (addr % DATA_WIDTH));
            end
            
            default: generate_pattern = {DATA_WIDTH{1'b0}};
        endcase
    endfunction
    
    // 主状态机
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            mbist_done <= 1'b0;
            total_faults <= 0;
        end else begin
            state <= next_state;
        end
    end
    
    // 下一状态逻辑
    always @(*) begin
        next_state = state;
        
        case (state)
            IDLE: begin
                if (mbist_en) begin
                    case (mbist_mode)
                        2'b00: next_state = MARCH_W0;
                        2'b01: next_state = CHECKER_W0;
                        2'b10: next_state = INIT;
                    endcase
                end
            end
            
            MARCH_W0: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}})
                    next_state = MARCH_R0W1_UP;
            end
            
            MARCH_R0W1_UP: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}} && phase == 2'b01)
                    next_state = MARCH_R1W0_UP;
            end
            
            MARCH_R1W0_UP: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}} && phase == 2'b01)
                    next_state = MARCH_R0W1_DN;
            end
            
            MARCH_R0W1_DN: begin
                if (addr_cnt == 0 && phase == 2'b01)
                    next_state = MARCH_R1W0_DN;
            end
            
            MARCH_R1W0_DN: begin
                if (addr_cnt == 0 && phase == 2'b01)
                    next_state = MARCH_R0;
            end
            
            MARCH_R0: begin
                if (addr_cnt == {ADDR_WIDTH{1'b1}})
                    next_state = repair_en ? DIAGNOSE : DONE;
            end
            
            DIAGNOSE: begin
                if (total_faults == 0)
                    next_state = DONE;
                else
                    next_state = REPAIR;
            end
            
            REPAIR: begin
                next_state = DONE;
            end
            
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end
    
    // 地址生成和SRAM控制
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            addr_cnt <= 0;
            phase <= 0;
            for (int i = 0; i < NUM_SRAMS; i++) begin
                sram_fail_flag[i] <= 1'b0;
                repair_used[i] <= 0;
            end
        end else begin
            case (state)
                MARCH_W0: begin
                    // 所有SRAM并行写0
                    for (int i = 0; i < NUM_SRAMS; i++) begin
                        sram_en[i] <= 1'b1;
                        sram_we[i] <= 1'b1;
                        sram_addr[i] <= addr_cnt;
                        sram_wdata[i] <= {DATA_WIDTH{1'b0}};
                    end
                    addr_cnt <= addr_cnt + 1;
                end
                
                MARCH_R0W1_UP: begin
                    for (int i = 0; i < NUM_SRAMS; i++) begin
                        sram_en[i] <= 1'b1;
                        if (phase == 0) begin  // 读阶段
                            sram_we[i] <= 1'b0;
                            // 检查读出数据
                            if (sram_rdata[i] !== {DATA_WIDTH{1'b0}}) begin
                                sram_fail_flag[i] <= 1'b1;
                                fail_addr[i] <= addr_cnt;
                                fail_data[i] <= sram_rdata[i];
                                total_faults <= total_faults + 1;
                            end
                        end else begin  // 写阶段
                            sram_we[i] <= 1'b1;
                            sram_wdata[i] <= {DATA_WIDTH{1'b1}};
                        end
                        sram_addr[i] <= addr_cnt;
                    end
                    
                    if (phase == 1) begin
                        addr_cnt <= addr_cnt + 1;
                        phase <= 0;
                    end else begin
                        phase <= 1;
                    end
                end
                
                // 类似处理其他状态...
                
                DIAGNOSE: begin
                    // 输出诊断信息
                    for (int i = 0; i < NUM_SRAMS; i++) begin
                        if (sram_fail_flag[i]) begin
                            diag_valid <= 1'b1;
                            diag_sram_id <= i;
                            diag_addr <= fail_addr[i];
                            diag_expected <= {DATA_WIDTH{1'b0}};  // 根据状态确定
                            diag_actual <= fail_data[i];
                            break;
                        end
                    end
                end
                
                REPAIR: begin
                    // 简单的行修复策略
                    for (int i = 0; i < NUM_SRAMS; i++) begin
                        if (sram_fail_flag[i] && repair_used[i] < REPAIR_WIDTH) begin
                            repair_rows[i][repair_used[i]] <= fail_addr[i];
                            repair_used[i] <= repair_used[i] + 1;
                            repaired_faults <= repaired_faults + 1;
                            sram_fail_flag[i] <= 1'b0;
                        end
                    end
                end
                
                DONE: begin
                    mbist_done <= 1'b1;
                    mbist_fail <= sram_fail_flag;
                    diag_valid <= 1'b0;
                end
            endcase
        end
    end
    
    // 地址重映射（修复后）
    function [ADDR_WIDTH-1:0] remap_address;
        input [7:0] sram_id;
        input [ADDR_WIDTH-1:0] addr;
        
        remap_address = addr;
        
        // 检查是否需要重映射
        for (int i = 0; i < REPAIR_WIDTH; i++) begin
            if (repair_used[sram_id] > i && 
                repair_rows[sram_id][i] == addr) begin
                // 重映射到备用行
                remap_address = {ADDR_WIDTH{1'b1}} - i;
                break;
            end
        end
    endfunction

endmodule
                        </div>
                    </div>
                </div>
            </div>
        </section>
        </div>
        
        <div class="chapter-nav">
            <a href="chapter6.html" class="prev">上一章</a>
            <a href="chapter8.html" class="next">下一章</a>
        </div>
    </div>
</body>
</html>