<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¬¬6ç« ï¼šRTLè®¾è®¡å®ç° - NPUè®¾è®¡æ•™ç¨‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .nav-bar {
            background: #34495e;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .nav-bar ul {
            list-style: none;
            display: flex;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0;
        }

        .nav-bar li {
            margin: 0 15px;
        }

        .nav-bar a {
            color: white;
            text-decoration: none;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .nav-bar a:hover {
            background: #2c3e50;
        }

        .nav-bar .current {
            background: #2c3e50;
            font-weight: bold;
        }

        .chapter {
            background: white;
            margin: 20px 0;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .chapter h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
        }

        .chapter h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        .chapter h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
        }
        
        /* Language label */
        .code-block::before {
            content: attr(data-language);
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 12px;
            color: #95a5a6;
            text-transform: uppercase;
        }
        
        /* Syntax highlighting classes */
        .code-block .keyword { color: #e74c3c; font-weight: bold; }
        .code-block .type { color: #3498db; }
        .code-block .comment { color: #95a5a6; font-style: italic; }
        .code-block .number { color: #e67e22; }
        .code-block .string { color: #2ecc71; }
        .code-block .function { color: #3498db; }

        .exercise {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 5px solid #3498db;
        }

        .exercise h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .question {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .answer {
            margin-top: 10px;
            padding: 15px;
            background: #e8f5e9;
            border-radius: 5px;
            display: none;
            border-left: 4px solid #4caf50;
        }

        .answer.show {
            display: block;
        }
        
        .hint {
            margin: 10px 0;
            padding: 10px 15px;
            background: #fff8dc;
            border-left: 4px solid #ffa500;
            border-radius: 5px;
            font-size: 0.95em;
        }
        
        .hint summary {
            cursor: pointer;
            font-weight: bold;
            color: #ff8c00;
            outline: none;
        }
        
        .hint summary:hover {
            color: #ff6347;
        }
        
        .hint p {
            margin-top: 10px;
            color: #666;
        }

        .toggle-answer {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
            transition: background 0.3s;
        }

        .toggle-answer:hover {
            background: #2980b9;
        }

        .table-wrapper {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: bold;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 5px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .chapter-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #ecf0f1;
        }

        .chapter-nav a {
            background: #3498db;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .chapter-nav a:hover {
            background: #2980b9;
        }

        .chapter-nav .prev::before {
            content: "â† ";
        }

        .chapter-nav .next::after {
            content: " â†’";
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            header {
                padding: 20px 10px;
            }
            
            header h1 {
                font-size: 1.5em;
            }
            
            .chapter {
                padding: 15px;
                margin: 10px 0;
            }
            
            .chapter h2 {
                font-size: 1.5em;
            }
            
            .chapter h3 {
                font-size: 1.2em;
            }
            
            .nav-bar ul {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .nav-bar li {
                margin: 5px;
            }
            
            .code-block {
                padding: 10px;
                font-size: 12px;
            }
            
            table {
                font-size: 14px;
            }
            
            th, td {
                padding: 8px;
            }
        }

        /* List styles for proper indentation */
        .chapter ul, .chapter ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .chapter li {
            margin-bottom: 8px;
            line-height: 1.8;
        }
        
        .chapter ul ul, .chapter ol ol, .chapter ul ol, .chapter ol ul {
            margin-left: 20px;
            margin-top: 5px;
        }
        
        .info-box ul, .warning-box ul, .answer ul {
            margin-left: 20px;
        }
        
        .info-box li, .warning-box li, .answer li {
            margin-bottom: 10px;
        }
        
        /* Keep nav-bar lists unstyled */
        .nav-bar ul {
            margin-left: 0;
        }
        
        .nav-bar li {
            margin-bottom: 0;
        }
    </style>
    <script>
        // Syntax highlighting functions
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        function highlightSyntax() {
            const codeBlocks = document.querySelectorAll('.code-block');
            
            codeBlocks.forEach(block => {
                const content = block.textContent;
                let language = 'text';
                let highlighted = content;
                
                // Auto-detect language based on content
                if (content.includes('module ') || content.includes('always @') || content.includes('wire ') || content.includes('reg ')) {
                    language = 'verilog';
                    highlighted = highlightVerilog(content);
                } else if (content.includes('import ') || content.includes('def ') || content.includes('class ')) {
                    language = 'python';
                    highlighted = highlightPython(content);
                }
                
                block.innerHTML = highlighted;
                block.classList.add(language);
                block.setAttribute('data-language', language);
            });
        }
        
        function highlightVerilog(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments with placeholders
            code = code.replace(/(\/\/.*$|\/\*[\s\S]*?\*\/)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings with placeholders
            code = code.replace(/("[^"]*")/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(module|endmodule|input|output|wire|reg|always|assign|begin|end|if|else|for|while|parameter|posedge|negedge)\b/g;
            const types = /\b(bit|logic|byte|shortint|int|longint|integer|time|real)\b/g;
            const numbers = /\b(\d+'[hbdo][\da-fA-F_]+|\d+)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(types, '<span class="type">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        function highlightPython(code) {
            const placeholders = [];
            let placeholderIndex = 0;
            
            // Replace comments
            code = code.replace(/(#.*$)/gm, (match) => {
                const placeholder = `__COMMENT_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="comment">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Replace strings
            code = code.replace(/("[^"]*"|'[^']*')/g, (match) => {
                const placeholder = `__STRING_${placeholderIndex}__`;
                placeholders[placeholderIndex] = `<span class="string">${escapeHtml(match)}</span>`;
                placeholderIndex++;
                return placeholder;
            });
            
            // Apply highlights
            const keywords = /\b(and|as|assert|break|class|continue|def|del|elif|else|except|False|finally|for|from|global|if|import|in|is|lambda|None|not|or|pass|raise|return|True|try|while|with|yield)\b/g;
            const builtins = /\b(abs|all|any|bin|bool|dict|float|format|hex|input|int|len|list|map|max|min|open|print|range|round|set|sorted|str|sum|tuple|type|zip)\b/g;
            const numbers = /\b(\d+\.?\d*)\b/g;
            
            code = code.replace(keywords, '<span class="keyword">$1</span>');
            code = code.replace(builtins, '<span class="function">$1</span>');
            code = code.replace(numbers, '<span class="number">$1</span>');
            
            // Restore placeholders
            for (let i = 0; i < placeholderIndex; i++) {
                code = code.replace(new RegExp(`__COMMENT_${i}__`, 'g'), placeholders[i]);
                code = code.replace(new RegExp(`__STRING_${i}__`, 'g'), placeholders[i]);
            }
            
            return code;
        }
        
        // Toggle answer visibility
        document.addEventListener('DOMContentLoaded', function() {
            highlightSyntax();
            
            const toggleButtons = document.querySelectorAll('.toggle-answer');
            toggleButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const answer = this.nextElementSibling;
                    answer.classList.toggle('show');
                    this.textContent = answer.classList.contains('show') ? 'éšè—ç­”æ¡ˆ' : 'æ˜¾ç¤ºç­”æ¡ˆ';
                });
            });
        });
    </script>
</head>
<body>
    <header>
        <h1>ç¬¬6ç« ï¼šRTLè®¾è®¡å®ç°</h1>
    </header>
    
    <nav class="nav-bar">
        <ul>
            <li><a href="index.html">é¦–é¡µ</a></li>
            <li><a href="chapter1.html">ç¬¬1ç« </a></li>
            <li><a href="chapter2.html">ç¬¬2ç« </a></li>
            <li><a href="chapter3.html">ç¬¬3ç« </a></li>
            <li><a href="chapter4.html">ç¬¬4ç« </a></li>
            <li><a href="chapter5.html">ç¬¬5ç« </a></li>
            <li><a href="chapter6.html" class="current">ç¬¬6ç« </a></li>
            <li><a href="chapter7.html">ç¬¬7ç« </a></li>
            <li><a href="chapter8.html">ç¬¬8ç« </a></li>
            <li><a href="chapter9.html">ç¬¬9ç« </a></li>
            <li><a href="chapter10.html">ç¬¬10ç« </a></li>
            <li><a href="chapter11.html">ç¬¬11ç« </a></li>
            <li><a href="chapter12.html">ç¬¬12ç« </a></li>
        </ul>
    </nav>
    
    <div class="container">
        <div class="chapter">
            <h2>ç¬¬6ç« ï¼šRTLè®¾è®¡å®ç°</h2>
            
            <p>æœ¬ç« è¯¦ç»†ä»‹ç»NPUä»æ¶æ„è®¾è®¡åˆ°RTLå®ç°çš„å®Œæ•´æµç¨‹ï¼Œæ¶µç›–ç¼–ç è§„èŒƒã€æ—¶é’ŸåŸŸè®¾è®¡ã€å¤ä½ç­–ç•¥ã€ä½åŠŸè€—è®¾è®¡ã€é¢ç§¯ä¼˜åŒ–å’Œæ—¶åºæ”¶æ•›ç­‰å…³é”®æŠ€æœ¯ã€‚</p>

            <h3>6.1 è®¾è®¡æµç¨‹</h3>
            
            <p>NPUçš„RTLè®¾è®¡æ˜¯è¿æ¥ç®—æ³•æ¶æ„ä¸ç‰©ç†å®ç°çš„å…³é”®ç¯èŠ‚ï¼Œéœ€è¦éµå¾ªä¸¥æ ¼çš„è®¾è®¡æµç¨‹ã€‚</p>

            <h4>6.1.1 è®¾è®¡æµç¨‹æ¦‚è§ˆ</h4>
            <div class="code-block">
NPU RTLè®¾è®¡æµç¨‹ï¼š

1. ç³»ç»Ÿçº§è®¾è®¡
   â””â”€â”€ å®šä¹‰æ€§èƒ½æŒ‡æ ‡ï¼šTOPSã€ç²¾åº¦ã€åŠŸè€—
   â””â”€â”€ ç®—æ³•æ˜ å°„ï¼šæ”¯æŒçš„ç®—å­ã€æ•°æ®æµ

2. å¾®æ¶æ„è®¾è®¡
   â””â”€â”€ è®¡ç®—é˜µåˆ—è§„æ¨¡ï¼š8Ã—8ã€16Ã—16ç­‰
   â””â”€â”€ å­˜å‚¨å±‚æ¬¡ï¼šL0/L1/L2å®¹é‡å’Œå¸¦å®½
   â””â”€â”€ æ•°æ®é€šè·¯ï¼šä½å®½ã€æµæ°´çº¿çº§æ•°
   â””â”€â”€ æ§åˆ¶æ¶æ„ï¼šæŒ‡ä»¤é›†ã€è°ƒåº¦å™¨

3. RTLç¼–ç 
   â””â”€â”€ æ¨¡å—åˆ’åˆ†å’Œæ¥å£å®šä¹‰
   â””â”€â”€ åŠŸèƒ½å®ç°å’Œæ—¶åºè®¾è®¡
   â””â”€â”€ å‚æ•°åŒ–å’Œå¯é…ç½®è®¾è®¡

4. éªŒè¯ä¸ä»¿çœŸ
   â””â”€â”€ åŠŸèƒ½éªŒè¯ï¼šUVMæµ‹è¯•å¹³å°
   â””â”€â”€ æ€§èƒ½éªŒè¯ï¼šå‘¨æœŸç²¾ç¡®æ¨¡å‹
   â””â”€â”€ å½¢å¼éªŒè¯ï¼šç­‰ä»·æ€§æ£€æŸ¥

5. é€»è¾‘ç»¼åˆ
   â””â”€â”€ çº¦æŸå®šä¹‰ï¼šæ—¶åºã€é¢ç§¯ã€åŠŸè€—
   â””â”€â”€ å·¥è‰ºæ˜ å°„ï¼šæ ‡å‡†å•å…ƒåº“
   â””â”€â”€ ä¼˜åŒ–ç­–ç•¥ï¼šæ—¶åº/é¢ç§¯/åŠŸè€—æƒè¡¡

6. ç‰©ç†å®ç°
   â””â”€â”€ å¸ƒå±€è§„åˆ’ï¼šæ¨¡å—æ‘†æ”¾
   â””â”€â”€ æ—¶é’Ÿæ ‘ç»¼åˆï¼šæ—¶é’Ÿåæ–œæ§åˆ¶
   â””â”€â”€ å¸ƒçº¿ä¼˜åŒ–ï¼šæ‹¥å¡å’Œä¸²æ‰°

7. ç­¾æ ¸éªŒè¯
   â””â”€â”€ STAï¼šé™æ€æ—¶åºåˆ†æ
   â””â”€â”€ åŠŸè€—åˆ†æï¼šIR Drop
   â””â”€â”€ DRC/LVSï¼šç‰©ç†éªŒè¯
            </div>

            <h4>6.1.2 è®¾è®¡è¿­ä»£ä¸ä¼˜åŒ–</h4>
            <div class="code-block">
// è®¾è®¡è´¨é‡è¯„ä¼°æ¡†æ¶
module DesignQualityMonitor #(
    parameter DESIGN_NAME = "NPU_TOP"
)(
    // ç»¼åˆæŠ¥å‘Šè¾“å…¥
    input real target_freq_mhz,
    input real actual_freq_mhz,
    input real target_area_mm2,
    input real actual_area_mm2,
    input real target_power_mw,
    input real actual_power_mw,
    
    // è´¨é‡æŒ‡æ ‡è¾“å‡º
    output reg timing_met,
    output reg area_met,
    output reg power_met,
    output reg [7:0] overall_score
);

    // è¯„ä¼°é€»è¾‘
    always @(*) begin
        timing_met = (actual_freq_mhz >= target_freq_mhz);
        area_met = (actual_area_mm2 <= target_area_mm2);
        power_met = (actual_power_mw <= target_power_mw);
        
        // è®¡ç®—ç»¼åˆå¾—åˆ†
        real timing_score = (actual_freq_mhz / target_freq_mhz) * 100;
        real area_score = (target_area_mm2 / actual_area_mm2) * 100;
        real power_score = (target_power_mw / actual_power_mw) * 100;
        
        overall_score = (timing_score * 0.4 + 
                        area_score * 0.3 + 
                        power_score * 0.3) / 100 * 255;
    end
    
    // ç”Ÿæˆä¼˜åŒ–å»ºè®®
    always @(*) begin
        if (!timing_met) begin
            $display("[%s] Timing not met. Suggestions:", DESIGN_NAME);
            $display("  - Increase pipeline stages");
            $display("  - Reduce logic levels");
            $display("  - Optimize critical paths");
        end
        
        if (!area_met) begin
            $display("[%s] Area exceeded. Suggestions:", DESIGN_NAME);
            $display("  - Enable resource sharing");
            $display("  - Reduce data width where possible");
            $display("  - Use memory instead of registers");
        end
        
        if (!power_met) begin
            $display("[%s] Power exceeded. Suggestions:", DESIGN_NAME);
            $display("  - Add more clock gating");
            $display("  - Reduce switching activity");
            $display("  - Consider voltage scaling");
        end
    end
endmodule
            </div>

            <h3>6.2 ç¼–ç è§„èŒƒ</h3>
            
            <p>ç»Ÿä¸€çš„ç¼–ç è§„èŒƒæ˜¯ä¿è¯ä»£ç è´¨é‡ã€å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§çš„åŸºç¡€ã€‚</p>

            <h4>6.2.1 å‘½åè§„åˆ™</h4>
            <div class="code-block">
// ========== NPU RTLç¼–ç è§„èŒƒç¤ºä¾‹ ==========

// 1. æ¨¡å—å‘½åï¼šä½¿ç”¨å¤§é©¼å³°å‘½åæ³•
module NpuTopModule #(
    parameter ARRAY_SIZE = 16,
    parameter DATA_WIDTH = 8
)(
    // 2. ç«¯å£å‘½åè§„åˆ™
    // æ—¶é’Ÿä¿¡å·ï¼šclk_å‰ç¼€
    input  wire                     clk_sys,        // ç³»ç»Ÿæ—¶é’Ÿ
    input  wire                     clk_noc,        // NoCæ—¶é’Ÿ
    
    // å¤ä½ä¿¡å·ï¼šrst_å‰ç¼€ï¼Œ_nè¡¨ç¤ºä½æœ‰æ•ˆ
    input  wire                     rst_sys_n,      // ç³»ç»Ÿå¤ä½
    input  wire                     rst_noc_n,      // NoCå¤ä½
    
    // è¾“å…¥ä¿¡å·ï¼š_iåç¼€
    input  wire [DATA_WIDTH-1:0]    weight_data_i,
    input  wire                     weight_valid_i,
    output wire                     weight_ready_o,
    
    // è¾“å‡ºä¿¡å·ï¼š_oåç¼€
    output wire [31:0]              result_data_o,
    output wire                     result_valid_o,
    input  wire                     result_ready_i,
    
    // é…ç½®å¯„å­˜å™¨ï¼šcfg_å‰ç¼€
    input  wire [31:0]              cfg_layer_param,
    input  wire [15:0]              cfg_tile_size
);

    // 3. å†…éƒ¨ä¿¡å·å‘½å
    // å¯„å­˜å™¨è¾“å‡ºï¼š_qåç¼€
    reg  [DATA_WIDTH-1:0]           weight_buffer_q;
    
    // å¯„å­˜å™¨è¾“å…¥ï¼š_dåç¼€
    wire [DATA_WIDTH-1:0]           weight_buffer_d;
    
    // ç»„åˆé€»è¾‘ä¸­é—´ä¿¡å·ï¼š_combåç¼€
    wire [DATA_WIDTH-1:0]           partial_sum_comb;
    
    // æ§åˆ¶ä¿¡å·ï¼šæè¿°æ€§å‘½å
    wire                            compute_enable;
    wire                            accumulate_start;
    
    // 4. å‚æ•°å‘½åï¼šå…¨å¤§å†™ï¼Œä¸‹åˆ’çº¿åˆ†éš”
    localparam BUFFER_DEPTH = 1024;
    localparam FSM_IDLE = 3'b000;
    localparam FSM_COMPUTE = 3'b001;
    
    // 5. Generateå˜é‡ï¼šgen_å‰ç¼€
    genvar gen_i, gen_j;
    
    // 6. å‡½æ•°å‘½åï¼šå°é©¼å³°å‘½åæ³•
    function [7:0] calculateChecksum;
        input [31:0] data;
        begin
            calculateChecksum = data[7:0] ^ data[15:8] ^ 
                               data[23:16] ^ data[31:24];
        end
    endfunction

endmodule
            </div>

            <h4>6.2.2 æ¨¡å—åŒ–è®¾è®¡åŸåˆ™</h4>
            <div class="code-block">
// è‰¯å¥½çš„æ¨¡å—åˆ’åˆ†ç¤ºä¾‹
module NpuComputeCluster #(
    parameter CLUSTER_ID = 0,
    parameter PE_ROWS = 4,
    parameter PE_COLS = 4
)(
    input  wire         clk,
    input  wire         rst_n,
    
    // æ ‡å‡†åŒ–æ¥å£
    NpuDataInterface.slave      data_if,
    NpuControlInterface.slave   ctrl_if,
    NpuConfigInterface.slave    cfg_if
);

    // ===== æ¨¡å—åŒ–åŸåˆ™ =====
    // 1. å•ä¸€èŒè´£ï¼šæ¯ä¸ªæ¨¡å—åªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½
    // 2. æ¥å£æ¸…æ™°ï¼šä½¿ç”¨SystemVerilog interface
    // 3. å‚æ•°åŒ–è®¾è®¡ï¼šä¾¿äºå¤ç”¨å’Œé…ç½®
    // 4. å±‚æ¬¡åŒ–ç»„ç»‡ï¼šè‡ªé¡¶å‘ä¸‹åˆ†è§£
    
    // å­æ¨¡å—å®ä¾‹åŒ–
    genvar row, col;
    generate
        for (row = 0; row < PE_ROWS; row = row + 1) begin : gen_pe_row
            for (col = 0; col < PE_COLS; col = col + 1) begin : gen_pe_col
                ProcessingElement #(
                    .PE_ID(row * PE_COLS + col),
                    .DATA_WIDTH(data_if.DATA_WIDTH)
                ) u_pe (
                    .clk        (clk),
                    .rst_n      (rst_n),
                    .north_i    (pe_north_conn[row][col]),
                    .south_o    (pe_south_conn[row][col]),
                    .west_i     (pe_west_conn[row][col]),
                    .east_o     (pe_east_conn[row][col]),
                    .config_i   (pe_config[row][col])
                );
            end
        end
    endgenerate
    
    // æœ¬åœ°æ§åˆ¶å™¨
    ClusterController #(
        .CLUSTER_ID(CLUSTER_ID)
    ) u_controller (
        .clk        (clk),
        .rst_n      (rst_n),
        .ctrl_if    (ctrl_if),
        .pe_enable  (pe_enable),
        .pe_mode    (pe_mode)
    );
    
    // æ•°æ®åˆ†å‘ç½‘ç»œ
    DataDistributionNetwork #(
        .NUM_PE(PE_ROWS * PE_COLS)
    ) u_data_network (
        .clk        (clk),
        .rst_n      (rst_n),
        .data_if    (data_if),
        .pe_data    (pe_data_conn)
    );

endmodule

// SystemVerilog Interfaceå®šä¹‰
interface NpuDataInterface #(
    parameter DATA_WIDTH = 256,
    parameter ADDR_WIDTH = 32
);
    logic [DATA_WIDTH-1:0]  data;
    logic [ADDR_WIDTH-1:0]  addr;
    logic                   valid;
    logic                   ready;
    
    modport master (
        output data, addr, valid,
        input  ready
    );
    
    modport slave (
        input  data, addr, valid,
        output ready
    );
endinterface
            </div>

            <h4>6.2.3 å¯ç»¼åˆRTLç¼–ç å‡†åˆ™</h4>
            <div class="code-block">
// ===== å¯ç»¼åˆRTLç¼–ç ç¤ºä¾‹ =====

module SynthesizableDesign (
    input  wire         clk,
    input  wire         rst_n,
    input  wire [7:0]   data_in,
    input  wire         data_valid,
    output reg  [15:0]  data_out,
    output reg          data_ready
);

    // 1. æ—¶åºé€»è¾‘ï¼šç»Ÿä¸€ä½¿ç”¨éé˜»å¡èµ‹å€¼
    reg [7:0] data_reg_q;
    reg [2:0] state_q;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_reg_q <= 8'h00;
            state_q <= 3'b000;
        end else begin
            data_reg_q <= data_in;    // éé˜»å¡èµ‹å€¼
            state_q <= next_state;     // éé˜»å¡èµ‹å€¼
        end
    end
    
    // 2. ç»„åˆé€»è¾‘ï¼šä½¿ç”¨é˜»å¡èµ‹å€¼ï¼Œå®Œæ•´çš„æ¡ä»¶è¦†ç›–
    reg [2:0] next_state;
    reg [15:0] compute_result;
    
    always @(*) begin
        // é»˜è®¤èµ‹å€¼ï¼Œé¿å…é”å­˜å™¨
        next_state = state_q;
        compute_result = 16'h0000;
        data_ready = 1'b0;
        
        case (state_q)
            3'b000: begin  // IDLE
                if (data_valid) begin
                    next_state = 3'b001;
                end
            end
            
            3'b001: begin  // COMPUTE
                compute_result = {data_reg_q, data_in};  // é˜»å¡èµ‹å€¼
                next_state = 3'b010;
            end
            
            3'b010: begin  // OUTPUT
                data_ready = 1'b1;
                if (data_valid) begin
                    next_state = 3'b001;
                end else begin
                    next_state = 3'b000;
                end
            end
            
            default: begin  // å¿…é¡»æœ‰defaultåˆ†æ”¯
                next_state = 3'b000;
            end
        endcase
    end
    
    // 3. è¾“å‡ºå¯„å­˜å™¨åŒ–ï¼Œæ”¹å–„æ—¶åº
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_out <= 16'h0000;
        end else begin
            data_out <= compute_result;
        end
    end
    
    // 4. é¿å…çš„å†™æ³•ç¤ºä¾‹ï¼ˆæ³¨é‡Šå½¢å¼ï¼‰
    // initial begin              // ä¸å¯ç»¼åˆ
    //     data_out = 0;
    // end
    
    // always @(data_in) begin    // ä¸å®Œæ•´çš„æ•æ„Ÿåˆ—è¡¨
    //     result = data_in + offset;
    // end
    
    // #10 data_out = result;     // å»¶æ—¶è¯­å¥ä¸å¯ç»¼åˆ

endmodule

// 5. æ¨èçš„å‚æ•°åŒ–ç§»ä½å™¨å®ç°
module ParametricShifter #(
    parameter WIDTH = 32,
    parameter SHIFT_WIDTH = 5
)(
    input  wire [WIDTH-1:0]         data_in,
    input  wire [SHIFT_WIDTH-1:0]   shift_amount,
    input  wire                     shift_dir,  // 0: left, 1: right
    output wire [WIDTH-1:0]         data_out
);

    // ä½¿ç”¨generateå®ç°å¯é…ç½®çš„ç§»ä½å™¨
    wire [WIDTH-1:0] shift_stages [SHIFT_WIDTH:0];
    assign shift_stages[0] = data_in;
    
    genvar i;
    generate
        for (i = 0; i < SHIFT_WIDTH; i = i + 1) begin : gen_shift
            assign shift_stages[i+1] = shift_amount[i] ? 
                (shift_dir ? 
                    (shift_stages[i] >> (1 << i)) : 
                    (shift_stages[i] << (1 << i))) : 
                shift_stages[i];
        end
    endgenerate
    
    assign data_out = shift_stages[SHIFT_WIDTH];

endmodule
            </div>

            <h4>6.2.4 RTLç¼–ç åä¾‹ï¼ˆAnti-patternsï¼‰</h4>
            <div class="warning-box">
                <p><strong>âš ï¸ å¸¸è§çš„RTLç¼–ç é”™è¯¯ç¤ºä¾‹ï¼š</strong></p>
            </div>
            
            <div class="code-block">
// âŒ é”™è¯¯ç¤ºä¾‹1ï¼šäº§ç”Ÿé”å­˜å™¨çš„ç»„åˆé€»è¾‘
module bad_latch_example (
    input wire [1:0] sel,
    input wire [7:0] a, b, c,
    output reg [7:0] out
);
    // é”™è¯¯ï¼šä¸å®Œæ•´çš„æ¡ä»¶è¦†ç›–ä¼šäº§ç”Ÿé”å­˜å™¨
    always @(*) begin
        case (sel)
            2'b00: out = a;
            2'b01: out = b;
            2'b10: out = c;
            // ç¼ºå°‘defaultæˆ–2'b11çš„æƒ…å†µï¼
        endcase
    end
endmodule

// âœ… æ­£ç¡®åšæ³•ï¼šå®Œæ•´çš„æ¡ä»¶è¦†ç›–
module good_comb_example (
    input wire [1:0] sel,
    input wire [7:0] a, b, c,
    output reg [7:0] out
);
    always @(*) begin
        case (sel)
            2'b00: out = a;
            2'b01: out = b;
            2'b10: out = c;
            default: out = 8'h00;  // å¿…é¡»æœ‰default
        endcase
    end
endmodule

// âŒ é”™è¯¯ç¤ºä¾‹2ï¼šé˜»å¡ä¸éé˜»å¡èµ‹å€¼æ··ç”¨
module bad_assignment_mix (
    input wire clk, rst_n,
    input wire [7:0] d,
    output reg [7:0] q
);
    reg [7:0] temp;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            temp = 8'h00;    // é”™è¯¯ï¼šæ—¶åºé€»è¾‘ä¸­ä½¿ç”¨é˜»å¡èµ‹å€¼
            q <= 8'h00;
        end else begin
            temp = d;        // é”™è¯¯ï¼šæ··ç”¨èµ‹å€¼ç±»å‹
            q <= temp;       // ä¼šå¯¼è‡´ä»¿çœŸä¸ç»¼åˆä¸ä¸€è‡´
        end
    end
endmodule

// âœ… æ­£ç¡®åšæ³•ï¼šæ—¶åºé€»è¾‘ç»Ÿä¸€ä½¿ç”¨éé˜»å¡èµ‹å€¼
module good_sequential (
    input wire clk, rst_n,
    input wire [7:0] d,
    output reg [7:0] q
);
    reg [7:0] temp;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            temp <= 8'h00;
            q <= 8'h00;
        end else begin
            temp <= d;
            q <= temp;
        end
    end
endmodule

// âŒ é”™è¯¯ç¤ºä¾‹3ï¼šç»„åˆé€»è¾‘ç¯è·¯
module bad_comb_loop (
    input wire enable,
    input wire [7:0] data_in,
    output wire [7:0] data_out
);
    wire [7:0] internal;
    
    // é”™è¯¯ï¼šåˆ›å»ºäº†ç»„åˆé€»è¾‘ç¯è·¯
    assign internal = enable ? data_in : data_out;
    assign data_out = internal + 1;
    // è¿™ä¼šå¯¼è‡´ä»¿çœŸæ—¶å‡ºç°Xæ€ä¼ æ’­ï¼Œç»¼åˆæ—¶å‡ºç°timing loop
endmodule

// âœ… æ­£ç¡®åšæ³•ï¼šæ‰“ç ´ç»„åˆç¯è·¯
module good_registered (
    input wire clk, rst_n,
    input wire enable,
    input wire [7:0] data_in,
    output reg [7:0] data_out
);
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            data_out <= 8'h00;
        else if (enable)
            data_out <= data_in + 1;
    end
endmodule
            </div>

            <div class="info-box">
                <p><strong>è¿™äº›é”™è¯¯çš„å±å®³ï¼š</strong></p>
                <ul>
                    <li><strong>é”å­˜å™¨ï¼š</strong>å¯¹æ¯›åˆºæ•æ„Ÿï¼Œæ—¶åºåˆ†æå›°éš¾ï¼ŒåŠŸè€—é«˜ï¼Œæµ‹è¯•è¦†ç›–ç‡ä½</li>
                    <li><strong>èµ‹å€¼æ··ç”¨ï¼š</strong>ä»¿çœŸè¡Œä¸ºä¸ç»¼åˆç»“æœä¸ä¸€è‡´ï¼Œå¯¼è‡´ç¡…å‰éªŒè¯å¤±æ•ˆ</li>
                    <li><strong>ç»„åˆç¯è·¯ï¼š</strong>äº§ç”ŸæŒ¯è¡ï¼Œæ—¶åºæ— æ³•æ”¶æ•›ï¼ŒèŠ¯ç‰‡åŠŸèƒ½å¤±æ•ˆ</li>
                    <li><strong>é¢„é˜²æªæ–½ï¼š</strong>ä½¿ç”¨lintå·¥å…·ï¼ˆå¦‚Spyglassï¼‰åœ¨æ—©æœŸå‘ç°è¿™äº›é—®é¢˜</li>
                </ul>
            </div>

            <h3>6.3 æ—¶é’ŸåŸŸè®¾è®¡</h3>
            
            <p>NPUé€šå¸¸åŒ…å«å¤šä¸ªæ—¶é’ŸåŸŸï¼Œæ­£ç¡®çš„è·¨æ—¶é’ŸåŸŸ(CDC)è®¾è®¡å¯¹ç³»ç»Ÿç¨³å®šæ€§è‡³å…³é‡è¦ã€‚</p>

            <h4>6.3.1 æ—¶é’ŸåŸŸåˆ’åˆ†</h4>
            <div class="code-block">
// NPUå…¸å‹æ—¶é’ŸåŸŸåˆ’åˆ†
module NpuClockDomains (
    // å¤šæ—¶é’Ÿè¾“å…¥
    input wire clk_sys,          // ç³»ç»Ÿæ—¶é’Ÿ (1GHz)
    input wire clk_noc,          // NoCæ—¶é’Ÿ (800MHz)
    input wire clk_ddr,          // DDRæ—¶é’Ÿ (2.4GHz)
    input wire clk_cfg,          // é…ç½®æ—¶é’Ÿ (100MHz)
    input wire clk_dbg,          // è°ƒè¯•æ—¶é’Ÿ (50MHz)
    
    input wire rst_n
);

    // ===== æ—¶é’ŸåŸŸåŠŸèƒ½åˆ’åˆ† =====
    // 1. è®¡ç®—åŸŸ (clk_sys)
    //    - MACé˜µåˆ—
    //    - å‘é‡å¤„ç†å•å…ƒ
    //    - æœ¬åœ°SRAM
    
    // 2. äº’è¿åŸŸ (clk_noc)
    //    - ç‰‡ä¸Šç½‘ç»œ
    //    - DMAæ§åˆ¶å™¨
    //    - å…¨å±€ç¼“å†²åŒº
    
    // 3. å­˜å‚¨åŸŸ (clk_ddr)
    //    - DDRæ§åˆ¶å™¨
    //    - PHYæ¥å£
    
    // 4. ä½é€ŸåŸŸ (clk_cfg)
    //    - é…ç½®å¯„å­˜å™¨
    //    - ä¸­æ–­æ§åˆ¶å™¨
    //    - ç”µæºç®¡ç†
    
    // 5. è°ƒè¯•åŸŸ (clk_dbg)
    //    - è°ƒè¯•æ¥å£
    //    - æ€§èƒ½è®¡æ•°å™¨
    //    - Traceç¼“å†²åŒº

endmodule
            </div>

            <h4>6.3.2 CDCåŒæ­¥å™¨è®¾è®¡</h4>
            <div class="code-block">
// 1. å•æ¯”ç‰¹ä¿¡å·åŒæ­¥å™¨ï¼ˆ2çº§è§¦å‘å™¨ï¼‰
module SyncBit #(
    parameter SYNC_STAGES = 2  // å¯é…ç½®åŒæ­¥çº§æ•°
)(
    input  wire clk_dst,
    input  wire rst_dst_n,
    input  wire data_in,
    output wire data_out
);

    reg [SYNC_STAGES-1:0] sync_regs;
    
    always @(posedge clk_dst or negedge rst_dst_n) begin
        if (!rst_dst_n) begin
            sync_regs <= {SYNC_STAGES{1'b0}};
        end else begin
            sync_regs <= {sync_regs[SYNC_STAGES-2:0], data_in};
        end
    end
    
    assign data_out = sync_regs[SYNC_STAGES-1];

endmodule

// 2. å¤šæ¯”ç‰¹æ•°æ®CDC - æ¡æ‰‹åè®®
module HandshakeCDC #(
    parameter DATA_WIDTH = 32
)(
    // æºæ—¶é’ŸåŸŸ
    input  wire                     clk_src,
    input  wire                     rst_src_n,
    input  wire [DATA_WIDTH-1:0]    data_src,
    input  wire                     valid_src,
    output wire                     ready_src,
    
    // ç›®æ ‡æ—¶é’ŸåŸŸ
    input  wire                     clk_dst,
    input  wire                     rst_dst_n,
    output wire [DATA_WIDTH-1:0]    data_dst,
    output wire                     valid_dst,
    input  wire                     ready_dst
);

    // æºåŸŸï¼šæ•°æ®å¯„å­˜å’Œè¯·æ±‚ç”Ÿæˆ
    reg [DATA_WIDTH-1:0] data_hold_q;
    reg req_q;
    wire ack_sync_src;
    
    always @(posedge clk_src or negedge rst_src_n) begin
        if (!rst_src_n) begin
            data_hold_q <= {DATA_WIDTH{1'b0}};
            req_q <= 1'b0;
        end else begin
            if (valid_src && ready_src) begin
                data_hold_q <= data_src;
                req_q <= 1'b1;
            end else if (ack_sync_src) begin
                req_q <= 1'b0;
            end
        end
    end
    
    assign ready_src = !req_q || ack_sync_src;
    
    // è¯·æ±‚ä¿¡å·åŒæ­¥åˆ°ç›®æ ‡åŸŸ
    wire req_sync_dst;
    SyncBit u_req_sync (
        .clk_dst    (clk_dst),
        .rst_dst_n  (rst_dst_n),
        .data_in    (req_q),
        .data_out   (req_sync_dst)
    );
    
    // ç›®æ ‡åŸŸï¼šæ¥æ”¶æ•°æ®å’Œåº”ç­”ç”Ÿæˆ
    reg ack_q;
    reg req_sync_d1;
    
    always @(posedge clk_dst or negedge rst_dst_n) begin
        if (!rst_dst_n) begin
            ack_q <= 1'b0;
            req_sync_d1 <= 1'b0;
        end else begin
            req_sync_d1 <= req_sync_dst;
            
            if (req_sync_dst && !req_sync_d1) begin  // ä¸Šå‡æ²¿æ£€æµ‹
                ack_q <= 1'b1;
            end else if (!req_sync_dst) begin
                ack_q <= 1'b0;
            end
        end
    end
    
    assign data_dst = data_hold_q;  // æ•°æ®ä¿æŒç¨³å®š
    assign valid_dst = req_sync_dst && !ack_q;
    
    // åº”ç­”ä¿¡å·åŒæ­¥å›æºåŸŸ
    SyncBit u_ack_sync (
        .clk_dst    (clk_src),
        .rst_dst_n  (rst_src_n),
        .data_in    (ack_q),
        .data_out   (ack_sync_src)
    );

endmodule

// 3. å¼‚æ­¥FIFOå®ç°
module AsyncFIFO #(
    parameter DATA_WIDTH = 32,
    parameter ADDR_WIDTH = 4,
    parameter DEPTH = 16
)(
    // å†™æ—¶é’ŸåŸŸ
    input  wire                     wr_clk,
    input  wire                     wr_rst_n,
    input  wire                     wr_en,
    input  wire [DATA_WIDTH-1:0]    wr_data,
    output wire                     wr_full,
    
    // è¯»æ—¶é’ŸåŸŸ
    input  wire                     rd_clk,
    input  wire                     rd_rst_n,
    input  wire                     rd_en,
    output wire [DATA_WIDTH-1:0]    rd_data,
    output wire                     rd_empty
);

    // åŒç«¯å£RAM
    reg [DATA_WIDTH-1:0] mem [DEPTH-1:0];
    
    // å†™æŒ‡é’ˆï¼ˆäºŒè¿›åˆ¶å’Œæ ¼é›·ç ï¼‰
    reg [ADDR_WIDTH:0] wr_ptr_bin_q;
    reg [ADDR_WIDTH:0] wr_ptr_gray_q;
    wire [ADDR_WIDTH:0] wr_ptr_bin_next;
    wire [ADDR_WIDTH:0] wr_ptr_gray_next;
    
    // è¯»æŒ‡é’ˆï¼ˆäºŒè¿›åˆ¶å’Œæ ¼é›·ç ï¼‰
    reg [ADDR_WIDTH:0] rd_ptr_bin_q;
    reg [ADDR_WIDTH:0] rd_ptr_gray_q;
    wire [ADDR_WIDTH:0] rd_ptr_bin_next;
    wire [ADDR_WIDTH:0] rd_ptr_gray_next;
    
    // åŒæ­¥åçš„æŒ‡é’ˆ
    wire [ADDR_WIDTH:0] wr_ptr_gray_sync;
    wire [ADDR_WIDTH:0] rd_ptr_gray_sync;
    
    // äºŒè¿›åˆ¶è½¬æ ¼é›·ç 
    function [ADDR_WIDTH:0] bin2gray(input [ADDR_WIDTH:0] bin);
        bin2gray = bin ^ (bin >> 1);
    endfunction
    
    // æ ¼é›·ç è½¬äºŒè¿›åˆ¶
    function [ADDR_WIDTH:0] gray2bin(input [ADDR_WIDTH:0] gray);
        integer i;
        begin
            gray2bin[ADDR_WIDTH] = gray[ADDR_WIDTH];
            for (i = ADDR_WIDTH-1; i >= 0; i = i-1) begin
                gray2bin[i] = gray2bin[i+1] ^ gray[i];
            end
        end
    endfunction
    
    // å†™é€»è¾‘
    assign wr_ptr_bin_next = wr_ptr_bin_q + (wr_en && !wr_full);
    assign wr_ptr_gray_next = bin2gray(wr_ptr_bin_next);
    
    always @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n) begin
            wr_ptr_bin_q <= 0;
            wr_ptr_gray_q <= 0;
        end else begin
            wr_ptr_bin_q <= wr_ptr_bin_next;
            wr_ptr_gray_q <= wr_ptr_gray_next;
            
            if (wr_en && !wr_full) begin
                mem[wr_ptr_bin_q[ADDR_WIDTH-1:0]] <= wr_data;
            end
        end
    end
    
    // è¯»é€»è¾‘
    assign rd_ptr_bin_next = rd_ptr_bin_q + (rd_en && !rd_empty);
    assign rd_ptr_gray_next = bin2gray(rd_ptr_bin_next);
    
    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            rd_ptr_bin_q <= 0;
            rd_ptr_gray_q <= 0;
        end else begin
            rd_ptr_bin_q <= rd_ptr_bin_next;
            rd_ptr_gray_q <= rd_ptr_gray_next;
        end
    end
    
    assign rd_data = mem[rd_ptr_bin_q[ADDR_WIDTH-1:0]];
    
    // æŒ‡é’ˆåŒæ­¥
    SyncBus #(.WIDTH(ADDR_WIDTH+1)) u_wr2rd_sync (
        .clk_dst    (rd_clk),
        .rst_dst_n  (rd_rst_n),
        .data_in    (wr_ptr_gray_q),
        .data_out   (wr_ptr_gray_sync)
    );
    
    SyncBus #(.WIDTH(ADDR_WIDTH+1)) u_rd2wr_sync (
        .clk_dst    (wr_clk),
        .rst_dst_n  (wr_rst_n),
        .data_in    (rd_ptr_gray_q),
        .data_out   (rd_ptr_gray_sync)
    );
    
    // ç©ºæ»¡åˆ¤æ–­
    assign wr_full = (wr_ptr_gray_next == {~rd_ptr_gray_sync[ADDR_WIDTH:ADDR_WIDTH-1], 
                                            rd_ptr_gray_sync[ADDR_WIDTH-2:0]});
    assign rd_empty = (rd_ptr_gray_q == wr_ptr_gray_sync);

endmodule
            </div>

            <h4>6.3.3 CDCæ–¹æ¡ˆå¯¹æ¯”ä¸é€‰æ‹©</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>æ–¹æ¡ˆ</th>
                            <th>å»¶è¿Ÿ</th>
                            <th>ååé‡</th>
                            <th>é¢ç§¯å¼€é”€</th>
                            <th>è®¾è®¡å¤æ‚åº¦</th>
                            <th>é€‚ç”¨åœºæ™¯</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>ä¸¤çº§åŒæ­¥å™¨</td>
                            <td>å›ºå®š2-3å‘¨æœŸ</td>
                            <td>ä½</td>
                            <td>æœ€å°</td>
                            <td>ä½</td>
                            <td>å•æ¯”ç‰¹æ§åˆ¶ä¿¡å·</td>
                        </tr>
                        <tr>
                            <td>æ¡æ‰‹åè®®</td>
                            <td>å¯å˜(4-10å‘¨æœŸ)</td>
                            <td>ä¸­</td>
                            <td>ä¸­ç­‰</td>
                            <td>ä¸­</td>
                            <td>å¤šæ¯”ç‰¹æ•°æ®ã€å‘½ä»¤ä¼ è¾“</td>
                        </tr>
                        <tr>
                            <td>å¼‚æ­¥FIFO</td>
                            <td>é«˜(æ·±åº¦ç›¸å…³)</td>
                            <td>é«˜</td>
                            <td>è¾ƒå¤§</td>
                            <td>é«˜</td>
                            <td>å¤§é‡è¿ç»­æ•°æ®æµ</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="warning-box">
                <p><strong>âš ï¸ CDCè®¾è®¡é™·é˜±è­¦å‘Šï¼š</strong></p>
                <ul>
                    <li><strong>äºšç¨³æ€é—®é¢˜ï¼š</strong>CDCæ˜¯èŠ¯ç‰‡è®¾è®¡ä¸­æœ€éš¾è°ƒè¯•çš„é—®é¢˜ä¹‹ä¸€ï¼Œæ•…éšœç°è±¡å¶å‘ä¸”éš¾ä»¥å¤ç°</li>
                    <li><strong>æ¯›åˆºä¼ æ’­ï¼š</strong>ç»„åˆé€»è¾‘è¾“å‡ºç›´æ¥è·¨æ—¶é’ŸåŸŸä¼šå¯¼è‡´æ¯›åˆºä¼ æ’­ï¼Œå¿…é¡»å…ˆå¯„å­˜</li>
                    <li><strong>æ ¼é›·ç è¦æ±‚ï¼š</strong>å¤šæ¯”ç‰¹è®¡æ•°å™¨è·¨æ—¶é’ŸåŸŸå¿…é¡»ä½¿ç”¨æ ¼é›·ç ï¼Œå¦åˆ™ä¼šäº§ç”Ÿé”™è¯¯</li>
                    <li><strong>éªŒè¯æŒ‘æˆ˜ï¼š</strong>å¸¸è§„ä»¿çœŸéš¾ä»¥å‘ç°CDCé—®é¢˜ï¼Œéœ€è¦ä¸“é—¨çš„CDCéªŒè¯å·¥å…·</li>
                </ul>
            </div>

            <h3>6.4 å¤ä½ç­–ç•¥</h3>
            
            <p>åˆç†çš„å¤ä½ç­–ç•¥å¯¹NPUçš„å¯é æ€§å’ŒåŠŸèƒ½æ­£ç¡®æ€§è‡³å…³é‡è¦ã€‚éœ€è¦è€ƒè™‘å¤ä½æ ‘çš„åˆ†å¸ƒã€åŒæ­¥ã€æ—¶åºå’ŒåŠŸè€—ã€‚</p>

            <h4>6.4.1 å¤ä½ç±»å‹é€‰æ‹©</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>å¤ä½ç±»å‹</th>
                            <th>ä¼˜ç‚¹</th>
                            <th>ç¼ºç‚¹</th>
                            <th>é€‚ç”¨åœºæ™¯</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>åŒæ­¥å¤ä½</td>
                            <td>æ— äºšç¨³æ€é—®é¢˜ã€æ—¶åºå®¹æ˜“æ»¡è¶³</td>
                            <td>éœ€è¦æ—¶é’Ÿã€å¤ä½å»¶è¿Ÿå¤§</td>
                            <td>æ•°æ®é€šè·¯ã€çŠ¶æ€æœº</td>
                        </tr>
                        <tr>
                            <td>å¼‚æ­¥å¤ä½</td>
                            <td>å“åº”å¿«ã€ä¸éœ€è¦æ—¶é’Ÿ</td>
                            <td>é‡Šæ”¾æ—¶å¯èƒ½äº§ç”Ÿäºšç¨³æ€</td>
                            <td>æ§åˆ¶å¯„å­˜å™¨ã€é…ç½®æ¨¡å—</td>
                        </tr>
                        <tr>
                            <td>å¼‚æ­¥å¤ä½åŒæ­¥é‡Šæ”¾</td>
                            <td>ç»“åˆä¸¤è€…ä¼˜ç‚¹</td>
                            <td>è®¾è®¡å¤æ‚åº¦å¢åŠ </td>
                            <td>æ¨èçš„é»˜è®¤é€‰æ‹©</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="info-box">
                <p><strong>ä¸ºä»€ä¹ˆéœ€è¦"å¼‚æ­¥å¤ä½åŒæ­¥é‡Šæ”¾"ï¼Ÿ</strong></p>
                <p>å¼‚æ­¥å¤ä½çš„é‡Šæ”¾è¾¹æ²¿å¦‚æœä¸åŒæ­¥ï¼Œä¼šå¯¼è‡´ä¸¥é‡çš„æ—¶åºé—®é¢˜ï¼š</p>
                <ul>
                    <li><strong>Recoveryæ—¶é—´è¿ä¾‹ï¼š</strong>å¤ä½é‡Šæ”¾ä¿¡å·ç›¸å¯¹äºæ—¶é’Ÿçš„å»ºç«‹æ—¶é—´ä¸è¶³</li>
                    <li><strong>Removalæ—¶é—´è¿ä¾‹ï¼š</strong>å¤ä½é‡Šæ”¾ä¿¡å·ç›¸å¯¹äºæ—¶é’Ÿçš„ä¿æŒæ—¶é—´ä¸è¶³</li>
                    <li><strong>ä¸åŒæ­¥é‡Šæ”¾ï¼š</strong>ä¸åŒè§¦å‘å™¨åœ¨ä¸åŒæ—¶é’Ÿå‘¨æœŸè„±ç¦»å¤ä½ï¼Œå¯¼è‡´çŠ¶æ€æœºè¿›å…¥éæ³•çŠ¶æ€</li>
                    <li><strong>æœ€ä½³å®è·µï¼š</strong>å¤ä½ä¿¡å·å¯ä»¥å¼‚æ­¥ç½®ä½ï¼ˆç«‹å³å“åº”ï¼‰ï¼Œä½†å¿…é¡»åŒæ­¥é‡Šæ”¾ï¼ˆå—æ—¶é’Ÿæ§åˆ¶ï¼‰</li>
                </ul>
            </div>

            <h4>6.4.2 å¤ä½åŒæ­¥å™¨è®¾è®¡</h4>
            <div class="code-block">
// å¼‚æ­¥å¤ä½åŒæ­¥é‡Šæ”¾ç”µè·¯
module ResetSync (
    input  wire clk,
    input  wire async_rst_n,   // å¼‚æ­¥å¤ä½è¾“å…¥ï¼ˆä½æœ‰æ•ˆï¼‰
    output wire sync_rst_n     // åŒæ­¥å¤ä½è¾“å‡ºï¼ˆä½æœ‰æ•ˆï¼‰
);

    reg [1:0] rst_sync_q;
    
    always @(posedge clk or negedge async_rst_n) begin
        if (!async_rst_n) begin
            rst_sync_q <= 2'b00;   // å¼‚æ­¥å¤ä½ç«‹å³ç”Ÿæ•ˆ
        end else begin
            rst_sync_q <= {rst_sync_q[0], 1'b1};  // åŒæ­¥é‡Šæ”¾
        end
    end
    
    assign sync_rst_n = rst_sync_q[1];

endmodule

// å¤ä½åŸŸåˆ’åˆ†ä¸ç®¡ç†
module ResetController #(
    parameter NUM_DOMAINS = 4
)(
    input wire clk_sys,
    input wire power_on_rst_n,      // ä¸Šç”µå¤ä½
    input wire soft_rst_n,          // è½¯ä»¶å¤ä½
    input wire wdt_rst_n,           // çœ‹é—¨ç‹—å¤ä½
    
    // å„æ—¶é’ŸåŸŸçš„æ—¶é’Ÿ
    input wire [NUM_DOMAINS-1:0] domain_clks,
    
    // å„åŸŸçš„å¤ä½è¾“å‡º
    output wire [NUM_DOMAINS-1:0] domain_rst_n
);

    // åˆå¹¶å¤ä½æº
    wire global_rst_n = power_on_rst_n & soft_rst_n & wdt_rst_n;
    
    // ä¸ºæ¯ä¸ªæ—¶é’ŸåŸŸç”ŸæˆåŒæ­¥å¤ä½
    genvar i;
    generate
        for (i = 0; i < NUM_DOMAINS; i = i + 1) begin : rst_sync_gen
            ResetSync u_rst_sync (
                .clk         (domain_clks[i]),
                .async_rst_n (global_rst_n),
                .sync_rst_n  (domain_rst_n[i])
            );
        end
    endgenerate

endmodule

// å¤ä½é¡ºåºæ§åˆ¶å™¨
module ResetSequencer (
    input wire clk,
    input wire rst_n,
    
    // æ¨¡å—å¤ä½è¾“å‡ºï¼ˆæŒ‰é¡ºåºé‡Šæ”¾ï¼‰
    output reg rst_pll_n,        // PLLå¤ä½
    output reg rst_mem_n,        // å†…å­˜æ§åˆ¶å™¨å¤ä½
    output reg rst_core_n,       // è®¡ç®—æ ¸å¿ƒå¤ä½
    output reg rst_periph_n      // å¤–è®¾å¤ä½
);

    // çŠ¶æ€æœºçŠ¶æ€
    localparam IDLE = 3'b000;
    localparam RST_PLL = 3'b001;
    localparam RST_MEM = 3'b010;
    localparam RST_CORE = 3'b011;
    localparam RST_PERIPH = 3'b100;
    localparam DONE = 3'b101;
    
    reg [2:0] state, next_state;
    reg [7:0] wait_cnt;
    
    // çŠ¶æ€æœº
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            wait_cnt <= 0;
        end else begin
            state <= next_state;
            if (state != next_state) begin
                wait_cnt <= 0;
            end else begin
                wait_cnt <= wait_cnt + 1;
            end
        end
    end
    
    // ä¸‹ä¸€çŠ¶æ€é€»è¾‘
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: next_state = RST_PLL;
            RST_PLL: if (wait_cnt >= 8'h10) next_state = RST_MEM;
            RST_MEM: if (wait_cnt >= 8'h20) next_state = RST_CORE;
            RST_CORE: if (wait_cnt >= 8'h10) next_state = RST_PERIPH;
            RST_PERIPH: if (wait_cnt >= 8'h08) next_state = DONE;
            DONE: next_state = DONE;
            default: next_state = IDLE;
        endcase
    end
    
    // å¤ä½è¾“å‡ºæ§åˆ¶
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rst_pll_n <= 1'b0;
            rst_mem_n <= 1'b0;
            rst_core_n <= 1'b0;
            rst_periph_n <= 1'b0;
        end else begin
            case (state)
                RST_PLL: rst_pll_n <= 1'b1;
                RST_MEM: rst_mem_n <= 1'b1;
                RST_CORE: rst_core_n <= 1'b1;
                RST_PERIPH: rst_periph_n <= 1'b1;
                default: begin
                    // ä¿æŒå½“å‰çŠ¶æ€
                end
            endcase
        end
    end

endmodule
            </div>

            <h4>6.4.3 å¤ä½è®¾è®¡æœ€ä½³å®è·µ</h4>
            <div class="info-box">
                <p><strong>å¤ä½è®¾è®¡å‡†åˆ™ï¼š</strong></p>
                <ul>
                    <li>ä½¿ç”¨å¼‚æ­¥å¤ä½åŒæ­¥é‡Šæ”¾ä½œä¸ºé»˜è®¤æ–¹æ¡ˆ</li>
                    <li>å¤ä½ä¿¡å·è¦ç»è¿‡æ—¶åºåˆ†æï¼Œæ»¡è¶³recoveryå’Œremovalæ—¶é—´</li>
                    <li>å¤§è§„æ¨¡è®¾è®¡éœ€è¦å¤ä½æ ‘ï¼ˆReset Treeï¼‰è¿›è¡Œæ‰‡å‡ºæ§åˆ¶</li>
                    <li>ä¸åŒåŠŸèƒ½æ¨¡å—å¯ä»¥æœ‰ç‹¬ç«‹çš„å¤ä½æ§åˆ¶</li>
                    <li>è€ƒè™‘éƒ¨åˆ†å¤ä½ï¼ˆPartial Resetï¼‰ä»¥é™ä½åŠŸè€—</li>
                    <li>å…³é”®å¯„å­˜å™¨éœ€è¦æ˜¾å¼å¤ä½ï¼Œéå…³é”®è·¯å¾„å¯ä»¥ä¸å¤ä½</li>
                </ul>
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  6.4</h4>
                <div class="question">
                    <p><strong>é¢˜ç›®ï¼š</strong>è®¾è®¡ä¸€ä¸ªæ”¯æŒå¤šç§å¤ä½æºçš„å¤ä½ç®¡ç†å™¨ï¼Œè¦æ±‚ï¼š
                    1) æ”¯æŒä¸Šç”µå¤ä½ã€è½¯ä»¶å¤ä½ã€çœ‹é—¨ç‹—å¤ä½
                    2) å®ç°å¤ä½ä¼˜å…ˆçº§ç®¡ç†
                    3) æä¾›å¤ä½çŠ¶æ€å¯„å­˜å™¨ä¾›è½¯ä»¶æŸ¥è¯¢</p>
                    <details class="hint">
                        <summary>ğŸ’¡ æç¤º</summary>
                        <p>æ€è€ƒæ–¹å‘ï¼šä¸åŒå¤ä½æºæœ‰ä¸åŒä¼˜å…ˆçº§ï¼ˆä¸Šç”µå¤ä½>çœ‹é—¨ç‹—>è½¯ä»¶å¤ä½ï¼‰ã€‚ä½¿ç”¨çŠ¶æ€æœºç®¡ç†å¤ä½åºåˆ—ã€‚å¤ä½çŠ¶æ€éœ€è¦ä¿å­˜ä»¥ä¾›è°ƒè¯•ã€‚è€ƒè™‘å¼‚æ­¥å¤ä½åŒæ­¥é‡Šæ”¾çš„æœ€ä½³å®è·µã€‚</p>
                    </details>
                    <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                    <div class="answer">
                        <div class="code-block">
module ResetManager (
    input wire clk,
    input wire por_n,           // Power-on reset (highest priority)
    input wire soft_rst_req,    // Software reset request
    input wire wdt_rst_n,       // Watchdog reset
    
    // APBæ¥å£ç”¨äºçŠ¶æ€æŸ¥è¯¢
    input wire psel,
    input wire penable,
    input wire pwrite,
    input wire [7:0] paddr,
    input wire [31:0] pwdata,
    output reg [31:0] prdata,
    
    // å¤ä½è¾“å‡º
    output wire sys_rst_n
);

    // å¤ä½çŠ¶æ€å¯„å­˜å™¨
    reg [2:0] rst_source;  // è®°å½•å¤ä½æº
    reg soft_rst_pending;
    
    // å¤ä½æºç¼–ç 
    localparam RST_POR = 3'b001;
    localparam RST_SOFT = 3'b010;
    localparam RST_WDT = 3'b100;
    
    // è½¯ä»¶å¤ä½è„‰å†²ç”Ÿæˆ
    reg soft_rst_req_d1;
    wire soft_rst_pulse = soft_rst_req && !soft_rst_req_d1;
    
    always @(posedge clk or negedge por_n) begin
        if (!por_n) begin
            soft_rst_req_d1 <= 1'b0;
            soft_rst_pending <= 1'b0;
            rst_source <= RST_POR;
        end else begin
            soft_rst_req_d1 <= soft_rst_req;
            
            // è½¯ä»¶å¤ä½è¯·æ±‚é”å­˜
            if (soft_rst_pulse) begin
                soft_rst_pending <= 1'b1;
            end else if (!sys_rst_n) begin
                soft_rst_pending <= 1'b0;
            end
            
            // å¤ä½æºè®°å½•ï¼ˆä¼˜å…ˆçº§ï¼šPOR > WDT > SOFTï¼‰
            if (!por_n) begin
                rst_source <= RST_POR;
            end else if (!wdt_rst_n) begin
                rst_source <= RST_WDT;
            end else if (soft_rst_pending) begin
                rst_source <= RST_SOFT;
            end
        end
    end
    
    // å¤ä½è¾“å‡ºç”Ÿæˆ
    wire rst_combined = por_n & wdt_rst_n & !soft_rst_pending;
    
    // å¼‚æ­¥å¤ä½åŒæ­¥é‡Šæ”¾
    ResetSync u_rst_sync (
        .clk         (clk),
        .async_rst_n (rst_combined),
        .sync_rst_n  (sys_rst_n)
    );
    
    // APBè¯»æ“ä½œ
    always @(posedge clk or negedge por_n) begin
        if (!por_n) begin
            prdata <= 32'h0;
        end else if (psel && !pwrite && penable) begin
            case (paddr[7:0])
                8'h00: prdata <= {29'h0, rst_source};  // å¤ä½æºçŠ¶æ€
                8'h04: prdata <= {31'h0, sys_rst_n};   // å½“å‰å¤ä½çŠ¶æ€
                default: prdata <= 32'h0;
            endcase
        end
    end

endmodule
                        </div>
                    </div>
                </div>
            </div>

            <h3>6.5 ä½åŠŸè€—è®¾è®¡</h3>
            
            <p>NPUçš„åŠŸè€—ä¼˜åŒ–æ˜¯å…³é”®è®¾è®¡ç›®æ ‡ï¼Œéœ€è¦ä»æ¶æ„åˆ°å®ç°å„ä¸ªå±‚é¢è¿›è¡Œä¼˜åŒ–ã€‚</p>

            <h4>6.5.1 æ—¶é’Ÿé—¨æ§ï¼ˆClock Gatingï¼‰</h4>
            <div class="code-block">
// ç»†ç²’åº¦æ—¶é’Ÿé—¨æ§å®ç°
module ClockGatingCell (
    input  wire clk,
    input  wire enable,
    input  wire test_en,  // DFTæµ‹è¯•ä½¿èƒ½
    output wire gclk      // é—¨æ§åçš„æ—¶é’Ÿ
);

    reg enable_latch;
    
    // ä½ç”µå¹³é”å­˜å™¨ï¼Œé˜²æ­¢æ¯›åˆº
    always @(clk or enable or test_en) begin
        if (!clk) begin
            enable_latch <= enable | test_en;
        end
    end
    
    // ANDé—¨ç”Ÿæˆé—¨æ§æ—¶é’Ÿ
    assign gclk = clk & enable_latch;

endmodule

// MACé˜µåˆ—çš„å±‚æ¬¡åŒ–æ—¶é’Ÿé—¨æ§
module MACArrayClockGated #(
    parameter ARRAY_SIZE = 16,
    parameter DATA_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    input wire array_enable,
    input wire [ARRAY_SIZE-1:0] row_enable,
    input wire [ARRAY_SIZE-1:0] col_enable,
    
    // æ•°æ®æ¥å£
    input wire [DATA_WIDTH-1:0] act_in [ARRAY_SIZE-1:0],
    input wire [DATA_WIDTH-1:0] weight_in [ARRAY_SIZE-1:0][ARRAY_SIZE-1:0],
    output wire [31:0] acc_out [ARRAY_SIZE-1:0][ARRAY_SIZE-1:0]
);

    // å±‚æ¬¡åŒ–æ—¶é’Ÿé—¨æ§
    wire array_gclk;
    wire [ARRAY_SIZE-1:0] row_gclk;
    
    // é¡¶å±‚æ—¶é’Ÿé—¨æ§
    ClockGatingCell u_array_cg (
        .clk     (clk),
        .enable  (array_enable),
        .test_en (1'b0),
        .gclk    (array_gclk)
    );
    
    // è¡Œçº§æ—¶é’Ÿé—¨æ§
    genvar i, j;
    generate
        for (i = 0; i < ARRAY_SIZE; i = i + 1) begin : row_cg_gen
            ClockGatingCell u_row_cg (
                .clk     (array_gclk),
                .enable  (row_enable[i]),
                .test_en (1'b0),
                .gclk    (row_gclk[i])
            );
            
            // MACå•å…ƒå®ä¾‹åŒ–
            for (j = 0; j < ARRAY_SIZE; j = j + 1) begin : mac_gen
                wire mac_enable = row_enable[i] & col_enable[j];
                wire mac_gclk;
                
                // å•å…ƒçº§æ—¶é’Ÿé—¨æ§ï¼ˆå¯é€‰ï¼‰
                ClockGatingCell u_mac_cg (
                    .clk     (row_gclk[i]),
                    .enable  (col_enable[j]),
                    .test_en (1'b0),
                    .gclk    (mac_gclk)
                );
                
                // MACå•å…ƒ
                MACUnit #(.DATA_WIDTH(DATA_WIDTH)) u_mac (
                    .clk     (mac_gclk),
                    .rst_n   (rst_n),
                    .enable  (1'b1),  // æ—¶é’Ÿå·²é—¨æ§
                    .a_in    (act_in[i]),
                    .b_in    (weight_in[i][j]),
                    .acc_out (acc_out[i][j])
                );
            end
        end
    endgenerate

endmodule
            </div>

            <div class="info-box">
                <p><strong>æ—¶é’Ÿé—¨æ§çš„åŠŸè€—èŠ‚çœé‡åŒ–åˆ†æï¼š</strong></p>
                <p>ä»¥ä¸€ä¸ª32ä½å¯„å­˜å™¨ä¸ºä¾‹ï¼Œå‡è®¾ï¼š</p>
                <ul>
                    <li>æ—¶é’Ÿé¢‘ç‡ï¼š1GHz</li>
                    <li>å¯„å­˜å™¨ç¿»è½¬åŠŸè€—ï¼š0.5pJ/bit/cycle</li>
                    <li>æ—¶é’Ÿæ ‘åŠŸè€—ï¼š0.2pJ/bit/cycle</li>
                    <li>æ•°æ®å˜åŒ–ç‡ï¼š10%ï¼ˆ90%æ—¶é—´æ•°æ®ä¸å˜ï¼‰</li>
                </ul>
                <p><strong>ä¸ä½¿ç”¨æ—¶é’Ÿé—¨æ§ï¼š</strong></p>
                <ul>
                    <li>åŠ¨æ€åŠŸè€— = (0.5 + 0.2) Ã— 32 Ã— 1G = 22.4mW</li>
                </ul>
                <p><strong>ä½¿ç”¨æ—¶é’Ÿé—¨æ§åï¼š</strong></p>
                <ul>
                    <li>æ—¶é’Ÿæ ‘åŠŸè€—é™ä¸º10%ï¼š0.2 Ã— 32 Ã— 1G Ã— 0.1 = 0.64mW</li>
                    <li>å¯„å­˜å™¨ç¿»è½¬åŠŸè€—ï¼š0.5 Ã— 32 Ã— 1G Ã— 0.1 = 1.6mW</li>
                    <li>æ€»åŠŸè€— = 0.64 + 1.6 = 2.24mW</li>
                    <li><strong>åŠŸè€—èŠ‚çœï¼š90%</strong></li>
                </ul>
                <p>å¯¹äºåŒ…å«æ•°åƒä¸ªå¯„å­˜å™¨çš„NPUè®¾è®¡ï¼Œæ—¶é’Ÿé—¨æ§å¯ä»¥èŠ‚çœæ•°ç“¦çš„åŠŸè€—ã€‚</p>
            </div>

            <h4>6.5.2 æ“ä½œæ•°éš”ç¦»ï¼ˆOperand Isolationï¼‰</h4>
            <div class="code-block">
// æ“ä½œæ•°éš”ç¦»å‡å°‘æ— æ•ˆç¿»è½¬
module MACWithIsolation #(
    parameter DATA_WIDTH = 8,
    parameter ACC_WIDTH = 32
)(
    input wire clk,
    input wire rst_n,
    input wire enable,
    
    input wire signed [DATA_WIDTH-1:0] a_in,
    input wire signed [DATA_WIDTH-1:0] b_in,
    output reg signed [ACC_WIDTH-1:0] acc_out
);

    // æ“ä½œæ•°éš”ç¦»
    wire signed [DATA_WIDTH-1:0] a_isolated;
    wire signed [DATA_WIDTH-1:0] b_isolated;
    
    // å½“ä¸ä½¿èƒ½æ—¶ï¼Œå°†è¾“å…¥ç½®é›¶ï¼Œå‡å°‘ä¹˜æ³•å™¨å†…éƒ¨ç¿»è½¬
    assign a_isolated = enable ? a_in : {DATA_WIDTH{1'b0}};
    assign b_isolated = enable ? b_in : {DATA_WIDTH{1'b0}};
    
    // MACè¿ç®—
    wire signed [2*DATA_WIDTH-1:0] mult_result;
    assign mult_result = a_isolated * b_isolated;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            acc_out <= {ACC_WIDTH{1'b0}};
        end else if (enable) begin
            acc_out <= acc_out + {{(ACC_WIDTH-2*DATA_WIDTH){mult_result[2*DATA_WIDTH-1]}}, mult_result};
        end
        // ä¸ä½¿èƒ½æ—¶ä¿æŒåŸå€¼ï¼Œæ— éœ€elseåˆ†æ”¯
    end

endmodule
            </div>

            <h4>6.5.3 åŠ¨æ€ç”µå‹é¢‘ç‡è°ƒèŠ‚ï¼ˆDVFSï¼‰</h4>
            <div class="code-block">
// DVFSæ§åˆ¶å™¨
module DVFSController (
    input wire clk,
    input wire rst_n,
    
    // æ€§èƒ½ç›‘æ§è¾“å…¥
    input wire [31:0] workload,      // å½“å‰è´Ÿè½½
    input wire [31:0] deadline,      // æˆªæ­¢æ—¶é—´
    
    // ç”µå‹é¢‘ç‡æ§åˆ¶è¾“å‡º
    output reg [2:0] vdd_level,      // ç”µå‹ç­‰çº§
    output reg [2:0] freq_level,     // é¢‘ç‡ç­‰çº§
    output reg dvfs_change_req       // å˜æ›´è¯·æ±‚
);

    // DVFSçŠ¶æ€
    localparam DVFS_LOW = 3'b000;    // 0.8V, 200MHz
    localparam DVFS_MID = 3'b001;    // 0.9V, 400MHz
    localparam DVFS_HIGH = 3'b010;   // 1.0V, 600MHz
    localparam DVFS_TURBO = 3'b011;  // 1.1V, 800MHz
    
    reg [2:0] current_level;
    reg [2:0] target_level;
    reg [15:0] change_delay_cnt;
    
    // è´Ÿè½½è¯„ä¼°
    wire high_load = (workload > 32'h8000_0000);
    wire mid_load = (workload > 32'h4000_0000) && !high_load;
    wire low_load = (workload <= 32'h4000_0000);
    
    // ç›®æ ‡ç­‰çº§å†³ç­–
    always @(*) begin
        if (high_load && (deadline < 32'h0000_1000)) begin
            target_level = DVFS_TURBO;
        end else if (high_load) begin
            target_level = DVFS_HIGH;
        end else if (mid_load) begin
            target_level = DVFS_MID;
        end else begin
            target_level = DVFS_LOW;
        end
    end
    
    // DVFSçŠ¶æ€æœº
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_level <= DVFS_LOW;
            vdd_level <= DVFS_LOW;
            freq_level <= DVFS_LOW;
            dvfs_change_req <= 1'b0;
            change_delay_cnt <= 16'h0;
        end else begin
            if (current_level != target_level) begin
                if (change_delay_cnt == 16'h0) begin
                    // å‘èµ·DVFSå˜æ›´
                    dvfs_change_req <= 1'b1;
                    change_delay_cnt <= 16'hFFFF;
                    
                    // ç”µå‹ä¼˜å…ˆäºé¢‘ç‡è°ƒæ•´
                    if (target_level > current_level) begin
                        vdd_level <= target_level;  // å…ˆå‡å‹
                    end else begin
                        freq_level <= target_level; // å…ˆé™é¢‘
                    end
                end else if (change_delay_cnt == 16'h8000) begin
                    // å®Œæˆç¬¬äºŒæ­¥è°ƒæ•´
                    if (target_level > current_level) begin
                        freq_level <= target_level; // åå‡é¢‘
                    end else begin
                        vdd_level <= target_level;  // åé™å‹
                    end
                    current_level <= target_level;
                end else if (change_delay_cnt == 16'h0001) begin
                    dvfs_change_req <= 1'b0;
                end
                
                if (change_delay_cnt > 0) begin
                    change_delay_cnt <= change_delay_cnt - 1;
                end
            end
        end
    end

endmodule
            </div>

            <h4>6.5.4 åŠŸè€—ä¼˜åŒ–æŠ€æœ¯æ€»ç»“</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>æŠ€æœ¯</th>
                            <th>åŠŸè€—èŠ‚çœ</th>
                            <th>å®ç°å¤æ‚åº¦</th>
                            <th>é€‚ç”¨åœºæ™¯</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>æ—¶é’Ÿé—¨æ§</td>
                            <td>20-40%</td>
                            <td>ä½</td>
                            <td>æ‰€æœ‰æ¨¡å—</td>
                        </tr>
                        <tr>
                            <td>æ“ä½œæ•°éš”ç¦»</td>
                            <td>5-15%</td>
                            <td>ä½</td>
                            <td>ç®—æœ¯å•å…ƒ</td>
                        </tr>
                        <tr>
                            <td>å¤šé˜ˆå€¼ç”µå‹</td>
                            <td>10-20%</td>
                            <td>ä¸­</td>
                            <td>å…³é”®/éå…³é”®è·¯å¾„</td>
                        </tr>
                        <tr>
                            <td>ç”µæºé—¨æ§</td>
                            <td>50-90%</td>
                            <td>é«˜</td>
                            <td>ç©ºé—²æ¨¡å—</td>
                        </tr>
                        <tr>
                            <td>DVFS</td>
                            <td>30-60%</td>
                            <td>é«˜</td>
                            <td>ç³»ç»Ÿçº§</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  6.5</h4>
                <div class="question">
                    <p><strong>é¢˜ç›®ï¼š</strong>è®¾è®¡ä¸€ä¸ªæ”¯æŒå¤šçº§ç”µæºé—¨æ§çš„NPUè®¡ç®—æ ¸å¿ƒï¼Œè¦æ±‚ï¼š
                    1) æ”¯æŒæ ¸å¿ƒçº§ã€ç°‡çº§ã€å•å…ƒçº§ä¸‰çº§ç”µæºé—¨æ§
                    2) å®ç°ç”µæºå¼€å…³æ—¶åºæ§åˆ¶
                    3) å¤„ç†éš”ç¦»å’ŒçŠ¶æ€ä¿æŒ</p>
                    <details class="hint">
                        <summary>ğŸ’¡ æç¤º</summary>
                        <p>æ€è€ƒæ–¹å‘ï¼šç”µæºé—¨æ§éœ€è¦åˆ†å±‚æ¬¡å…³é—­å’Œæ‰“å¼€ï¼ˆå…ˆå…³å°å•å…ƒå†å…³å¤§å•å…ƒï¼‰ã€‚ä½¿ç”¨éš”ç¦»å•å…ƒé˜²æ­¢æ¼ç”µæµã€‚çŠ¶æ€ä¿æŒéœ€è¦ç‰¹æ®Šçš„ä¿æŒå¯„å­˜å™¨ã€‚æ³¨æ„ç”µæºå¼€å…³çš„æ—¶åºæ§åˆ¶å’Œrush currentã€‚</p>
                    </details>
                    <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                    <div class="answer">
                        <div class="code-block">
module PowerGatedNPUCore #(
    parameter NUM_CLUSTERS = 4,
    parameter UNITS_PER_CLUSTER = 16
)(
    input wire clk,
    input wire rst_n,
    
    // ç”µæºæ§åˆ¶
    input wire core_power_req,
    input wire [NUM_CLUSTERS-1:0] cluster_power_req,
    input wire [NUM_CLUSTERS-1:0][UNITS_PER_CLUSTER-1:0] unit_power_req,
    
    // ç”µæºçŠ¶æ€
    output reg core_powered,
    output reg [NUM_CLUSTERS-1:0] cluster_powered,
    output reg [NUM_CLUSTERS-1:0][UNITS_PER_CLUSTER-1:0] unit_powered
);

    // ç”µæºå¼€å…³æ§åˆ¶ä¿¡å·
    reg core_sleep_n;
    reg core_iso_n;
    reg core_ret_n;
    
    reg [NUM_CLUSTERS-1:0] cluster_sleep_n;
    reg [NUM_CLUSTERS-1:0] cluster_iso_n;
    reg [NUM_CLUSTERS-1:0] cluster_ret_n;
    
    // ç”µæºæ—¶åºçŠ¶æ€æœº
    localparam PSM_OFF = 3'b000;
    localparam PSM_ISO_ON = 3'b001;
    localparam PSM_RET_ON = 3'b010;
    localparam PSM_PWR_ON = 3'b011;
    localparam PSM_ACTIVE = 3'b100;
    localparam PSM_PWR_OFF = 3'b101;
    localparam PSM_RET_OFF = 3'b110;
    localparam PSM_ISO_OFF = 3'b111;
    
    reg [2:0] core_psm_state;
    reg [7:0] core_psm_timer;
    
    // æ ¸å¿ƒçº§ç”µæºæ§åˆ¶çŠ¶æ€æœº
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            core_psm_state <= PSM_OFF;
            core_psm_timer <= 8'h0;
            core_sleep_n <= 1'b0;
            core_iso_n <= 1'b0;
            core_ret_n <= 1'b0;
            core_powered <= 1'b0;
        end else begin
            case (core_psm_state)
                PSM_OFF: begin
                    if (core_power_req) begin
                        core_psm_state <= PSM_ISO_ON;
                        core_iso_n <= 1'b1;  // å…ˆå¼€å¯éš”ç¦»
                        core_psm_timer <= 8'h10;
                    end
                end
                
                PSM_ISO_ON: begin
                    if (core_psm_timer == 0) begin
                        core_psm_state <= PSM_RET_ON;
                        core_ret_n <= 1'b1;  // å¼€å¯çŠ¶æ€ä¿æŒ
                        core_psm_timer <= 8'h10;
                    end else begin
                        core_psm_timer <= core_psm_timer - 1;
                    end
                end
                
                PSM_RET_ON: begin
                    if (core_psm_timer == 0) begin
                        core_psm_state <= PSM_PWR_ON;
                        core_sleep_n <= 1'b1;  // å¼€å¯ç”µæº
                        core_psm_timer <= 8'h40;  // æ›´é•¿çš„ç¨³å®šæ—¶é—´
                    end else begin
                        core_psm_timer <= core_psm_timer - 1;
                    end
                end
                
                PSM_PWR_ON: begin
                    if (core_psm_timer == 0) begin
                        core_psm_state <= PSM_ACTIVE;
                        core_powered <= 1'b1;
                    end else begin
                        core_psm_timer <= core_psm_timer - 1;
                    end
                end
                
                PSM_ACTIVE: begin
                    if (!core_power_req) begin
                        core_psm_state <= PSM_PWR_OFF;
                        core_sleep_n <= 1'b0;  // å…³é—­ç”µæº
                        core_powered <= 1'b0;
                        core_psm_timer <= 8'h10;
                    end
                end
                
                PSM_PWR_OFF: begin
                    if (core_psm_timer == 0) begin
                        core_psm_state <= PSM_RET_OFF;
                        core_ret_n <= 1'b0;  // å…³é—­çŠ¶æ€ä¿æŒ
                        core_psm_timer <= 8'h10;
                    end else begin
                        core_psm_timer <= core_psm_timer - 1;
                    end
                end
                
                PSM_RET_OFF: begin
                    if (core_psm_timer == 0) begin
                        core_psm_state <= PSM_ISO_OFF;
                        core_iso_n <= 1'b0;  // å…³é—­éš”ç¦»
                        core_psm_timer <= 8'h10;
                    end else begin
                        core_psm_timer <= core_psm_timer - 1;
                    end
                end
                
                PSM_ISO_OFF: begin
                    if (core_psm_timer == 0) begin
                        core_psm_state <= PSM_OFF;
                    end else begin
                        core_psm_timer <= core_psm_timer - 1;
                    end
                end
            endcase
        end
    end
    
    // ç°‡çº§ç”µæºæ§åˆ¶ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    genvar i;
    generate
        for (i = 0; i < NUM_CLUSTERS; i = i + 1) begin : cluster_pg_gen
            always @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    cluster_powered[i] <= 1'b0;
                    cluster_sleep_n[i] <= 1'b0;
                    cluster_iso_n[i] <= 1'b0;
                    cluster_ret_n[i] <= 1'b0;
                end else begin
                    // åªæœ‰æ ¸å¿ƒä¸Šç”µæ—¶æ‰èƒ½æ§åˆ¶ç°‡
                    if (core_powered) begin
                        if (cluster_power_req[i] && !cluster_powered[i]) begin
                            // ç®€åŒ–çš„ä¸Šç”µåºåˆ—
                            cluster_iso_n[i] <= 1'b1;
                            #10 cluster_ret_n[i] <= 1'b1;
                            #10 cluster_sleep_n[i] <= 1'b1;
                            #40 cluster_powered[i] <= 1'b1;
                        end else if (!cluster_power_req[i] && cluster_powered[i]) begin
                            // ç®€åŒ–çš„ä¸‹ç”µåºåˆ—
                            cluster_powered[i] <= 1'b0;
                            cluster_sleep_n[i] <= 1'b0;
                            #10 cluster_ret_n[i] <= 1'b0;
                            #10 cluster_iso_n[i] <= 1'b0;
                        end
                    end else begin
                        cluster_powered[i] <= 1'b0;
                        cluster_sleep_n[i] <= 1'b0;
                        cluster_iso_n[i] <= 1'b0;
                        cluster_ret_n[i] <= 1'b0;
                    end
                end
            end
        end
    endgenerate

endmodule
                        </div>
                    </div>
                </div>
            </div>

            <h3>6.6 é¢ç§¯ä¼˜åŒ–</h3>
            
            <p>é¢ç§¯ä¼˜åŒ–å¯¹é™ä½èŠ¯ç‰‡æˆæœ¬è‡³å…³é‡è¦ã€‚NPUè®¾è®¡éœ€è¦åœ¨æ€§èƒ½ã€åŠŸè€—å’Œé¢ç§¯ä¹‹é—´æ‰¾åˆ°æœ€ä½³å¹³è¡¡ç‚¹ã€‚</p>

            <h4>6.6.1 èµ„æºå…±äº«æŠ€æœ¯</h4>
            <div class="code-block">
// ä¼˜åŒ–çš„æµæ°´çº¿å…±äº«ä¹˜æ³•å™¨ - Verilogç‰ˆæœ¬
module SharedMultiplier #(
    parameter DATA_WIDTH = 16,
    parameter NUM_USERS = 4,
    parameter PIPE_STAGES = 3  // æµæ°´çº¿çº§æ•°
)(
    input wire clk,
    input wire rst_n,
    
    // è¯·æ±‚æ¥å£
    input wire [NUM_USERS-1:0] req,
    input wire [DATA_WIDTH-1:0] a_in [NUM_USERS-1:0],
    input wire [DATA_WIDTH-1:0] b_in [NUM_USERS-1:0],
    
    // å“åº”æ¥å£
    output reg [NUM_USERS-1:0] ack,
    output reg [2*DATA_WIDTH-1:0] result_out [NUM_USERS-1:0]
);

    // æµæ°´çº¿é˜¶æ®µå®šä¹‰
    // Stage 0: ä»²è£å’Œè¾“å…¥é€‰æ‹©
    // Stage 1: ä¹˜æ³•ç¬¬ä¸€çº§
    // Stage 2: ä¹˜æ³•ç¬¬äºŒçº§
    // Stage 3: è¾“å‡ºåˆ†å‘
    
    // ä»²è£å™¨çŠ¶æ€
    reg [$clog2(NUM_USERS)-1:0] grant_id;
    reg req_valid;
    
    // è½®è¯¢ä»²è£å™¨
    reg [$clog2(NUM_USERS)-1:0] rr_pointer;
    
    // æµæ°´çº¿å¯„å­˜å™¨
    reg [DATA_WIDTH-1:0] pipe_a [PIPE_STAGES:0];
    reg [DATA_WIDTH-1:0] pipe_b [PIPE_STAGES:0];
    reg [$clog2(NUM_USERS)-1:0] pipe_id [PIPE_STAGES:0];
    reg pipe_valid [PIPE_STAGES:0];
    
    // Stage 0: ä»²è£é€»è¾‘ï¼ˆæ”¹è¿›çš„è½®è¯¢ä»²è£ï¼‰
    integer i;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rr_pointer <= 0;
            req_valid <= 1'b0;
            grant_id <= 0;
        end else begin
            req_valid <= 1'b0;
            
            // è½®è¯¢æŸ¥æ‰¾ä¸‹ä¸€ä¸ªè¯·æ±‚
            for (i = 0; i < NUM_USERS; i = i + 1) begin
                integer idx = (rr_pointer + i) % NUM_USERS;
                if (req[idx] && !req_valid) begin
                    grant_id <= idx;
                    req_valid <= 1'b1;
                    rr_pointer <= (idx + 1) % NUM_USERS;
                end
            end
        end
    end
    
    // Stage 0->1: è¾“å…¥å¯„å­˜
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pipe_a[0] <= 0;
            pipe_b[0] <= 0;
            pipe_id[0] <= 0;
            pipe_valid[0] <= 1'b0;
        end else begin
            if (req_valid) begin
                pipe_a[0] <= a_in[grant_id];
                pipe_b[0] <= b_in[grant_id];
                pipe_id[0] <= grant_id;
                pipe_valid[0] <= 1'b1;
            end else begin
                pipe_valid[0] <= 1'b0;
            end
        end
    end
    
    // æµæ°´çº¿ä¹˜æ³•å™¨ï¼ˆåˆ†ä¸ºä¸¤çº§ï¼‰
    reg [DATA_WIDTH-1:0] mult_a_reg, mult_b_reg;
    reg [DATA_WIDTH/2-1:0] partial_prod [3:0];
    reg [2*DATA_WIDTH-1:0] mult_result;
    
    // Stage 1: éƒ¨åˆ†ç§¯è®¡ç®—
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mult_a_reg <= 0;
            mult_b_reg <= 0;
            pipe_id[1] <= 0;
            pipe_valid[1] <= 1'b0;
            for (i = 0; i < 4; i = i + 1) begin
                partial_prod[i] <= 0;
            end
        end else begin
            mult_a_reg <= pipe_a[0];
            mult_b_reg <= pipe_b[0];
            pipe_id[1] <= pipe_id[0];
            pipe_valid[1] <= pipe_valid[0];
            
            // è®¡ç®—éƒ¨åˆ†ç§¯ï¼ˆBoothç¼–ç ä¼˜åŒ–ï¼‰
            partial_prod[0] <= pipe_a[0][DATA_WIDTH/2-1:0] * pipe_b[0][DATA_WIDTH/2-1:0];
            partial_prod[1] <= pipe_a[0][DATA_WIDTH-1:DATA_WIDTH/2] * pipe_b[0][DATA_WIDTH/2-1:0];
            partial_prod[2] <= pipe_a[0][DATA_WIDTH/2-1:0] * pipe_b[0][DATA_WIDTH-1:DATA_WIDTH/2];
            partial_prod[3] <= pipe_a[0][DATA_WIDTH-1:DATA_WIDTH/2] * pipe_b[0][DATA_WIDTH-1:DATA_WIDTH/2];
        end
    end
    
    // Stage 2: æœ€ç»ˆç´¯åŠ 
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            mult_result <= 0;
            pipe_id[2] <= 0;
            pipe_valid[2] <= 1'b0;
        end else begin
            pipe_id[2] <= pipe_id[1];
            pipe_valid[2] <= pipe_valid[1];
            
            // Wallaceæ ‘ç´¯åŠ éƒ¨åˆ†ç§¯
            mult_result <= {partial_prod[3], {(DATA_WIDTH/2){1'b0}}} +
                          ({partial_prod[2], {(DATA_WIDTH/2){1'b0}}} >> (DATA_WIDTH/2)) +
                          ({partial_prod[1], {(DATA_WIDTH/2){1'b0}}} >> (DATA_WIDTH/2)) +
                          partial_prod[0];
        end
    end
    
    // Stage 3: è¾“å‡ºåˆ†å‘
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            ack <= 0;
            for (i = 0; i < NUM_USERS; i = i + 1) begin
                result_out[i] <= 0;
            end
        end else begin
            // æ¸…é™¤ä¹‹å‰çš„åº”ç­”
            ack <= 0;
            
            // è®¾ç½®æ–°çš„åº”ç­”
            if (pipe_valid[2]) begin
                ack[pipe_id[2]] <= 1'b1;
                result_out[pipe_id[2]] <= mult_result;
            end
        end
    end

endmodule
            </div>
            
            <div class="code-block">
// Chiselç‰ˆæœ¬çš„æµæ°´çº¿å…±äº«ä¹˜æ³•å™¨
import chisel3._
import chisel3.util._

class SharedMultiplier(dataWidth: Int = 16, numUsers: Int = 4, pipeStages: Int = 3) extends Module {
  val io = IO(new Bundle {
    // è¯·æ±‚æ¥å£
    val req = Input(Vec(numUsers, Bool()))
    val aIn = Input(Vec(numUsers, UInt(dataWidth.W)))
    val bIn = Input(Vec(numUsers, UInt(dataWidth.W)))
    
    // å“åº”æ¥å£
    val ack = Output(Vec(numUsers, Bool()))
    val resultOut = Output(Vec(numUsers, UInt((2*dataWidth).W)))
  })
  
  // è½®è¯¢ä»²è£å™¨
  val rrPointer = RegInit(0.U(log2Ceil(numUsers).W))
  val grantId = Wire(UInt(log2Ceil(numUsers).W))
  val reqValid = Wire(Bool())
  
  // ä»²è£é€»è¾‘
  val arbiter = Module(new RoundRobinArbiter(numUsers))
  arbiter.io.req := io.req
  grantId := arbiter.io.grant
  reqValid := arbiter.io.valid
  
  // æµæ°´çº¿å¯„å­˜å™¨
  val pipeA = RegInit(VecInit(Seq.fill(pipeStages+1)(0.U(dataWidth.W))))
  val pipeB = RegInit(VecInit(Seq.fill(pipeStages+1)(0.U(dataWidth.W))))
  val pipeId = RegInit(VecInit(Seq.fill(pipeStages+1)(0.U(log2Ceil(numUsers).W))))
  val pipeValid = RegInit(VecInit(Seq.fill(pipeStages+1)(false.B)))
  
  // Stage 0->1: è¾“å…¥å¯„å­˜
  when (reqValid) {
    pipeA(0) := io.aIn(grantId)
    pipeB(0) := io.bIn(grantId)
    pipeId(0) := grantId
    pipeValid(0) := true.B
  }.otherwise {
    pipeValid(0) := false.B
  }
  
  // æµæ°´çº¿ä¼ æ’­
  for (i <- 1 to pipeStages) {
    pipeA(i) := pipeA(i-1)
    pipeB(i) := pipeB(i-1)
    pipeId(i) := pipeId(i-1)
    pipeValid(i) := pipeValid(i-1)
  }
  
  // ä¹˜æ³•å™¨å®ä¾‹
  val mult = Module(new PipelinedMultiplier(dataWidth))
  mult.io.a := pipeA(0)
  mult.io.b := pipeB(0)
  mult.io.valid := pipeValid(0)
  
  // è¾“å‡ºåˆ†å‘
  io.ack := VecInit(Seq.fill(numUsers)(false.B))
  when (pipeValid(pipeStages)) {
    io.ack(pipeId(pipeStages)) := true.B
    io.resultOut(pipeId(pipeStages)) := mult.io.result
  }
}
            </div>
            
            <div class="code-block">
// ä¼˜åŒ–çš„æµæ°´çº¿å­˜å‚¨å™¨èµ„æºå…±äº« - Verilogç‰ˆæœ¬
module SharedMemoryWrapper #(
    parameter ADDR_WIDTH = 10,
    parameter DATA_WIDTH = 32,
    parameter PIPELINE_READ = 1  // è¯»æ“ä½œæµæ°´çº¿
)(
    input wire clk,
    input wire rst_n,
    
    // ç«¯å£Aï¼ˆè¯»å†™ï¼‰
    input wire a_en,
    input wire a_we,
    input wire [ADDR_WIDTH-1:0] a_addr,
    input wire [DATA_WIDTH-1:0] a_wdata,
    output reg [DATA_WIDTH-1:0] a_rdata,
    output reg a_ready,
    
    // ç«¯å£Bï¼ˆåªè¯»ï¼‰
    input wire b_en,
    input wire [ADDR_WIDTH-1:0] b_addr,
    output reg [DATA_WIDTH-1:0] b_rdata,
    output reg b_ready
);

    // å•ç«¯å£å­˜å‚¨å™¨
    reg [DATA_WIDTH-1:0] mem [(1<<ADDR_WIDTH)-1:0];
    
    // æµæ°´çº¿å¯„å­˜å™¨
    reg [ADDR_WIDTH-1:0] addr_pipe;
    reg [1:0] port_pipe;  // 0: none, 1: port A, 2: port B
    reg we_pipe;
    reg [DATA_WIDTH-1:0] wdata_pipe;
    
    // è¯·æ±‚ç¼“å†²ï¼ˆé¿å…è¯·æ±‚ä¸¢å¤±ï¼‰
    reg a_pending, b_pending;
    reg [ADDR_WIDTH-1:0] a_addr_buf, b_addr_buf;
    reg a_we_buf;
    reg [DATA_WIDTH-1:0] a_wdata_buf;
    
    // ä»²è£é€»è¾‘
    wire a_grant = (a_en || a_pending) && !b_pending;  // Aä¼˜å…ˆï¼Œé™¤éBåœ¨ç­‰å¾…
    wire b_grant = (b_en || b_pending) && !(a_en || a_pending);
    
    // Stage 1: åœ°å€å’Œæ§åˆ¶æµæ°´çº¿
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            addr_pipe <= 0;
            port_pipe <= 0;
            we_pipe <= 1'b0;
            wdata_pipe <= 0;
            a_pending <= 1'b0;
            b_pending <= 1'b0;
        end else begin
            // é»˜è®¤å€¼
            port_pipe <= 0;
            
            // å¤„ç†è¯·æ±‚
            if (a_grant) begin
                if (a_pending) begin
                    // ä½¿ç”¨ç¼“å†²çš„è¯·æ±‚
                    addr_pipe <= a_addr_buf;
                    we_pipe <= a_we_buf;
                    wdata_pipe <= a_wdata_buf;
                    a_pending <= 1'b0;
                end else begin
                    // ä½¿ç”¨å½“å‰è¯·æ±‚
                    addr_pipe <= a_addr;
                    we_pipe <= a_we;
                    wdata_pipe <= a_wdata;
                end
                port_pipe <= 1;
            end else if (b_grant) begin
                if (b_pending) begin
                    addr_pipe <= b_addr_buf;
                    b_pending <= 1'b0;
                end else begin
                    addr_pipe <= b_addr;
                end
                we_pipe <= 1'b0;
                port_pipe <= 2;
            end
            
            // ç¼“å†²æœªæœåŠ¡çš„è¯·æ±‚
            if (a_en && !a_grant && !a_pending) begin
                a_pending <= 1'b1;
                a_addr_buf <= a_addr;
                a_we_buf <= a_we;
                a_wdata_buf <= a_wdata;
            end
            
            if (b_en && !b_grant && !b_pending) begin
                b_pending <= 1'b1;
                b_addr_buf <= b_addr;
            end
        end
    end
    
    // Stage 2: å­˜å‚¨å™¨è®¿é—®
    reg [DATA_WIDTH-1:0] read_data;
    reg [1:0] port_out;
    
    always @(posedge clk) begin
        if (we_pipe) begin
            mem[addr_pipe] <= wdata_pipe;
        end
        read_data <= mem[addr_pipe];
        port_out <= port_pipe;
    end
    
    // Stage 3: è¾“å‡ºåˆ†å‘
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            a_ready <= 1'b0;
            b_ready <= 1'b0;
            a_rdata <= 0;
            b_rdata <= 0;
        end else begin
            // æ¸…é™¤ä¹‹å‰çš„ready
            a_ready <= 1'b0;
            b_ready <= 1'b0;
            
            // æ ¹æ®ç«¯å£åˆ†å‘ç»“æœ
            case (port_out)
                1: begin  // Port A
                    a_ready <= 1'b1;
                    if (!we_pipe) begin  // åªåœ¨è¯»æ“ä½œæ—¶æ›´æ–°
                        a_rdata <= read_data;
                    end
                end
                
                2: begin  // Port B
                    b_ready <= 1'b1;
                    b_rdata <= read_data;
                end
            endcase
        end
    end

endmodule
            </div>
            
            <div class="code-block">
// Chiselç‰ˆæœ¬çš„æµæ°´çº¿å­˜å‚¨å™¨èµ„æºå…±äº«
import chisel3._
import chisel3.util._

class SharedMemoryWrapper(addrWidth: Int = 10, dataWidth: Int = 32) extends Module {
  val io = IO(new Bundle {
    // ç«¯å£Aï¼ˆè¯»å†™ï¼‰
    val aEn = Input(Bool())
    val aWe = Input(Bool())
    val aAddr = Input(UInt(addrWidth.W))
    val aWdata = Input(UInt(dataWidth.W))
    val aRdata = Output(UInt(dataWidth.W))
    val aReady = Output(Bool())
    
    // ç«¯å£Bï¼ˆåªè¯»ï¼‰
    val bEn = Input(Bool())
    val bAddr = Input(UInt(addrWidth.W))
    val bRdata = Output(UInt(dataWidth.W))
    val bReady = Output(Bool())
  })
  
  // å­˜å‚¨å™¨
  val mem = SyncReadMem(1 << addrWidth, UInt(dataWidth.W))
  
  // è¯·æ±‚ç¼“å†²
  val aPending = RegInit(false.B)
  val bPending = RegInit(false.B)
  val aAddrBuf = Reg(UInt(addrWidth.W))
  val aWeBuf = Reg(Bool())
  val aWdataBuf = Reg(UInt(dataWidth.W))
  val bAddrBuf = Reg(UInt(addrWidth.W))
  
  // ä»²è£
  val aGrant = (io.aEn || aPending) && !bPending
  val bGrant = (io.bEn || bPending) && !(io.aEn || aPending)
  
  // æµæ°´çº¿å¯„å­˜å™¨
  val addrPipe = Reg(UInt(addrWidth.W))
  val portPipe = Reg(UInt(2.W))
  val wePipe = Reg(Bool())
  val wdataPipe = Reg(UInt(dataWidth.W))
  
  // Stage 1: ä»²è£å’Œåœ°å€æµæ°´çº¿
  when (aGrant) {
    when (aPending) {
      addrPipe := aAddrBuf
      wePipe := aWeBuf
      wdataPipe := aWdataBuf
      aPending := false.B
    }.otherwise {
      addrPipe := io.aAddr
      wePipe := io.aWe
      wdataPipe := io.aWdata
    }
    portPipe := 1.U
  }.elsewhen (bGrant) {
    addrPipe := Mux(bPending, bAddrBuf, io.bAddr)
    wePipe := false.B
    portPipe := 2.U
    bPending := false.B
  }.otherwise {
    portPipe := 0.U
  }
  
  // ç¼“å†²æœªæœåŠ¡è¯·æ±‚
  when (io.aEn && !aGrant && !aPending) {
    aPending := true.B
    aAddrBuf := io.aAddr
    aWeBuf := io.aWe
    aWdataBuf := io.aWdata
  }
  
  when (io.bEn && !bGrant && !bPending) {
    bPending := true.B
    bAddrBuf := io.bAddr
  }
  
  // Stage 2: å­˜å‚¨å™¨è®¿é—®
  val readData = mem.read(addrPipe)
  when (wePipe) {
    mem.write(addrPipe, wdataPipe)
  }
  val portOut = RegNext(portPipe)
  
  // Stage 3: è¾“å‡ºåˆ†å‘
  io.aReady := portOut === 1.U
  io.bReady := portOut === 2.U
  io.aRdata := Mux(io.aReady && !RegNext(wePipe), readData, 0.U)
  io.bRdata := Mux(io.bReady, readData, 0.U)
}
            </div>

            <h4>6.6.2 æ•°æ®è·¯å¾„ä¼˜åŒ–</h4>
            <div class="code-block">
// ä¼˜åŒ–çš„æµæ°´çº¿èåˆæ“ä½œ - Verilogç‰ˆæœ¬
module FusedOperation #(
    parameter DATA_WIDTH = 16
)(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire valid_in,
    
    // åŸå§‹æ“ä½œï¼šY = (A * B) + (C * D) + E
    input wire signed [DATA_WIDTH-1:0] a, b, c, d, e,
    output reg signed [DATA_WIDTH*2+1:0] y,
    output reg valid_out
);

    // ä¼˜åŒ–æ–¹æ¡ˆï¼š3çº§æµæ°´çº¿ï¼Œå…±äº«2ä¸ªä¹˜æ³•å™¨
    // Stage 1: è¾“å…¥å¯„å­˜å’Œä¹˜æ³•
    // Stage 2: éƒ¨åˆ†å’Œç´¯åŠ 
    // Stage 3: æœ€ç»ˆåŠ æ³•å’Œè¾“å‡º
    
    // æµæ°´çº¿å¯„å­˜å™¨
    reg signed [DATA_WIDTH-1:0] a_s1, b_s1, c_s1, d_s1, e_s1;
    reg signed [DATA_WIDTH-1:0] e_s2;
    reg valid_s1, valid_s2;
    
    // ä¹˜æ³•å™¨è¾“å‡º
    wire signed [DATA_WIDTH*2-1:0] mult1_out, mult2_out;
    
    // ç´¯åŠ å™¨
    reg signed [DATA_WIDTH*2:0] partial_sum;
    
    // Stage 1: è¾“å…¥å¯„å­˜
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            a_s1 <= 0;
            b_s1 <= 0;
            c_s1 <= 0;
            d_s1 <= 0;
            e_s1 <= 0;
            valid_s1 <= 1'b0;
        end else if (enable) begin
            if (valid_in) begin
                a_s1 <= a;
                b_s1 <= b;
                c_s1 <= c;
                d_s1 <= d;
                e_s1 <= e;
                valid_s1 <= 1'b1;
            end else begin
                valid_s1 <= 1'b0;
            end
        end
    end
    
    // å…±äº«ä¹˜æ³•å™¨ï¼ˆç»„åˆé€»è¾‘ï¼‰
    assign mult1_out = a_s1 * b_s1;
    assign mult2_out = c_s1 * d_s1;
    
    // Stage 2: éƒ¨åˆ†å’Œç´¯åŠ 
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            partial_sum <= 0;
            e_s2 <= 0;
            valid_s2 <= 1'b0;
        end else if (enable) begin
            if (valid_s1) begin
                // Wallaceæ ‘åŠ æ³•å™¨ç»“æ„
                partial_sum <= {{1{mult1_out[DATA_WIDTH*2-1]}}, mult1_out} + 
                              {{1{mult2_out[DATA_WIDTH*2-1]}}, mult2_out};
                e_s2 <= e_s1;
                valid_s2 <= 1'b1;
            end else begin
                valid_s2 <= 1'b0;
            end
        end
    end
    
    // Stage 3: æœ€ç»ˆåŠ æ³•
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            y <= 0;
            valid_out <= 1'b0;
        end else if (enable) begin
            if (valid_s2) begin
                y <= partial_sum + {{(DATA_WIDTH+2){e_s2[DATA_WIDTH-1]}}, e_s2};
                valid_out <= 1'b1;
            end else begin
                valid_out <= 1'b0;
            end
        end
    end

endmodule
            </div>
            
            <div class="code-block">
// Chiselç‰ˆæœ¬çš„æµæ°´çº¿èåˆæ“ä½œ
import chisel3._
import chisel3.util._

class FusedOperation(dataWidth: Int = 16) extends Module {
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val validIn = Input(Bool())
    val a = Input(SInt(dataWidth.W))
    val b = Input(SInt(dataWidth.W))
    val c = Input(SInt(dataWidth.W))
    val d = Input(SInt(dataWidth.W))
    val e = Input(SInt(dataWidth.W))
    val y = Output(SInt((dataWidth*2+2).W))
    val validOut = Output(Bool())
  })
  
  // æµæ°´çº¿å¯„å­˜å™¨
  val stage1 = RegEnable(new Bundle {
    val a = io.a
    val b = io.b
    val c = io.c
    val d = io.d
    val e = io.e
    val valid = io.validIn
  }, io.enable)
  
  // ä¹˜æ³•å™¨
  val mult1 = stage1.a * stage1.b
  val mult2 = stage1.c * stage1.d
  
  // Stage 2
  val stage2 = RegEnable(new Bundle {
    val partialSum = mult1 +& mult2  // +& ä¿ç•™è¿›ä½
    val e = stage1.e
    val valid = stage1.valid
  }, io.enable)
  
  // Stage 3
  val stage3 = RegEnable(new Bundle {
    val y = stage2.partialSum +& stage2.e.asSInt
    val valid = stage2.valid
  }, io.enable)
  
  io.y := stage3.y
  io.validOut := stage3.valid
}

// ä¼˜åŒ–çš„æµæ°´çº¿ä½å®½ä¼˜åŒ–MAC - Verilogç‰ˆæœ¬
module BitwidthOptimized #(
    parameter IN_WIDTH = 8,
    parameter WEIGHT_WIDTH = 8,
    parameter OUT_WIDTH = 24  // ä¼˜åŒ–åçš„ä½å®½
)(
    input wire clk,
    input wire rst_n,
    input wire enable,
    
    // 4ä¸ªè¾“å…¥çš„MAC
    input wire signed [IN_WIDTH-1:0] in0, in1, in2, in3,
    input wire signed [WEIGHT_WIDTH-1:0] w0, w1, w2, w3,
    output reg signed [OUT_WIDTH-1:0] out,
    output reg valid_out
);

    // æµæ°´çº¿å¯„å­˜å™¨
    reg signed [IN_WIDTH-1:0] in_reg [3:0];
    reg signed [WEIGHT_WIDTH-1:0] w_reg [3:0];
    reg valid_s1;
    
    // éƒ¨åˆ†ç§¯å¯„å­˜å™¨
    reg signed [IN_WIDTH+WEIGHT_WIDTH-1:0] p_reg [3:0];
    reg valid_s2;
    
    // Wallaceæ ‘çº§å¯„å­˜å™¨
    reg signed [IN_WIDTH+WEIGHT_WIDTH:0] sum01_reg, sum23_reg;
    reg valid_s3;
    
    // Stage 1: è¾“å…¥å¯„å­˜
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            in_reg[0] <= 0; in_reg[1] <= 0; in_reg[2] <= 0; in_reg[3] <= 0;
            w_reg[0] <= 0; w_reg[1] <= 0; w_reg[2] <= 0; w_reg[3] <= 0;
            valid_s1 <= 1'b0;
        end else if (enable) begin
            in_reg[0] <= in0; in_reg[1] <= in1; in_reg[2] <= in2; in_reg[3] <= in3;
            w_reg[0] <= w0; w_reg[1] <= w1; w_reg[2] <= w2; w_reg[3] <= w3;
            valid_s1 <= 1'b1;
        end else begin
            valid_s1 <= 1'b0;
        end
    end
    
    // Stage 2: ä¹˜æ³•å™¨ï¼ˆå¹¶è¡Œï¼‰
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            p_reg[0] <= 0; p_reg[1] <= 0; p_reg[2] <= 0; p_reg[3] <= 0;
            valid_s2 <= 1'b0;
        end else begin
            p_reg[0] <= in_reg[0] * w_reg[0];
            p_reg[1] <= in_reg[1] * w_reg[1];
            p_reg[2] <= in_reg[2] * w_reg[2];
            p_reg[3] <= in_reg[3] * w_reg[3];
            valid_s2 <= valid_s1;
        end
    end
    
    // Stage 3: Wallaceæ ‘ç¬¬ä¸€çº§
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sum01_reg <= 0;
            sum23_reg <= 0;
            valid_s3 <= 1'b0;
        end else begin
            sum01_reg <= p_reg[0] + p_reg[1];
            sum23_reg <= p_reg[2] + p_reg[3];
            valid_s3 <= valid_s2;
        end
    end
    
    // Stage 4: æœ€ç»ˆç´¯åŠ å’Œé¥±å’Œ
    wire signed [IN_WIDTH+WEIGHT_WIDTH+1:0] sum_all = sum01_reg + sum23_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            out <= 0;
            valid_out <= 1'b0;
        end else begin
            // é¥±å’Œé€»è¾‘
            if (sum_all > $signed({1'b0, {(OUT_WIDTH-1){1'b1}}})) begin
                out <= {1'b0, {(OUT_WIDTH-1){1'b1}}};  // æœ€å¤§æ­£å€¼
            end else if (sum_all < $signed({1'b1, {(OUT_WIDTH-1){1'b0}}})) begin
                out <= {1'b1, {(OUT_WIDTH-1){1'b0}}};  // æœ€å°è´Ÿå€¼
            end else begin
                out <= sum_all[OUT_WIDTH-1:0];
            end
            valid_out <= valid_s3;
        end
    end

endmodule
            </div>
            
            <div class="code-block">
// Chiselç‰ˆæœ¬çš„æµæ°´çº¿ä½å®½ä¼˜åŒ–MAC
import chisel3._
import chisel3.util._

class BitwidthOptimized(inWidth: Int = 8, weightWidth: Int = 8, outWidth: Int = 24) extends Module {
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val in = Input(Vec(4, SInt(inWidth.W)))
    val weights = Input(Vec(4, SInt(weightWidth.W)))
    val out = Output(SInt(outWidth.W))
    val validOut = Output(Bool())
  })
  
  // Stage 1: è¾“å…¥å¯„å­˜
  val inReg = RegEnable(io.in, io.enable)
  val wReg = RegEnable(io.weights, io.enable)
  val validS1 = RegEnable(io.enable, io.enable)
  
  // Stage 2: ä¹˜æ³•
  val products = Wire(Vec(4, SInt((inWidth + weightWidth).W)))
  for (i <- 0 until 4) {
    products(i) := RegNext(inReg(i) * wReg(i))
  }
  val validS2 = RegNext(validS1)
  
  // Stage 3: Wallaceæ ‘ç¬¬ä¸€çº§
  val sum01 = RegNext(products(0) +& products(1))
  val sum23 = RegNext(products(2) +& products(3))
  val validS3 = RegNext(validS2)
  
  // Stage 4: æœ€ç»ˆç´¯åŠ å’Œé¥±å’Œ
  val sumAll = sum01 +& sum23
  val maxVal = ((1L << (outWidth - 1)) - 1).S
  val minVal = (-(1L << (outWidth - 1))).S
  
  io.out := RegNext(MuxCase(sumAll(outWidth-1, 0).asSInt, Seq(
    (sumAll > maxVal) -> maxVal,
    (sumAll < minVal) -> minVal
  )))
  io.validOut := RegNext(validS3)
}
            </div>

            <h4>6.6.3 é¢ç§¯ä¼˜åŒ–æ£€æŸ¥æ¸…å•</h4>
            <div class="info-box">
                <p><strong>é¢ç§¯ä¼˜åŒ–ç­–ç•¥ï¼š</strong></p>
                <ul>
                    <li><strong>èµ„æºå…±äº«ï¼š</strong>
                        <ul>
                            <li>å…±äº«æ˜‚è´µçš„è¿ç®—å•å…ƒï¼ˆä¹˜æ³•å™¨ã€é™¤æ³•å™¨ï¼‰</li>
                            <li>æ—¶åˆ†å¤ç”¨å­˜å‚¨å™¨ç«¯å£</li>
                            <li>å…±äº«æ§åˆ¶é€»è¾‘</li>
                        </ul>
                    </li>
                    <li><strong>æ•°æ®è·¯å¾„ä¼˜åŒ–ï¼š</strong>
                        <ul>
                            <li>æ“ä½œèåˆå‡å°‘ä¸­é—´å¯„å­˜å™¨</li>
                            <li>ä½å®½ä¼˜åŒ–ï¼Œç§»é™¤å†—ä½™ä½</li>
                            <li>ä½¿ç”¨ç§»ä½ä»£æ›¿ä¹˜ä»¥2çš„å¹‚</li>
                        </ul>
                    </li>
                    <li><strong>å­˜å‚¨ä¼˜åŒ–ï¼š</strong>
                        <ul>
                            <li>ä½¿ç”¨å•ç«¯å£ä»£æ›¿åŒç«¯å£RAM</li>
                            <li>å¯„å­˜å™¨æ–‡ä»¶æ”¹ä¸ºåˆ†å¸ƒå¼RAM</li>
                            <li>å‹ç¼©å­˜å‚¨æ ¼å¼</li>
                        </ul>
                    </li>
                    <li><strong>é€»è¾‘ä¼˜åŒ–ï¼š</strong>
                        <ul>
                            <li>å¸ƒå°”ä¼˜åŒ–å’Œé€»è¾‘ç®€åŒ–</li>
                            <li>å¸¸æ•°ä¼ æ’­å’Œæ­»ä»£ç æ¶ˆé™¤</li>
                            <li>FSMç¼–ç ä¼˜åŒ–</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <div class="info-box">
                <p><strong>é¢ç§¯ä¼˜åŒ–å‰åå¯¹æ¯”ï¼š</strong></p>
                <p>ä»¥ä¸€ä¸ª16Ã—16 MACé˜µåˆ—ä¸ºä¾‹ï¼š</p>
                <ul>
                    <li><strong>ä¼˜åŒ–å‰ï¼š</strong></li>
                    <ul>
                        <li>256ä¸ªç‹¬ç«‹ä¹˜æ³•å™¨ï¼š256 Ã— 1000 gates = 256K gates</li>
                        <li>256ä¸ªç‹¬ç«‹ç´¯åŠ å™¨ï¼š256 Ã— 500 gates = 128K gates</li>
                        <li>æ€»é¢ç§¯ï¼š384K gates</li>
                    </ul>
                    <li><strong>ä¼˜åŒ–åï¼ˆ4:1èµ„æºå…±äº«ï¼‰ï¼š</strong></li>
                    <ul>
                        <li>64ä¸ªå…±äº«ä¹˜æ³•å™¨ï¼š64 Ã— 1000 gates = 64K gates</li>
                        <li>256ä¸ªç´¯åŠ å™¨ï¼š256 Ã— 500 gates = 128K gates</li>
                        <li>ä»²è£å’Œæ§åˆ¶é€»è¾‘ï¼š20K gates</li>
                        <li>æ€»é¢ç§¯ï¼š212K gates</li>
                        <li><strong>é¢ç§¯èŠ‚çœï¼š45%</strong></li>
                    </ul>
                </ul>
                <p><strong>æ€§èƒ½å½±å“ï¼š</strong>ååé‡é™ä½åˆ°25%ï¼Œä½†é€šè¿‡æé«˜é¢‘ç‡å¯éƒ¨åˆ†è¡¥å¿ã€‚é€‚ç”¨äºå¯¹å»¶è¿Ÿä¸æ•æ„Ÿçš„åº”ç”¨ã€‚</p>
            </div>

            <h3>6.7 æ—¶åºæ”¶æ•›</h3>
            
            <p>æ—¶åºæ”¶æ•›æ˜¯RTLè®¾è®¡åˆ°ç‰©ç†å®ç°çš„å…³é”®æŒ‘æˆ˜ï¼Œéœ€è¦åœ¨è®¾è®¡æ—©æœŸå°±è€ƒè™‘æ—¶åºé—®é¢˜ã€‚</p>

            <h4>6.7.1 æµæ°´çº¿è®¾è®¡</h4>
            <div class="code-block">
// ä¼˜åŒ–çš„æ·±åº¦æµæ°´çº¿MACé˜µåˆ— - Verilogç‰ˆæœ¬
module PipelinedMACArray #(
    parameter DATA_WIDTH = 8,
    parameter ARRAY_DIM = 4,
    parameter PIPE_STAGES = 3,  // æµæ°´çº¿çº§æ•°
    parameter ACC_WIDTH = 32     // ç´¯åŠ å™¨ä½å®½
)(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire clear_acc,        // æ¸…é™¤ç´¯åŠ å™¨
    
    input wire [DATA_WIDTH-1:0] a_in [ARRAY_DIM-1:0],
    input wire [DATA_WIDTH-1:0] b_in [ARRAY_DIM-1:0][ARRAY_DIM-1:0],
    output wire [ACC_WIDTH-1:0] c_out [ARRAY_DIM-1:0][ARRAY_DIM-1:0],
    output reg valid_out
);

    // æµæ°´çº¿å¯„å­˜å™¨
    reg [DATA_WIDTH-1:0] a_pipe [PIPE_STAGES:0][ARRAY_DIM-1:0];
    reg [DATA_WIDTH-1:0] b_pipe [PIPE_STAGES:0][ARRAY_DIM-1:0][ARRAY_DIM-1:0];
    reg valid_pipe [PIPE_STAGES:0];
    
    // è¾“å…¥æµæ°´çº¿ï¼ˆä¼˜åŒ–ï¼šä½¿ç”¨éé˜»å¡èµ‹å€¼å‡å°‘å»¶è¿Ÿï¼‰
    integer s, i, j;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (s = 0; s <= PIPE_STAGES; s = s + 1) begin
                valid_pipe[s] <= 1'b0;
                for (i = 0; i < ARRAY_DIM; i = i + 1) begin
                    a_pipe[s][i] <= 0;
                    for (j = 0; j < ARRAY_DIM; j = j + 1) begin
                        b_pipe[s][i][j] <= 0;
                    end
                end
            end
        end else if (enable) begin
            // ç¬¬ä¸€çº§
            a_pipe[0] <= a_in;
            b_pipe[0] <= b_in;
            valid_pipe[0] <= 1'b1;
            
            // æµæ°´çº¿ä¼ æ’­
            for (s = 1; s <= PIPE_STAGES; s = s + 1) begin
                a_pipe[s] <= a_pipe[s-1];
                b_pipe[s] <= b_pipe[s-1];
                valid_pipe[s] <= valid_pipe[s-1];
            end
        end else begin
            // ä¸ä½¿èƒ½æ—¶æ¸…é™¤valid
            for (s = 0; s <= PIPE_STAGES; s = s + 1) begin
                valid_pipe[s] <= 1'b0;
            end
        end
    end
    
    // è¾“å‡ºvalidä¿¡å·
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            valid_out <= 1'b0;
        end else begin
            valid_out <= valid_pipe[PIPE_STAGES];
        end
    end
    
    // MACå•å…ƒå®ä¾‹åŒ–ï¼ˆä¼˜åŒ–åçš„æµæ°´çº¿ç»“æ„ï¼‰
    genvar gi, gj;
    generate
        for (gi = 0; gi < ARRAY_DIM; gi = gi + 1) begin : row_gen
            for (gj = 0; gj < ARRAY_DIM; gj = gj + 1) begin : col_gen
                OptimizedPipelinedMAC #(
                    .DATA_WIDTH(DATA_WIDTH),
                    .ACC_WIDTH(ACC_WIDTH),
                    .INTERNAL_PIPES(2)  // MACå†…éƒ¨æµæ°´çº¿
                ) u_mac (
                    .clk(clk),
                    .rst_n(rst_n),
                    .enable(valid_pipe[PIPE_STAGES]),
                    .clear(clear_acc),
                    .a(a_pipe[PIPE_STAGES][gi]),
                    .b(b_pipe[PIPE_STAGES][gi][gj]),
                    .acc_out(c_out[gi][gj])
                );
            end
        end
    endgenerate

endmodule

// ä¼˜åŒ–çš„æµæ°´çº¿MACå•å…ƒ
module OptimizedPipelinedMAC #(
    parameter DATA_WIDTH = 8,
    parameter ACC_WIDTH = 32,
    parameter INTERNAL_PIPES = 2
)(
    input wire clk,
    input wire rst_n,
    input wire enable,
    input wire clear,
    input wire signed [DATA_WIDTH-1:0] a,
    input wire signed [DATA_WIDTH-1:0] b,
    output wire signed [ACC_WIDTH-1:0] acc_out
);

    // ä¹˜æ³•å™¨æµæ°´çº¿å¯„å­˜å™¨
    reg signed [DATA_WIDTH-1:0] a_reg, b_reg;
    reg signed [2*DATA_WIDTH-1:0] mult_pipe [INTERNAL_PIPES:0];
    reg enable_pipe [INTERNAL_PIPES+1:0];
    
    // ç´¯åŠ å™¨
    reg signed [ACC_WIDTH-1:0] acc_reg;
    
    // æµæ°´çº¿ä¹˜æ³•
    integer k;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            a_reg <= 0;
            b_reg <= 0;
            for (k = 0; k <= INTERNAL_PIPES; k = k + 1) begin
                mult_pipe[k] <= 0;
            end
            for (k = 0; k <= INTERNAL_PIPES+1; k = k + 1) begin
                enable_pipe[k] <= 1'b0;
            end
        end else begin
            // è¾“å…¥å¯„å­˜
            a_reg <= a;
            b_reg <= b;
            enable_pipe[0] <= enable;
            
            // ä¹˜æ³•ç¬¬ä¸€çº§
            mult_pipe[0] <= a_reg * b_reg;
            enable_pipe[1] <= enable_pipe[0];
            
            // ä¹˜æ³•æµæ°´çº¿
            for (k = 1; k <= INTERNAL_PIPES; k = k + 1) begin
                mult_pipe[k] <= mult_pipe[k-1];
                enable_pipe[k+1] <= enable_pipe[k];
            end
        end
    end
    
    // ç´¯åŠ ï¼ˆå¸¦æ¸…é›¶æ§åˆ¶ï¼‰
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            acc_reg <= 0;
        end else if (clear) begin
            acc_reg <= 0;
        end else if (enable_pipe[INTERNAL_PIPES+1]) begin
            acc_reg <= acc_reg + {{(ACC_WIDTH-2*DATA_WIDTH){mult_pipe[INTERNAL_PIPES][2*DATA_WIDTH-1]}}, 
                                  mult_pipe[INTERNAL_PIPES]};
        end
    end
    
    assign acc_out = acc_reg;

endmodule
            </div>
            
            <div class="code-block">
// Chiselç‰ˆæœ¬çš„æ·±åº¦æµæ°´çº¿MACé˜µåˆ—
import chisel3._
import chisel3.util._

class PipelinedMACArray(dataWidth: Int = 8, arrayDim: Int = 4, pipeStages: Int = 3, accWidth: Int = 32) extends Module {
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val clearAcc = Input(Bool())
    val aIn = Input(Vec(arrayDim, SInt(dataWidth.W)))
    val bIn = Input(Vec(arrayDim, Vec(arrayDim, SInt(dataWidth.W))))
    val cOut = Output(Vec(arrayDim, Vec(arrayDim, SInt(accWidth.W))))
    val validOut = Output(Bool())
  })
  
  // æµæ°´çº¿å¯„å­˜å™¨
  val aPipe = RegInit(VecInit(Seq.fill(pipeStages+1)(VecInit(Seq.fill(arrayDim)(0.S(dataWidth.W))))))
  val bPipe = RegInit(VecInit(Seq.fill(pipeStages+1)(VecInit(Seq.fill(arrayDim)(VecInit(Seq.fill(arrayDim)(0.S(dataWidth.W))))))))
  val validPipe = RegInit(VecInit(Seq.fill(pipeStages+1)(false.B)))
  
  // è¾“å…¥æµæ°´çº¿
  when (io.enable) {
    aPipe(0) := io.aIn
    bPipe(0) := io.bIn
    validPipe(0) := true.B
    
    for (s <- 1 to pipeStages) {
      aPipe(s) := aPipe(s-1)
      bPipe(s) := bPipe(s-1)
      validPipe(s) := validPipe(s-1)
    }
  }.otherwise {
    validPipe.foreach(_ := false.B)
  }
  
  io.validOut := validPipe(pipeStages)
  
  // MACå•å…ƒé˜µåˆ—
  val macUnits = Seq.fill(arrayDim, arrayDim) {
    Module(new OptimizedPipelinedMAC(dataWidth, accWidth, 2))
  }
  
  for (i <- 0 until arrayDim; j <- 0 until arrayDim) {
    macUnits(i)(j).io.enable := validPipe(pipeStages)
    macUnits(i)(j).io.clear := io.clearAcc
    macUnits(i)(j).io.a := aPipe(pipeStages)(i)
    macUnits(i)(j).io.b := bPipe(pipeStages)(i)(j)
    io.cOut(i)(j) := macUnits(i)(j).io.accOut
  }
}

// ç»†ç²’åº¦æµæ°´çº¿MAC
module PipelinedMAC #(
    parameter DATA_WIDTH = 8,
    parameter ACC_WIDTH = 32,
    parameter INTERNAL_PIPES = 2
)(
    input wire clk,
    input wire rst_n,
    input wire [DATA_WIDTH-1:0] a,
    input wire [DATA_WIDTH-1:0] b,
    output wire [ACC_WIDTH-1:0] acc_out
);

    // ä¹˜æ³•å™¨æµæ°´çº¿
    reg [DATA_WIDTH-1:0] a_reg, b_reg;
    reg [2*DATA_WIDTH-1:0] mult_pipe [INTERNAL_PIPES-1:0];
    
    // ç´¯åŠ å™¨
    reg [ACC_WIDTH-1:0] acc_reg;
    
    // æµæ°´çº¿ä¹˜æ³•
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            a_reg <= 0;
            b_reg <= 0;
            for (int i = 0; i < INTERNAL_PIPES; i++) begin
                mult_pipe[i] <= 0;
            end
        end else begin
            // è¾“å…¥å¯„å­˜
            a_reg <= a;
            b_reg <= b;
            
            // ç¬¬ä¸€çº§ä¹˜æ³•
            mult_pipe[0] <= a_reg * b_reg;
            
            // ä¹˜æ³•æµæ°´çº¿
            for (int i = 1; i < INTERNAL_PIPES; i++) begin
                mult_pipe[i] <= mult_pipe[i-1];
            end
        end
    end
    
    // ç´¯åŠ 
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            acc_reg <= 0;
        end else begin
            acc_reg <= acc_reg + {{(ACC_WIDTH-2*DATA_WIDTH){mult_pipe[INTERNAL_PIPES-1][2*DATA_WIDTH-1]}}, 
                                  mult_pipe[INTERNAL_PIPES-1]};
        end
    end
    
    assign acc_out = acc_reg;

endmodule
            </div>

            <h4>6.7.2 æ—¶åºä¼˜åŒ–æŠ€æœ¯</h4>
            <div class="info-box">
                <p><strong>æµæ°´çº¿æ·±åº¦ä¸æ€§èƒ½æƒè¡¡åˆ†æï¼š</strong></p>
                <table class="comparison-table">
                    <tr>
                        <th>æµæ°´çº¿æ·±åº¦</th>
                        <th>æœ€å¤§é¢‘ç‡</th>
                        <th>å»¶è¿Ÿ(cycles)</th>
                        <th>ååé‡</th>
                        <th>é¢ç§¯å¼€é”€</th>
                        <th>åŠŸè€—</th>
                    </tr>
                    <tr>
                        <td>æ— æµæ°´çº¿</td>
                        <td>200 MHz</td>
                        <td>1</td>
                        <td>200 MOPS</td>
                        <td>åŸºå‡†</td>
                        <td>åŸºå‡†</td>
                    </tr>
                    <tr>
                        <td>2çº§æµæ°´çº¿</td>
                        <td>400 MHz</td>
                        <td>2</td>
                        <td>400 MOPS</td>
                        <td>+5%</td>
                        <td>+10%</td>
                    </tr>
                    <tr>
                        <td>4çº§æµæ°´çº¿</td>
                        <td>667 MHz</td>
                        <td>4</td>
                        <td>667 MOPS</td>
                        <td>+12%</td>
                        <td>+20%</td>
                    </tr>
                    <tr>
                        <td>8çº§æµæ°´çº¿</td>
                        <td>800 MHz</td>
                        <td>8</td>
                        <td>800 MOPS</td>
                        <td>+25%</td>
                        <td>+35%</td>
                    </tr>
                </table>
                <p><strong>ç»“è®ºï¼š</strong>æµæ°´çº¿æ·±åº¦å¢åŠ å¸¦æ¥é€’å‡çš„æ€§èƒ½æ”¶ç›Šï¼ŒåŒæ—¶é¢ç§¯å’ŒåŠŸè€—å¼€é”€é€’å¢ã€‚æœ€ä¼˜æ·±åº¦éœ€è¦æ ¹æ®å…·ä½“åº”ç”¨åœºæ™¯æƒè¡¡ã€‚</p>
            </div>
            
            <div class="code-block">
// ä¼˜åŒ–çš„é‡å®šæ—¶ï¼ˆRetimingï¼‰ç¤ºä¾‹ - Verilogç‰ˆæœ¬
module RetimingExample #(
    parameter WIDTH = 32
)(
    input wire clk,
    input wire rst_n,
    input wire [WIDTH-1:0] a, b, c, d,
    input wire valid_in,
    output reg [WIDTH-1:0] result,
    output reg valid_out
);

    // åŸå§‹è®¾è®¡ï¼šé•¿ç»„åˆè·¯å¾„
    // assign result = ((a + b) * c) + d;
    
    // ä¼˜åŒ–åï¼šå¹³è¡¡çš„æµæ°´çº¿ï¼Œå¸¦æœ‰æ•ˆä¿¡å·ä¼ æ’­
    reg [WIDTH-1:0] sum_ab;
    reg [WIDTH-1:0] c_reg1, c_reg2;
    reg [WIDTH-1:0] d_reg1, d_reg2, d_reg3;
    reg [WIDTH*2-1:0] product;
    reg valid_stage1, valid_stage2, valid_stage3;
    
    // ä¸ºäº†æ›´å¥½çš„æ—¶åºï¼Œå°†ä¹˜æ³•åˆ†è§£ä¸ºéƒ¨åˆ†ç§¯
    reg [WIDTH-1:0] partial_prod_low, partial_prod_high;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sum_ab <= 0;
            c_reg1 <= 0;
            c_reg2 <= 0;
            d_reg1 <= 0;
            d_reg2 <= 0;
            d_reg3 <= 0;
            partial_prod_low <= 0;
            partial_prod_high <= 0;
            product <= 0;
            result <= 0;
            valid_stage1 <= 0;
            valid_stage2 <= 0;
            valid_stage3 <= 0;
            valid_out <= 0;
        end else begin
            // Stage 1: åŠ æ³•å’Œå¯„å­˜å™¨
            sum_ab <= a + b;
            c_reg1 <= c;
            d_reg1 <= d;
            valid_stage1 <= valid_in;
            
            // Stage 2: éƒ¨åˆ†ç§¯è®¡ç®—
            partial_prod_low <= sum_ab[WIDTH/2-1:0] * c_reg1[WIDTH/2-1:0];
            partial_prod_high <= sum_ab[WIDTH-1:WIDTH/2] * c_reg1[WIDTH-1:WIDTH/2];
            c_reg2 <= c_reg1;
            d_reg2 <= d_reg1;
            valid_stage2 <= valid_stage1;
            
            // Stage 3: å®Œæ•´ä¹˜æ³•ç»“æœ
            product <= {partial_prod_high, partial_prod_low} + 
                      (sum_ab[WIDTH/2-1:0] * c_reg2[WIDTH-1:WIDTH/2]) << (WIDTH/2) +
                      (sum_ab[WIDTH-1:WIDTH/2] * c_reg2[WIDTH/2-1:0]) << (WIDTH/2);
            d_reg3 <= d_reg2;
            valid_stage3 <= valid_stage2;
            
            // Stage 4: æœ€ç»ˆåŠ æ³•å’Œé¥±å’Œ
            if (valid_stage3) begin
                if (product[WIDTH*2-1:WIDTH] != 0 && product[WIDTH*2-1]) begin
                    // è´Ÿæ•°æº¢å‡º
                    result <= {1'b1, {(WIDTH-1){1'b0}}};
                end else if (product[WIDTH*2-1:WIDTH] != 0 && !product[WIDTH*2-1]) begin
                    // æ­£æ•°æº¢å‡º
                    result <= {1'b0, {(WIDTH-1){1'b1}}};
                end else begin
                    result <= product[WIDTH-1:0] + d_reg3;
                end
            end
            valid_out <= valid_stage3;
        end
    end

endmodule
            </div>
            
            <p>Chiselç‰ˆæœ¬çš„é‡å®šæ—¶ç¤ºä¾‹ï¼š</p>
            <div class="code-block">
import chisel3._
import chisel3.util._

class RetimingExample(width: Int = 32) extends Module {
  val io = IO(new Bundle {
    val a = Input(UInt(width.W))
    val b = Input(UInt(width.W))
    val c = Input(UInt(width.W))
    val d = Input(UInt(width.W))
    val valid_in = Input(Bool())
    val result = Output(UInt(width.W))
    val valid_out = Output(Bool())
  })
  
  // Stage 1: åŠ æ³•
  val sum_ab = RegNext(io.a + io.b, 0.U)
  val c_reg1 = RegNext(io.c, 0.U)
  val d_reg1 = RegNext(io.d, 0.U)
  val valid_stage1 = RegNext(io.valid_in, false.B)
  
  // Stage 2: éƒ¨åˆ†ç§¯
  val partial_prod_low = RegNext(
    sum_ab(width/2-1, 0) * c_reg1(width/2-1, 0), 0.U
  )
  val partial_prod_high = RegNext(
    sum_ab(width-1, width/2) * c_reg1(width-1, width/2), 0.U
  )
  val c_reg2 = RegNext(c_reg1, 0.U)
  val d_reg2 = RegNext(d_reg1, 0.U)
  val valid_stage2 = RegNext(valid_stage1, false.B)
  
  // Stage 3: å®Œæ•´ä¹˜æ³•
  val cross_prod1 = sum_ab(width/2-1, 0) * c_reg2(width-1, width/2)
  val cross_prod2 = sum_ab(width-1, width/2) * c_reg2(width/2-1, 0)
  val product = RegNext(
    Cat(partial_prod_high, partial_prod_low) +
    (cross_prod1 << (width/2)) +
    (cross_prod2 << (width/2)), 0.U
  )
  val d_reg3 = RegNext(d_reg2, 0.U)
  val valid_stage3 = RegNext(valid_stage2, false.B)
  
  // Stage 4: æœ€ç»ˆç»“æœ
  val raw_result = product(width-1, 0) + d_reg3
  
  // é¥±å’Œé€»è¾‘
  val overflow = product(width*2-1, width).orR && !product(width*2-1)
  val underflow = product(width*2-1, width).orR && product(width*2-1)
  
  io.result := RegEnable(
    MuxCase(raw_result, Seq(
      overflow -> Cat(0.U(1.W), Fill(width-1, 1.U)),
      underflow -> Cat(1.U(1.W), Fill(width-1, 0.U))
    )),
    0.U,
    valid_stage3
  )
  io.valid_out := RegNext(valid_stage3, false.B)
}

// ä¼˜åŒ–çš„é€»è¾‘å¤åˆ¶è§£å†³æ‰‡å‡ºé—®é¢˜ - Verilogç‰ˆæœ¬
module FanoutOptimization #(
    parameter WIDTH = 8,
    parameter FANOUT = 64
)(
    input wire clk,
    input wire rst_n,
    input wire [WIDTH-1:0] data_in,
    input wire valid_in,
    input wire enable,
    output reg [WIDTH-1:0] data_out [FANOUT-1:0],
    output reg valid_out
);

    // æ‰‡å‡ºæ ‘ï¼šä½¿ç”¨å¤šçº§ç¼“å†²å’Œæµæ°´çº¿
    localparam TREE_LEVELS = 3;  // log4(64) = 3
    localparam FANOUT_PER_LEVEL = 4;
    
    // ä¸­é—´ç¼“å†²çº§å’Œæœ‰æ•ˆä¿¡å·
    reg [WIDTH-1:0] buffer_l1 [3:0];
    reg [WIDTH-1:0] buffer_l2 [15:0];
    reg enable_l1, enable_l2, enable_l3;
    reg valid_l1, valid_l2, valid_l3;
    
    // è¾“å…¥å¯„å­˜å™¨ï¼Œå‡å°‘è¾“å…¥ç«¯å£çš„è´Ÿè½½
    reg [WIDTH-1:0] data_in_reg;
    reg enable_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            data_in_reg <= 0;
            enable_reg <= 0;
        end else begin
            data_in_reg <= data_in;
            enable_reg <= enable;
        end
    end
    
    // ç¬¬ä¸€çº§ï¼š1->4 å¸¦æœ‰æ•ˆä¿¡å·ä¼ æ’­
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < 4; i++) buffer_l1[i] <= 0;
            enable_l1 <= 0;
            valid_l1 <= 0;
        end else begin
            if (enable_reg) begin
                // ä½¿ç”¨å¾ªç¯å±•å¼€å‡å°‘é€»è¾‘å»¶è¿Ÿ
                buffer_l1[0] <= data_in_reg;
                buffer_l1[1] <= data_in_reg;
                buffer_l1[2] <= data_in_reg;
                buffer_l1[3] <= data_in_reg;
            end
            enable_l1 <= enable_reg;
            valid_l1 <= valid_in && enable_reg;
        end
    end
    
    // ç¬¬äºŒçº§ï¼š4->16 å¸¦ç¼“å†²å™¨é€‰æ‹©é€»è¾‘
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < 16; i++) buffer_l2[i] <= 0;
            enable_l2 <= 0;
            valid_l2 <= 0;
        end else begin
            if (enable_l1) begin
                // æ‰‹åŠ¨å±•å¼€ä»¥ä¼˜åŒ–æ—¶åº
                buffer_l2[0]  <= buffer_l1[0];
                buffer_l2[1]  <= buffer_l1[0];
                buffer_l2[2]  <= buffer_l1[0];
                buffer_l2[3]  <= buffer_l1[0];
                buffer_l2[4]  <= buffer_l1[1];
                buffer_l2[5]  <= buffer_l1[1];
                buffer_l2[6]  <= buffer_l1[1];
                buffer_l2[7]  <= buffer_l1[1];
                buffer_l2[8]  <= buffer_l1[2];
                buffer_l2[9]  <= buffer_l1[2];
                buffer_l2[10] <= buffer_l1[2];
                buffer_l2[11] <= buffer_l1[2];
                buffer_l2[12] <= buffer_l1[3];
                buffer_l2[13] <= buffer_l1[3];
                buffer_l2[14] <= buffer_l1[3];
                buffer_l2[15] <= buffer_l1[3];
            end
            enable_l2 <= enable_l1;
            valid_l2 <= valid_l1;
        end
    end
    
    // ç¬¬ä¸‰çº§ï¼š16->64 æœ€ç»ˆè¾“å‡º
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (int i = 0; i < FANOUT; i++) data_out[i] <= 0;
            enable_l3 <= 0;
            valid_out <= 0;
        end else begin
            if (enable_l2) begin
                // åˆ†ç»„å¤„ç†ä»¥å‡å°‘æ¯ä¸ªæ—¶é’Ÿå‘¨æœŸçš„è´Ÿè½½
                for (int j = 0; j < 16; j++) begin
                    data_out[j*4]   <= buffer_l2[j];
                    data_out[j*4+1] <= buffer_l2[j];
                    data_out[j*4+2] <= buffer_l2[j];
                    data_out[j*4+3] <= buffer_l2[j];
                end
            end
            enable_l3 <= enable_l2;
            valid_out <= valid_l2;
        end
    end

endmodule
            </div>
            
            <p>Chiselç‰ˆæœ¬çš„æ‰‡å‡ºä¼˜åŒ–ï¼š</p>
            <div class="code-block">
import chisel3._
import chisel3.util._

class FanoutOptimization(width: Int = 8, fanout: Int = 64) extends Module {
  val io = IO(new Bundle {
    val data_in = Input(UInt(width.W))
    val valid_in = Input(Bool())
    val enable = Input(Bool())
    val data_out = Output(Vec(fanout, UInt(width.W)))
    val valid_out = Output(Bool())
  })
  
  // å±‚çº§å‚æ•°
  val treeLevels = 3
  val fanoutPerLevel = 4
  
  // è¾“å…¥å¯„å­˜å™¨
  val dataInReg = RegNext(io.data_in, 0.U)
  val enableReg = RegNext(io.enable, false.B)
  
  // ç¬¬ä¸€çº§ï¼š1->4
  val bufferL1 = Reg(Vec(4, UInt(width.W)))
  val enableL1 = RegNext(enableReg, false.B)
  val validL1 = RegNext(io.valid_in && enableReg, false.B)
  
  when(enableReg) {
    bufferL1.foreach(_ := dataInReg)
  }
  
  // ç¬¬äºŒçº§ï¼š4->16
  val bufferL2 = Reg(Vec(16, UInt(width.W)))
  val enableL2 = RegNext(enableL1, false.B)
  val validL2 = RegNext(validL1, false.B)
  
  when(enableL1) {
    for (i <- 0 until 16) {
      bufferL2(i) := bufferL1(i / 4)
    }
  }
  
  // ç¬¬ä¸‰çº§ï¼š16->64
  val dataOutReg = Reg(Vec(fanout, UInt(width.W)))
  val validOutReg = RegNext(validL2, false.B)
  
  when(enableL2) {
    for (i <- 0 until fanout) {
      dataOutReg(i) := bufferL2(i / 4)
    }
  }
  
  io.data_out := dataOutReg
  io.valid_out := validOutReg
  
  // å¯é€‰ï¼šæ·»åŠ æ€§èƒ½è®¡æ•°å™¨
  val updateCounter = RegInit(0.U(32.W))
  when(enableL2 && validL2) {
    updateCounter := updateCounter + 1.U
  }
}
            </div>

            <h4>6.7.3 æ—¶åºæ”¶æ•›ç­–ç•¥</h4>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th>é˜¶æ®µ</th>
                            <th>ç­–ç•¥</th>
                            <th>å·¥å…·/æ–¹æ³•</th>
                            <th>å½±å“</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>RTLè®¾è®¡</td>
                            <td>åˆç†åˆ’åˆ†æµæ°´çº¿</td>
                            <td>æ¶æ„æ¢ç´¢ã€æ€§èƒ½å»ºæ¨¡</td>
                            <td>æœ€å¤§å½±å“</td>
                        </tr>
                        <tr>
                            <td>ç»¼åˆ</td>
                            <td>çº¦æŸä¼˜åŒ–ã€é€»è¾‘é‡æ„</td>
                            <td>compile_ultraã€retime</td>
                            <td>ä¸­ç­‰å½±å“</td>
                        </tr>
                        <tr>
                            <td>å¸ƒå±€</td>
                            <td>å±‚æ¬¡åŒ–å¸ƒå±€ã€åŒºåŸŸçº¦æŸ</td>
                            <td>floorplanã€region</td>
                            <td>ä¸­ç­‰å½±å“</td>
                        </tr>
                        <tr>
                            <td>æ—¶é’Ÿæ ‘</td>
                            <td>å¹³è¡¡æ—¶é’Ÿåæ–œ</td>
                            <td>CTSã€useful skew</td>
                            <td>å°å¹…æ”¹å–„</td>
                        </tr>
                        <tr>
                            <td>å¸ƒçº¿å</td>
                            <td>ECOä¿®å¤</td>
                            <td>sizingã€buffering</td>
                            <td>æœ‰é™æ”¹å–„</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="exercise">
                <h4>ç»ƒä¹  6.6-6.7</h4>
                <div class="question">
                    <p><strong>é¢˜ç›®ï¼š</strong>è®¾è®¡ä¸€ä¸ªé«˜æ€§èƒ½çŸ©é˜µä¹˜æ³•å•å…ƒï¼Œè¦æ±‚ï¼š
                    1) æ”¯æŒ4Ã—4çŸ©é˜µä¹˜æ³•
                    2) ä½¿ç”¨è„‰åŠ¨é˜µåˆ—æ¶æ„
                    3) å®ç°3çº§æµæ°´çº¿
                    4) ä¼˜åŒ–é¢ç§¯å’Œæ—¶åº</p>
                    <details class="hint">
                        <summary>ğŸ’¡ æç¤º</summary>
                        <p>æ€è€ƒæ–¹å‘ï¼šè„‰åŠ¨é˜µåˆ—ä¸­æ•°æ®æµåŠ¨éœ€è¦ç²¾å¿ƒè®¾è®¡ã€‚ä½¿ç”¨æ•°æ®skewæ¥ç¡®ä¿æ­£ç¡®çš„è®¡ç®—æ—¶åºã€‚3çº§æµæ°´çº¿å¯ä»¥åˆ†ä¸ºï¼šè¾“å…¥å¯„å­˜ã€ä¹˜æ³•ã€ç´¯åŠ ã€‚é¢ç§¯ä¼˜åŒ–å¯ä»¥è€ƒè™‘èµ„æºå…±äº«å’Œä½å®½ä¼˜åŒ–ã€‚</p>
                    </details>
                    <button class="toggle-answer">æ˜¾ç¤ºç­”æ¡ˆ</button>
                    <div class="answer">
                        <div class="code-block">
// ä¼˜åŒ–çš„è„‰åŠ¨çŸ©é˜µä¹˜æ³•å™¨ - Verilogç‰ˆæœ¬
module SystolicMatrixMultiplier #(
    parameter DATA_WIDTH = 16,
    parameter MATRIX_SIZE = 4,
    parameter ACC_WIDTH = DATA_WIDTH * 2 + $clog2(MATRIX_SIZE)
)(
    input wire clk,
    input wire rst_n,
    input wire start,
    input wire valid_in,
    
    // çŸ©é˜µè¾“å…¥ï¼ˆæŒ‰å¯¹è§’çº¿è¾“å…¥ï¼‰
    input wire [DATA_WIDTH-1:0] a_in [MATRIX_SIZE-1:0],
    input wire [DATA_WIDTH-1:0] b_in [MATRIX_SIZE-1:0],
    
    // ç»“æœè¾“å‡º
    output reg [ACC_WIDTH-1:0] c_out [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0],
    output reg done,
    output reg valid_out
);

    // PEå†…éƒ¨æµæ°´çº¿å¯„å­˜å™¨
    reg [DATA_WIDTH-1:0] pe_a_reg1 [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    reg [DATA_WIDTH-1:0] pe_a_reg2 [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    reg [DATA_WIDTH-1:0] pe_b_reg1 [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    reg [DATA_WIDTH-1:0] pe_b_reg2 [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    reg [DATA_WIDTH*2-1:0] pe_mult [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    reg [ACC_WIDTH-1:0] pe_acc [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    
    // è¾“å…¥å»¶è¿Ÿé“¾ï¼ˆå®ç°å¯¹è§’çº¿è¾“å…¥ï¼‰
    reg [DATA_WIDTH-1:0] a_delay [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    reg [DATA_WIDTH-1:0] b_delay [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    reg valid_delay [MATRIX_SIZE-1:0][MATRIX_SIZE-1:0];
    
    // æ§åˆ¶è®¡æ•°å™¨å’ŒçŠ¶æ€
    reg [5:0] cycle_count;
    reg [2:0] state;
    localparam IDLE = 3'b000;
    localparam COMPUTING = 3'b001;
    localparam DRAINING = 3'b010;
    localparam OUTPUT = 3'b011;
    
    // è¾“å…¥å»¶è¿Ÿé“¾å®ç°
    genvar i, j;
    generate
        for (i = 0; i < MATRIX_SIZE; i = i + 1) begin : input_delay
            always @(posedge clk or negedge rst_n) begin
                if (!rst_n) begin
                    for (int k = 0; k <= i; k++) begin
                        a_delay[i][k] <= 0;
                        b_delay[i][k] <= 0;
                        valid_delay[i][k] <= 0;
                    end
                end else if (state == COMPUTING || state == DRAINING) begin
                    // AçŸ©é˜µè¡Œå»¶è¿Ÿ
                    a_delay[i][0] <= (state == COMPUTING) ? a_in[i] : 0;
                    valid_delay[i][0] <= (state == COMPUTING) ? valid_in : 0;
                    for (int k = 1; k <= i; k++) begin
                        a_delay[i][k] <= a_delay[i][k-1];
                        valid_delay[i][k] <= valid_delay[i][k-1];
                    end
                    
                    // BçŸ©é˜µåˆ—å»¶è¿Ÿ
                    b_delay[i][0] <= (state == COMPUTING) ? b_in[i] : 0;
                    for (int k = 1; k <= i; k++) begin
                        b_delay[i][k] <= b_delay[i][k-1];
                    end
                end
            end
        end
    endgenerate
    
    // è„‰åŠ¨é˜µåˆ—PE - å®Œå…¨æµæ°´çº¿åŒ–
    generate
        for (i = 0; i < MATRIX_SIZE; i = i + 1) begin : pe_row
            for (j = 0; j < MATRIX_SIZE; j = j + 1) begin : pe_col
                
                // PEè¾“å…¥ä¿¡å·
                wire [DATA_WIDTH-1:0] a_input = (j == 0) ? a_delay[i][i] : pe_a_reg2[i][j-1];
                wire [DATA_WIDTH-1:0] b_input = (i == 0) ? b_delay[j][j] : pe_b_reg2[i-1][j];
                wire valid_input = (i == 0 && j == 0) ? valid_delay[0][0] :
                                  (j == 0) ? valid_delay[i][i] :
                                  (i == 0) ? valid_delay[j][j] : 1'b1;
                
                always @(posedge clk or negedge rst_n) begin
                    if (!rst_n) begin
                        pe_a_reg1[i][j] <= 0;
                        pe_a_reg2[i][j] <= 0;
                        pe_b_reg1[i][j] <= 0;
                        pe_b_reg2[i][j] <= 0;
                        pe_mult[i][j] <= 0;
                        pe_acc[i][j] <= 0;
                    end else begin
                        // Stage 1: è¾“å…¥å¯„å­˜
                        pe_a_reg1[i][j] <= a_input;
                        pe_b_reg1[i][j] <= b_input;
                        
                        // Stage 2: ä¼ æ’­å’Œä¹˜æ³•å‡†å¤‡
                        pe_a_reg2[i][j] <= pe_a_reg1[i][j];
                        pe_b_reg2[i][j] <= pe_b_reg1[i][j];
                        
                        // Stage 3: ä¹˜æ³•
                        pe_mult[i][j] <= pe_a_reg1[i][j] * pe_b_reg1[i][j];
                        
                        // Stage 4: ç´¯åŠ 
                        if (start) begin
                            pe_acc[i][j] <= 0;
                        end else if (valid_input && (state == COMPUTING || state == DRAINING)) begin
                            pe_acc[i][j] <= pe_acc[i][j] + pe_mult[i][j];
                        end
                    end
                end
            end
        end
    endgenerate
    
    // ä¸»æ§åˆ¶çŠ¶æ€æœº
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            cycle_count <= 0;
            done <= 1'b0;
            valid_out <= 1'b0;
            for (int i = 0; i < MATRIX_SIZE; i++) begin
                for (int j = 0; j < MATRIX_SIZE; j++) begin
                    c_out[i][j] <= 0;
                end
            end
        end else begin
            case (state)
                IDLE: begin
                    if (start) begin
                        state <= COMPUTING;
                        cycle_count <= 0;
                        done <= 1'b0;
                        valid_out <= 1'b0;
                    end
                end
                
                COMPUTING: begin
                    cycle_count <= cycle_count + 1;
                    if (cycle_count == MATRIX_SIZE - 1) begin
                        state <= DRAINING;
                        cycle_count <= 0;
                    end
                end
                
                DRAINING: begin
                    cycle_count <= cycle_count + 1;
                    if (cycle_count == 2*MATRIX_SIZE + 2) begin
                        state <= OUTPUT;
                        cycle_count <= 0;
                    end
                end
                
                OUTPUT: begin
                    // è¾“å‡ºç»“æœ
                    for (int i = 0; i < MATRIX_SIZE; i++) begin
                        for (int j = 0; j < MATRIX_SIZE; j++) begin
                            c_out[i][j] <= pe_acc[i][j];
                        end
                    end
                    done <= 1'b1;
                    valid_out <= 1'b1;
                    state <= IDLE;
                end
            endcase
        end
    end

endmodule
            </div>
            
            <p>Chiselç‰ˆæœ¬çš„è„‰åŠ¨çŸ©é˜µä¹˜æ³•å™¨ï¼š</p>
            <div class="code-block">
import chisel3._
import chisel3.util._

class SystolicMatrixMultiplier(dataWidth: Int = 16, matrixSize: Int = 4) extends Module {
  val accWidth = dataWidth * 2 + log2Ceil(matrixSize)
  
  val io = IO(new Bundle {
    val start = Input(Bool())
    val valid_in = Input(Bool())
    val a_in = Input(Vec(matrixSize, UInt(dataWidth.W)))
    val b_in = Input(Vec(matrixSize, UInt(dataWidth.W)))
    val c_out = Output(Vec(matrixSize, Vec(matrixSize, UInt(accWidth.W))))
    val done = Output(Bool())
    val valid_out = Output(Bool())
  })
  
  // PEå†…éƒ¨çš„æµæ°´çº¿å¯„å­˜å™¨
  val peArray = Seq.fill(matrixSize, matrixSize) {
    new Bundle {
      val aReg1 = Reg(UInt(dataWidth.W))
      val aReg2 = Reg(UInt(dataWidth.W))
      val bReg1 = Reg(UInt(dataWidth.W))
      val bReg2 = Reg(UInt(dataWidth.W))
      val mult = Reg(UInt((dataWidth * 2).W))
      val acc = Reg(UInt(accWidth.W))
    }
  }
  
  // è¾“å…¥å»¶è¿Ÿé“¾
  val aDelay = Seq.tabulate(matrixSize) { i =>
    val delayChain = Module(new ShiftRegister(UInt(dataWidth.W), i + 1))
    delayChain.io.in := io.a_in(i)
    delayChain.io.enable := (state === computing) || (state === draining)
    delayChain
  }
  
  val bDelay = Seq.tabulate(matrixSize) { i =>
    val delayChain = Module(new ShiftRegister(UInt(dataWidth.W), i + 1))
    delayChain.io.in := io.b_in(i)
    delayChain.io.enable := (state === computing) || (state === draining)
    delayChain
  }
  
  // çŠ¶æ€æœº
  val idle :: computing :: draining :: output :: Nil = Enum(4)
  val state = RegInit(idle)
  val cycleCount = RegInit(0.U(6.W))
  
  // PEé˜µåˆ—è¿æ¥å’Œè®¡ç®—
  for (i <- 0 until matrixSize) {
    for (j <- 0 until matrixSize) {
      val pe = peArray(i)(j)
      
      // è¾“å…¥è¿æ¥
      val aInput = if (j == 0) aDelay(i).io.out else peArray(i)(j-1).aReg2
      val bInput = if (i == 0) bDelay(j).io.out else peArray(i-1)(j).bReg2
      
      // æµæ°´çº¿å¯„å­˜å™¨
      pe.aReg1 := aInput
      pe.bReg1 := bInput
      pe.aReg2 := pe.aReg1
      pe.bReg2 := pe.bReg1
      
      // ä¹˜æ³•å™¨
      pe.mult := pe.aReg1 * pe.bReg1
      
      // ç´¯åŠ å™¨
      when(io.start) {
        pe.acc := 0.U
      }.elsewhen((state === computing || state === draining) && io.valid_in) {
        pe.acc := pe.acc + pe.mult
      }
      
      // è¾“å‡ºè¿æ¥
      io.c_out(i)(j) := pe.acc
    }
  }
  
  // æ§åˆ¶é€»è¾‘
  switch(state) {
    is(idle) {
      when(io.start) {
        state := computing
        cycleCount := 0.U
      }
    }
    is(computing) {
      cycleCount := cycleCount + 1.U
      when(cycleCount === (matrixSize - 1).U) {
        state := draining
        cycleCount := 0.U
      }
    }
    is(draining) {
      cycleCount := cycleCount + 1.U
      when(cycleCount === (2 * matrixSize + 2).U) {
        state := output
      }
    }
    is(output) {
      state := idle
    }
  }
  
  io.done := state === output
  io.valid_out := state === output
}

// è¾…åŠ©ç§»ä½å¯„å­˜å™¨æ¨¡å—
class ShiftRegister[T <: Data](gen: T, depth: Int) extends Module {
  val io = IO(new Bundle {
    val in = Input(gen.cloneType)
    val out = Output(gen.cloneType)
    val enable = Input(Bool())
  })
  
  val regs = Reg(Vec(depth, gen.cloneType))
  
  when(io.enable) {
    regs(0) := io.in
    for (i <- 1 until depth) {
      regs(i) := regs(i - 1)
    }
  }
  
  io.out := regs(depth - 1)
}
                        </div>
                    </div>
                </div>
            </div>
        </section>
        </div>
        
        <div class="chapter-nav">
            <a href="chapter5.html" class="prev">ä¸Šä¸€ç« </a>
            <a href="chapter7.html" class="next">ä¸‹ä¸€ç« </a>
        </div>
    </div>
</body>
</html>